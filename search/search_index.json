{
    "docs": [
        {
            "location": "/", 
            "text": "Overview\n\n\nCanvas Flow is the essential companion to Unity UI, offering you a solution for easily transitioning between screens and crafting your user-interface's flow.\n\n\n\n\nEasily present \n dismiss screens \u2013 Canvases are dynamically loaded and unloaded, enabling you to build large, complex, or dynamic user-interface flows, loading only the necessary screens on demand.\n\n\nStoryboard your user-interface \u2013 Visually create the flow of your user-interface in a node-based editor to build complete screen flows without writing a line of code.\n\n\nCustomize the transitions between screens \u2013 Use one of five built-in, adjustable transition animators or build your own custom transition animations.\n\n\n\n\nQuick Start\n\n\n\n    \n\n\n\n\n\nDocumentation\n\n\n\n\nManual\n\n\nScripting Reference\n\n\n\n\nTutorials\n\n\n\n\nCreating a Custom Storyboard Hook For UI.Toggle\n\n\nCreating A Custom Transition Animator Using DOTween\n\n\n\n\nSupport\n\n\nCan't find what you're looking for? Have a query, a question, feedback, or a suggestion? (Or just want to say hi. \ud83d\udc4b)\n\n\n\n\nEmail\n\n\nForum\n\n\nTwitter\n\n\n\n\n\n\nVersion History\n\n\n\n\n\n\n\n\nVersion\n\n\nDate\n\n\nRelease Notes\n\n\n\n\n\n\n\n\n\n\nv1.1\n\n\nJune 19th 2018\n\n\n1.1 Release Notes\n\n\n\n\n\n\nv1.0\n\n\nJune 1st 2018\n\n\nInitial release", 
            "title": "Home"
        }, 
        {
            "location": "/#overview", 
            "text": "Canvas Flow is the essential companion to Unity UI, offering you a solution for easily transitioning between screens and crafting your user-interface's flow.   Easily present   dismiss screens \u2013 Canvases are dynamically loaded and unloaded, enabling you to build large, complex, or dynamic user-interface flows, loading only the necessary screens on demand.  Storyboard your user-interface \u2013 Visually create the flow of your user-interface in a node-based editor to build complete screen flows without writing a line of code.  Customize the transitions between screens \u2013 Use one of five built-in, adjustable transition animators or build your own custom transition animations.", 
            "title": "Overview"
        }, 
        {
            "location": "/#quick-start", 
            "text": "", 
            "title": "Quick Start"
        }, 
        {
            "location": "/#documentation", 
            "text": "Manual  Scripting Reference", 
            "title": "Documentation"
        }, 
        {
            "location": "/#tutorials", 
            "text": "Creating a Custom Storyboard Hook For UI.Toggle  Creating A Custom Transition Animator Using DOTween", 
            "title": "Tutorials"
        }, 
        {
            "location": "/#support", 
            "text": "Can't find what you're looking for? Have a query, a question, feedback, or a suggestion? (Or just want to say hi. \ud83d\udc4b)   Email  Forum  Twitter", 
            "title": "Support"
        }, 
        {
            "location": "/#version-history", 
            "text": "Version  Date  Release Notes      v1.1  June 19th 2018  1.1 Release Notes    v1.0  June 1st 2018  Initial release", 
            "title": "Version History"
        }, 
        {
            "location": "/manual/contents/", 
            "text": "Contents\n\n\nCanvas Controllers\n\n\n\n\nIntroduction\n\n\nCreating A Canvas Controller\n\n\nCanvas Controller Scenes\n\n\nPresentation \n Dismissal\n\n\nCanvas Controller Life Cycle\n\n\n\n\nStoryboards\n\n\n\n\nIntroduction\n\n\nCreating A Storyboard\n\n\nStoryboard Nodes\n\n\nStoryboard Transitions\n\n\nPresenting A Storyboard\n\n\nCustom Storyboard Hooks\n\n\n\n\nTransition Animators\n\n\n\n\nIntroduction\n\n\nDefault Transition Animators\n\n\nDefault Transition Animator\n\n\nFade To Color Transition Animator\n\n\nSlide Transition Animator\n\n\nScale Transition Animator\n\n\nScale And Fade Background Transition Animator\n\n\n\n\n\n\nUsing A Transition Animator\n\n\nCustom Transition Animators\n\n\n\n\nMiscellaneous\n\n\n\n\nPreferences\n\n\n\n\nTutorials\n\n\n\n\nCreating a Custom Storyboard Hook For UI.Toggle\n\n\nCreating A Custom Transition Animator Using DOTween", 
            "title": "Contents"
        }, 
        {
            "location": "/manual/contents/#contents", 
            "text": "", 
            "title": "Contents"
        }, 
        {
            "location": "/manual/contents/#canvas-controllers", 
            "text": "Introduction  Creating A Canvas Controller  Canvas Controller Scenes  Presentation   Dismissal  Canvas Controller Life Cycle", 
            "title": "Canvas Controllers"
        }, 
        {
            "location": "/manual/contents/#storyboards", 
            "text": "Introduction  Creating A Storyboard  Storyboard Nodes  Storyboard Transitions  Presenting A Storyboard  Custom Storyboard Hooks", 
            "title": "Storyboards"
        }, 
        {
            "location": "/manual/contents/#transition-animators", 
            "text": "Introduction  Default Transition Animators  Default Transition Animator  Fade To Color Transition Animator  Slide Transition Animator  Scale Transition Animator  Scale And Fade Background Transition Animator    Using A Transition Animator  Custom Transition Animators", 
            "title": "Transition Animators"
        }, 
        {
            "location": "/manual/contents/#miscellaneous", 
            "text": "Preferences", 
            "title": "Miscellaneous"
        }, 
        {
            "location": "/manual/contents/#tutorials", 
            "text": "Creating a Custom Storyboard Hook For UI.Toggle  Creating A Custom Transition Animator Using DOTween", 
            "title": "Tutorials"
        }, 
        {
            "location": "/manual/canvas-controllers/introduction/", 
            "text": "Introduction\n\n\nA canvas controller represents a single screen in your user interface. Canvas controllers can present and dismiss other canvas controllers, or screens, allowing you to easily build a user interface flow, presenting and dismissing screens as required.\n\n\nA canvas controller automatically manages the presentation hierarchy, as well as loading and unloading itself as it is presented or dismissed. This allows you to build large, complex, or dynamic user interface flows, loading only the necessary screens on demand.\n\n\nCanvas controllers are built with Unity's native \nUI Canvas\n, so any UI components that work with Unity's \nUI.Canvas\n are supported and creating the canvas controller's content will feel very familiar if you have worked with Unity UI before.\n\n\nCanvas controllers can be used in \nStoryboards\n to visually create the user interface's flow.\n\n\nCanvas controllers can be presented in world space by either setting a storyboard's \nStoryboardPresentationSpace\n to \nWorldSpace\n, or by passing a \nCanvasControllerWorldSpaceContainer\n to \nPresentInitialCanvasController\n. Canvas controllers presented from a world space canvas controller will also be presented in world space and contained within the presenter's container.\n\n\nA canvas controller consists of two files - a scene file (\n.unity\n) and a script file (\n.cs\n). The scene file is where you can create your screen's contents. See the \nCanvas Controller Scenes\n section for more information. The script file is where you can do any scripting that your screen may require. See the \nPresentation \n Dismissal\n and \nLife Cycle\n sections for more information.\n\n\n\n    \n\n    \nThe menu canvas controller from the included 'Floaty Cube' example.", 
            "title": "Introduction"
        }, 
        {
            "location": "/manual/canvas-controllers/introduction/#introduction", 
            "text": "A canvas controller represents a single screen in your user interface. Canvas controllers can present and dismiss other canvas controllers, or screens, allowing you to easily build a user interface flow, presenting and dismissing screens as required.  A canvas controller automatically manages the presentation hierarchy, as well as loading and unloading itself as it is presented or dismissed. This allows you to build large, complex, or dynamic user interface flows, loading only the necessary screens on demand.  Canvas controllers are built with Unity's native  UI Canvas , so any UI components that work with Unity's  UI.Canvas  are supported and creating the canvas controller's content will feel very familiar if you have worked with Unity UI before.  Canvas controllers can be used in  Storyboards  to visually create the user interface's flow.  Canvas controllers can be presented in world space by either setting a storyboard's  StoryboardPresentationSpace  to  WorldSpace , or by passing a  CanvasControllerWorldSpaceContainer  to  PresentInitialCanvasController . Canvas controllers presented from a world space canvas controller will also be presented in world space and contained within the presenter's container.  A canvas controller consists of two files - a scene file ( .unity ) and a script file ( .cs ). The scene file is where you can create your screen's contents. See the  Canvas Controller Scenes  section for more information. The script file is where you can do any scripting that your screen may require. See the  Presentation   Dismissal  and  Life Cycle  sections for more information.  \n     \n     The menu canvas controller from the included 'Floaty Cube' example.", 
            "title": "Introduction"
        }, 
        {
            "location": "/manual/canvas-controllers/creating-a-canvas-controller/", 
            "text": "Creating A Canvas Controller\n\n\nTo create a new canvas controller, open Unity's \nCreate\n menu - by either right-clicking in the Project window or selecting Assets in the menu bar - and selecting \nCreate/Canvas Flow/Canvas Controller\n. Enter a name and a directory for your new canvas controller.\n\n\nThis will create two new files at the specified location - a \n.unity\n scene file and a \n.cs\n script file - and open the new canvas controller's scene.\n\n\n\n    \n\n    \nA newly created canvas controller.", 
            "title": "Creating A Canvas Controller"
        }, 
        {
            "location": "/manual/canvas-controllers/creating-a-canvas-controller/#creating-a-canvas-controller", 
            "text": "To create a new canvas controller, open Unity's  Create  menu - by either right-clicking in the Project window or selecting Assets in the menu bar - and selecting  Create/Canvas Flow/Canvas Controller . Enter a name and a directory for your new canvas controller.  This will create two new files at the specified location - a  .unity  scene file and a  .cs  script file - and open the new canvas controller's scene.  \n     \n     A newly created canvas controller.", 
            "title": "Creating A Canvas Controller"
        }, 
        {
            "location": "/manual/canvas-controllers/canvas-controller-scenes/", 
            "text": "Canvas Controller Scenes\n\n\nA canvas controller's scene file contains the main canvas and is where you can create your screen's contents. By default, a canvas controller's scene is structured like so:\n\n\n\n    \n\n    \nA canvas controller's default hierarchy.\n\n    \n\n\n\n\n\nYou should place your UI elements underneath the 'Content' game object, just as the canvas controller's 'Background Image' has been. This ensures that your canvas controller is compatible with the included transition animators\n1\n.\n\n\n\n    \n\n    \nCreating a canvas controller's content.\n\n    \n\n\n\n\n\n1. The included transition animators animate the 'Content' game object. If you place elements outside of the canvas controller's content, it won't be animated by the included transition animators. You could, however, animate it with a \ncustom transition animator.\n\n\n\n\nRoot Canvas Controller Object\n\n\nThe top-level game object contains a single component - your canvas controller's script. Here you can see any properties that you declare in your canvas controller and configure any UI elements, such as button callbacks. \nYou must always keep this object in the root of your canvas controller's scene.\n\n\n\n    \n\n    \nThe canvas controller game object and component.\n\n    \n\n\n\n\n\n\n\nCanvas Object\n\n\nThe canvas game object contains three components - the canvas itself, a \nCanvas Scaler\n, and the Canvas' \nGraphic Raycaster\n.\n\n\n\n    \n\n    \nThe canvas game object and component.\n\n    \n\n\n\n\n\nThe Canvas Scaler's reference resolution should be set to the resolution that you are designing your UI at. If the screen resolution is larger, the UI will be scaled up, and if it\u2019s smaller, the UI will be scaled down. Note that you can change the default value for new canvas controllers in Canvas Flow's preferences, which can be found in the Unity menu at \nUnity/Preferences/Canvas Flow\n.\n\n\n\n    \n\n    \nSet the reference resolution for new canvas controllers in the editor preferences window.", 
            "title": "Canvas Controller Scenes"
        }, 
        {
            "location": "/manual/canvas-controllers/canvas-controller-scenes/#canvas-controller-scenes", 
            "text": "A canvas controller's scene file contains the main canvas and is where you can create your screen's contents. By default, a canvas controller's scene is structured like so:  \n     \n     A canvas controller's default hierarchy. \n       You should place your UI elements underneath the 'Content' game object, just as the canvas controller's 'Background Image' has been. This ensures that your canvas controller is compatible with the included transition animators 1 .  \n     \n     Creating a canvas controller's content. \n       1. The included transition animators animate the 'Content' game object. If you place elements outside of the canvas controller's content, it won't be animated by the included transition animators. You could, however, animate it with a  custom transition animator.", 
            "title": "Canvas Controller Scenes"
        }, 
        {
            "location": "/manual/canvas-controllers/canvas-controller-scenes/#root-canvas-controller-object", 
            "text": "The top-level game object contains a single component - your canvas controller's script. Here you can see any properties that you declare in your canvas controller and configure any UI elements, such as button callbacks.  You must always keep this object in the root of your canvas controller's scene.  \n     \n     The canvas controller game object and component.", 
            "title": "Root Canvas Controller Object"
        }, 
        {
            "location": "/manual/canvas-controllers/canvas-controller-scenes/#canvas-object", 
            "text": "The canvas game object contains three components - the canvas itself, a  Canvas Scaler , and the Canvas'  Graphic Raycaster .  \n     \n     The canvas game object and component. \n       The Canvas Scaler's reference resolution should be set to the resolution that you are designing your UI at. If the screen resolution is larger, the UI will be scaled up, and if it\u2019s smaller, the UI will be scaled down. Note that you can change the default value for new canvas controllers in Canvas Flow's preferences, which can be found in the Unity menu at  Unity/Preferences/Canvas Flow .  \n     \n     Set the reference resolution for new canvas controllers in the editor preferences window.", 
            "title": "Canvas Object"
        }, 
        {
            "location": "/manual/canvas-controllers/presentation-and-dismissal/", 
            "text": "Presentation \n Dismissal\n\n\nCanvas controllers can present and dismiss other canvas controllers,  allowing you to easily build a user interface flow, presenting and dismissing screens as required.\n\n\nA canvas controller automatically manages the presentation hierarchy, as well as loading and unloading itself as it is presented or dismissed. This allows you to build large, complex, or dynamic user interface flows, loading only the necessary screens on demand.\n\n\n\n\nNote: Use storyboards to present and dismiss canvas controllers without scripting by visually creating your user interface's flow. Please see the \nStoryboards\n section of the manual for information about using Storyboards.\n\n\n\n\nPresenting From A Canvas Controller\n\n\nCanvas controllers are presented and dismissed using the \nPresentCanvasController\nT\n()\n and \nDismissCanvasController()\n methods.\n\n\nFor example, suppose we have two canvas controllers - \nMenuCanvasController\n and \nSettingsCanvasController\n. In our menu canvas controller is a UI Button that should show the settings screen when pressed.\n\n\nIn the \nMenuCanvasController.cs\n script, we could add the following \nOnClick\n handler:\n\n\npublic void OnSettingsButtonPressed()\n{\n    PresentCanvasController\nSettingsCanvasController\n();\n}\n\n\n\n\nAnd that's it. When this button is pressed, the menu will present the settings screen, dynamically loading the settings canvas controller and animating it on screen.\n\n\nWe could do a similar thing in our settings canvas controller, except this time the button being pressed is a back button and we want to return to the previous screen when it is pressed.\n\n\npublic void OnBackButtonPressed()\n{\n    DismissCanvasController();\n}\n\n\n\n\nThis will cause the settings screen to be animated off-screen and subsequently unloaded, returning to the menu.\n\n\n\n\nPresenting From A Scene\n\n\nIn a game environment, there is usually an existing scene - say the game's level or other 3D content scene - over which a user interface is presented. Once the initial canvas controller has been presented, the \nPresentCanvasController\nT\n()\n and \nDismissCanvasController()\n methods described above can be used. In order to present the initial canvas controller however, the static method \nCanvasController.PresentInitialCanvasController\nT\n()\n is used.\n\n\nSo, for example, say we have an existing game scene called \nLevel1\n, which contains our game's content, and a canvas controller called \nGameOverlayCanvasController\n. When the game scene \nLevel1\n is run, we wish to present the game overlay screen over the game's content.\n\n\nTo do this, we could create a new script in the \nLevel1\n game scene and present the initial \nGameOverlayCanvasController\n in the \nMonoBehaviour\n's \nAwake()\n method, like so:\n\n\nprivate void Awake()\n{\n    CanvasController.PresentInitialCanvasController\nGameOverlayCanvasController\n(animated: false)\n}\n\n\n\n\n\n\nNote how we can specify this presentation to not be animated by using the \nanimated\n parameter.\n\n\n\n\nThe game overlay screen could then use the \nPresentCanvasController\nT\n()\n and \nDismissCanvasController()\n methods described above, perhaps presenting pause or game-over screens, as required.\n\n\n\n\nNote: A single \nUnity EventSystem\n is required to be present for canvases to receive input events. Therefore, depending on your game's structure, you may wish to place an Event System (\nGame Object/UI/Event System\n) in the scene presenting your initial canvas controller.\n\n\n\n\n\n\nPresenting In World Space\n\n\nBy default, canvas controllers are presented in screen space. To present a canvas controller in world space, you specify a \nCanvasControllerWorldSpaceContainer\n component when calling the aforementioned \nCanvasController.PresentInitialCanvasController\nT\n()\n method.\n\n\nFirst, create a new GameObject in the scene and add a \nCanvasControllerWorldSpaceContainer\n component to it. This will give you a world space canvas that you can position freely in your scene.\n\n\nThen, when calling \nCanvasController.PresentInitialCanvasController\nT\n()\n, pass in the world space container like so:\n\n\nCanvasController.PresentInitialCanvasController\nGameOverlayCanvasController\n(worldSpaceContainer: yourWorldSpaceContainer)\n\n\n\n\nThis will cause the canvas controller to be presented in world space and embedded within the specified container.\n\n\n\n\nNote that any subsequent calls to \nPresentCanvasController\nT\n()\n will automatically detect whether they should be presented in world space or screen space. If the presenting canvas controller is in world space, the presented canvas controller will also be in world space. Likewise, if the presenting canvas controller is in screen space, the presented canvas controller will also be in screen space.\n\n\n\n\n\n\nConfiguring A (To-Be) Presented Canvas Controller\n\n\nAll \nPresent\u2026()\n methods include a configuration action parameter to allow configuring the loaded canvas controller before it is presented. The configuration action is invoked by Canvas Flow after the canvas controller has been loaded, but before it has begun presenting. The configuration action is specified like so:\n\n\nPresentCanvasController\nGameOverlayCanvasController\n(configuration: (gameOverlayCanvasController) =\n\n{\n    // Configure the newly-loaded gameOverlayCanvasController.\n});\n\n\n\n\nA common use-case for the configuration action is to pass data to the to-be-presented canvas controller. To illustrate, take the earlier example of presenting a game overlay screen in the game's \nLevel1\n scene. Say we now have \nLevel2\n and \nLevel3\n scenes as well, which also display the same game overlay screen as before. However, we want to display the current level number in the top corner of the screen for the player. After adding a label to display the current level, we could also add a \nConfigureWithLevel()\n method to our \ngameOverlayCanvasController\n, which sets the level label's text. \n\n\n// In GameOverlayCanvasController.cs\npublic void ConfigureWithLevel(int levelNumber)\n{\n    currentLevelLabel.text = string.Format(\nLevel {0}\n, levelNumber);\n}\n\n\n\n\nThen when presenting the game overlay screen from the \nAwake()\n method as before, we can use the configuration action to configure it with the level number, which is set in the scene.\n\n\npublic int levelNumber;\n\nprivate void Awake()\n{\n    CanvasController.PresentInitialCanvasController\nGameOverlayCanvasController\n(\n        configuration: (gameOverlayCanvasController) =\n\n    {\n        gameOverlayCanvasController.ConfigureWithLevel(levelNumber);\n    } animated: false);\n}\n\n\n\n\nNow, no matter how many levels we create, the game overlay screen will simply display the level number it is configured with.\n\n\n\n\nNote: Canvas controllers also have a similar \ncompletion:\n action parameter, which is invoked \nafter\n the presentation transition has completed. \n\n\n\n\n\n\nFor information on customizing the transition animation between canvas controllers, please see the Custom Transition Animators section.", 
            "title": "Presentation & Dismissal"
        }, 
        {
            "location": "/manual/canvas-controllers/presentation-and-dismissal/#presentation-dismissal", 
            "text": "Canvas controllers can present and dismiss other canvas controllers,  allowing you to easily build a user interface flow, presenting and dismissing screens as required.  A canvas controller automatically manages the presentation hierarchy, as well as loading and unloading itself as it is presented or dismissed. This allows you to build large, complex, or dynamic user interface flows, loading only the necessary screens on demand.   Note: Use storyboards to present and dismiss canvas controllers without scripting by visually creating your user interface's flow. Please see the  Storyboards  section of the manual for information about using Storyboards.", 
            "title": "Presentation &amp; Dismissal"
        }, 
        {
            "location": "/manual/canvas-controllers/presentation-and-dismissal/#presenting-from-a-canvas-controller", 
            "text": "Canvas controllers are presented and dismissed using the  PresentCanvasController T ()  and  DismissCanvasController()  methods.  For example, suppose we have two canvas controllers -  MenuCanvasController  and  SettingsCanvasController . In our menu canvas controller is a UI Button that should show the settings screen when pressed.  In the  MenuCanvasController.cs  script, we could add the following  OnClick  handler:  public void OnSettingsButtonPressed()\n{\n    PresentCanvasController SettingsCanvasController ();\n}  And that's it. When this button is pressed, the menu will present the settings screen, dynamically loading the settings canvas controller and animating it on screen.  We could do a similar thing in our settings canvas controller, except this time the button being pressed is a back button and we want to return to the previous screen when it is pressed.  public void OnBackButtonPressed()\n{\n    DismissCanvasController();\n}  This will cause the settings screen to be animated off-screen and subsequently unloaded, returning to the menu.", 
            "title": "Presenting From A Canvas Controller"
        }, 
        {
            "location": "/manual/canvas-controllers/presentation-and-dismissal/#presenting-from-a-scene", 
            "text": "In a game environment, there is usually an existing scene - say the game's level or other 3D content scene - over which a user interface is presented. Once the initial canvas controller has been presented, the  PresentCanvasController T ()  and  DismissCanvasController()  methods described above can be used. In order to present the initial canvas controller however, the static method  CanvasController.PresentInitialCanvasController T ()  is used.  So, for example, say we have an existing game scene called  Level1 , which contains our game's content, and a canvas controller called  GameOverlayCanvasController . When the game scene  Level1  is run, we wish to present the game overlay screen over the game's content.  To do this, we could create a new script in the  Level1  game scene and present the initial  GameOverlayCanvasController  in the  MonoBehaviour 's  Awake()  method, like so:  private void Awake()\n{\n    CanvasController.PresentInitialCanvasController GameOverlayCanvasController (animated: false)\n}   Note how we can specify this presentation to not be animated by using the  animated  parameter.   The game overlay screen could then use the  PresentCanvasController T ()  and  DismissCanvasController()  methods described above, perhaps presenting pause or game-over screens, as required.   Note: A single  Unity EventSystem  is required to be present for canvases to receive input events. Therefore, depending on your game's structure, you may wish to place an Event System ( Game Object/UI/Event System ) in the scene presenting your initial canvas controller.", 
            "title": "Presenting From A Scene"
        }, 
        {
            "location": "/manual/canvas-controllers/presentation-and-dismissal/#presenting-in-world-space", 
            "text": "By default, canvas controllers are presented in screen space. To present a canvas controller in world space, you specify a  CanvasControllerWorldSpaceContainer  component when calling the aforementioned  CanvasController.PresentInitialCanvasController T ()  method.  First, create a new GameObject in the scene and add a  CanvasControllerWorldSpaceContainer  component to it. This will give you a world space canvas that you can position freely in your scene.  Then, when calling  CanvasController.PresentInitialCanvasController T () , pass in the world space container like so:  CanvasController.PresentInitialCanvasController GameOverlayCanvasController (worldSpaceContainer: yourWorldSpaceContainer)  This will cause the canvas controller to be presented in world space and embedded within the specified container.   Note that any subsequent calls to  PresentCanvasController T ()  will automatically detect whether they should be presented in world space or screen space. If the presenting canvas controller is in world space, the presented canvas controller will also be in world space. Likewise, if the presenting canvas controller is in screen space, the presented canvas controller will also be in screen space.", 
            "title": "Presenting In World Space"
        }, 
        {
            "location": "/manual/canvas-controllers/presentation-and-dismissal/#configuring-a-to-be-presented-canvas-controller", 
            "text": "All  Present\u2026()  methods include a configuration action parameter to allow configuring the loaded canvas controller before it is presented. The configuration action is invoked by Canvas Flow after the canvas controller has been loaded, but before it has begun presenting. The configuration action is specified like so:  PresentCanvasController GameOverlayCanvasController (configuration: (gameOverlayCanvasController) = \n{\n    // Configure the newly-loaded gameOverlayCanvasController.\n});  A common use-case for the configuration action is to pass data to the to-be-presented canvas controller. To illustrate, take the earlier example of presenting a game overlay screen in the game's  Level1  scene. Say we now have  Level2  and  Level3  scenes as well, which also display the same game overlay screen as before. However, we want to display the current level number in the top corner of the screen for the player. After adding a label to display the current level, we could also add a  ConfigureWithLevel()  method to our  gameOverlayCanvasController , which sets the level label's text.   // In GameOverlayCanvasController.cs\npublic void ConfigureWithLevel(int levelNumber)\n{\n    currentLevelLabel.text = string.Format( Level {0} , levelNumber);\n}  Then when presenting the game overlay screen from the  Awake()  method as before, we can use the configuration action to configure it with the level number, which is set in the scene.  public int levelNumber;\n\nprivate void Awake()\n{\n    CanvasController.PresentInitialCanvasController GameOverlayCanvasController (\n        configuration: (gameOverlayCanvasController) = \n    {\n        gameOverlayCanvasController.ConfigureWithLevel(levelNumber);\n    } animated: false);\n}  Now, no matter how many levels we create, the game overlay screen will simply display the level number it is configured with.   Note: Canvas controllers also have a similar  completion:  action parameter, which is invoked  after  the presentation transition has completed.     For information on customizing the transition animation between canvas controllers, please see the Custom Transition Animators section.", 
            "title": "Configuring A (To-Be) Presented Canvas Controller"
        }, 
        {
            "location": "/manual/canvas-controllers/canvas-controller-life-cycle/", 
            "text": "Canvas Controller Life Cycle\n\n\nCanvas controllers allow you to override certain methods in order to be notified when particular events occur in their life cycle. These include appearance related events, as well as all \nMonoBehaviour\n events.\n\n\nAppearance\n\n\nA canvas controller can override the following methods to receive appearance related callbacks. These could be used, for example, to trigger an animation once a canvas controller has completely transitioned on screen.\n\n\nYou can use the \nIsBeingPresented\n and \nIsBeingDismissed\n methods within the callback to infer the cause of the appearance or disappearance.\n\n\nprotected override void CanvasWillAppear()\n{\n    /*\n     *  Override this method in your canvas controller to be notified just\n     *  before the canvas is about to transition on screen. This could be\n     *  because it is about to be presented or about to dismiss its\n     *  PresentedCanvasController.\n     */\n}\n\nprotected override void CanvasDidAppear()\n{\n    /*\n     *  Override this method in your canvas controller to be notified just\n     *  after the canvas has transitioned on screen. This could be because\n     *  it has just been presented or has just dismissed its\n     *  PresentedCanvasController.\n     */\n}\n\nprotected override void CanvasWillDisappear()\n{\n    /*\n     *  Override this method in your canvas controller to be notified just\n     *  before the canvas is about to transition off screen. This could be\n     *  because it is about to be dismissed or about to present a canvas\n     *  controller.\n     */\n}\n\nprotected override void CanvasDidDisappear()\n{\n    /*\n     *  Override this method in your canvas controller to be notified just\n     *  after the canvas has transitioned off screen. This could be\n     *  because it has just been dismissed or has just presented a canvas\n     *  controller.\n     */\n}\n\n\n\n\nMonoBehaviour\n\n\nA canvas controller is a \nMonoBehaviour\n and as such, all \nMonoBehaviour\n callbacks will be called on a canvas controller.\n\n\nIf implementing \nAwake()\n or \nStart()\n, you should override and call the base implementation like so:\n\n\nprotected override void Awake()\n{\n    base.Awake();\n\n    // Your awake functionality.\n}\n\nprotected override void Start()\n{\n    base.Start();\n\n    // Your start functionality.\n}", 
            "title": "Canvas Controller Life Cycle"
        }, 
        {
            "location": "/manual/canvas-controllers/canvas-controller-life-cycle/#canvas-controller-life-cycle", 
            "text": "Canvas controllers allow you to override certain methods in order to be notified when particular events occur in their life cycle. These include appearance related events, as well as all  MonoBehaviour  events.", 
            "title": "Canvas Controller Life Cycle"
        }, 
        {
            "location": "/manual/canvas-controllers/canvas-controller-life-cycle/#appearance", 
            "text": "A canvas controller can override the following methods to receive appearance related callbacks. These could be used, for example, to trigger an animation once a canvas controller has completely transitioned on screen.  You can use the  IsBeingPresented  and  IsBeingDismissed  methods within the callback to infer the cause of the appearance or disappearance.  protected override void CanvasWillAppear()\n{\n    /*\n     *  Override this method in your canvas controller to be notified just\n     *  before the canvas is about to transition on screen. This could be\n     *  because it is about to be presented or about to dismiss its\n     *  PresentedCanvasController.\n     */\n}\n\nprotected override void CanvasDidAppear()\n{\n    /*\n     *  Override this method in your canvas controller to be notified just\n     *  after the canvas has transitioned on screen. This could be because\n     *  it has just been presented or has just dismissed its\n     *  PresentedCanvasController.\n     */\n}\n\nprotected override void CanvasWillDisappear()\n{\n    /*\n     *  Override this method in your canvas controller to be notified just\n     *  before the canvas is about to transition off screen. This could be\n     *  because it is about to be dismissed or about to present a canvas\n     *  controller.\n     */\n}\n\nprotected override void CanvasDidDisappear()\n{\n    /*\n     *  Override this method in your canvas controller to be notified just\n     *  after the canvas has transitioned off screen. This could be\n     *  because it has just been dismissed or has just presented a canvas\n     *  controller.\n     */\n}", 
            "title": "Appearance"
        }, 
        {
            "location": "/manual/canvas-controllers/canvas-controller-life-cycle/#monobehaviour", 
            "text": "A canvas controller is a  MonoBehaviour  and as such, all  MonoBehaviour  callbacks will be called on a canvas controller.  If implementing  Awake()  or  Start() , you should override and call the base implementation like so:  protected override void Awake()\n{\n    base.Awake();\n\n    // Your awake functionality.\n}\n\nprotected override void Start()\n{\n    base.Start();\n\n    // Your start functionality.\n}", 
            "title": "MonoBehaviour"
        }, 
        {
            "location": "/manual/storyboards/introduction/", 
            "text": "Introduction\n\n\nStoryboards allow you to visually create the flow of your user interface by defining the canvas controllers involved (nodes) and the connections between them (transitions).\n\n\nInstead of writing code to present and dismiss canvas controllers, you can create a storyboard to describe the flow between your screens. Canvas Flow can then automatically present and dismiss your canvas controllers as the relevant buttons, or \n'hooks'\n, are triggered.\n\n\nStoryboards are designed in the Storyboard Editor window, shown below, which can be opened by either double-clicking on a storyboard asset in the project inspector or selecting \nWindow/Canvas Flow/Storyboard\n in the menu bar.\n\n\n\n    \n\n    \nThe in-game storyboard from Canvas Flow's Floaty Cube example, containing four screens.", 
            "title": "Introduction"
        }, 
        {
            "location": "/manual/storyboards/introduction/#introduction", 
            "text": "Storyboards allow you to visually create the flow of your user interface by defining the canvas controllers involved (nodes) and the connections between them (transitions).  Instead of writing code to present and dismiss canvas controllers, you can create a storyboard to describe the flow between your screens. Canvas Flow can then automatically present and dismiss your canvas controllers as the relevant buttons, or  'hooks' , are triggered.  Storyboards are designed in the Storyboard Editor window, shown below, which can be opened by either double-clicking on a storyboard asset in the project inspector or selecting  Window/Canvas Flow/Storyboard  in the menu bar.  \n     \n     The in-game storyboard from Canvas Flow's Floaty Cube example, containing four screens.", 
            "title": "Introduction"
        }, 
        {
            "location": "/manual/storyboards/creating-a-storyboard/", 
            "text": "Creating A Storyboard\n\n\nTo create a new storyboard, open Unity's \nCreate\n menu - by either right-clicking in the Project window or selecting Assets in the menu bar - and selecting \nCreate/Canvas Flow/Storyboard\n. Enter a name and a directory for your new storyboard.\n\n\nThis will create a new storyboard file at the specified location and open it in the Storyboard Editor window.\n\n\n\n    \n\n    \nA newly-created, empty storyboard.\n\n\n\n\n\nBasic Controls\n\n\nTo \npan the storyboard editor window\n, you can either:\n\n\n\n\nScroll.\n\n\nClick and drag.\n\n\n\n\nTo \nzoom the storyboard editor window\n in and out, you can either:\n\n\n\n\nHold the \nALT\n key and scroll.\n\n\nUse the \nzoom\n buttons in the lower-left corner of the window.\n\n\n\n\nTo \nmove a \nstoryboard node\n:\n\n\n\n\nClick \n drag\n its title bar.\n\n\n\n\nTo \nmove an entry or exit node\n:\n\n\n\n\nClick \n drag\n it.", 
            "title": "Creating A Storyboard"
        }, 
        {
            "location": "/manual/storyboards/creating-a-storyboard/#creating-a-storyboard", 
            "text": "To create a new storyboard, open Unity's  Create  menu - by either right-clicking in the Project window or selecting Assets in the menu bar - and selecting  Create/Canvas Flow/Storyboard . Enter a name and a directory for your new storyboard.  This will create a new storyboard file at the specified location and open it in the Storyboard Editor window.  \n     \n     A newly-created, empty storyboard.", 
            "title": "Creating A Storyboard"
        }, 
        {
            "location": "/manual/storyboards/creating-a-storyboard/#basic-controls", 
            "text": "To  pan the storyboard editor window , you can either:   Scroll.  Click and drag.   To  zoom the storyboard editor window  in and out, you can either:   Hold the  ALT  key and scroll.  Use the  zoom  buttons in the lower-left corner of the window.   To  move a  storyboard node :   Click   drag  its title bar.   To  move an entry or exit node :   Click   drag  it.", 
            "title": "Basic Controls"
        }, 
        {
            "location": "/manual/storyboards/storyboard-nodes/", 
            "text": "Storyboard Nodes\n\n\nA storyboard node represents a single instance of a canvas controller in the storyboard. Nodes can then have connections made between them, called \ntransitions\n, which define the flow of your user interface.\n\n\nAdding Nodes\n\n\nTo add a node to a storyboard, simply drag the canvas controller's scene file onto the storyboard window, as shown in the video below.\n\n\nAlternatively, you can use the '+' button in the lower-right corner of the Storyboard Editor window to select an existing canvas controller in the file inspector.\n\n\n\n    \n\n    \nAdding a canvas controller to a storyboard with drag \n&\n drop.\n\n    \n\n\n\n\n\nNode Details\n\n\nA node represents a single instance of a canvas controller in the storyboard. It will display any \nhookable\n elements - such as Unity's \nUI Buttons\n - in the canvas preview area of the node, as shown below. A \nhookable\n element is one that a transition can be created from, in order to present or dismiss a canvas controller. \n\n\n\n    \n\n    \nA node's canvas preview area displays its 'hookable' elements, such as the pause button shown here.\n\n\n\n\n\n\n\nNote: The canvas preview area is sized according to the \nCanvas Scaler's\n reference resolution. See the canvas controller's \ncanvas object\n for more information.\n\n\n\n\nBy default, all \nUnity UI Buttons\n are supported as \nhookable\n elements in a storyboard. This means that any \nUI Buttons\n in a canvas controller can be used in a storyboard to trigger a transition to another canvas controller. To support additional UI elements, such as a custom button type, please see the \nCustom Storyboard Hooks\n section of the manual.\n\n\nWhen a canvas controller's scene is saved, all \nhookable\n components have a \nStoryboard Hook\n added to them, causing them to be displayed in the canvas preview area. A storyboard hook can be excluded from a storyboard by selecting the \nExclude From Storyboard\n flag on the hook in your canvas controller's scene.\n\n\n\n    \n\n    \nExclude a hook from a storyboard.\n\n    \n\n\n\n\n\nAdditionally, the automatic adding of \nStoryboardHook\n components can be disabled in Canvas Flow's preferences by unchecking \n'Auto-Add Hooks On Scene Save'\n, found in the menu bar at \nUnity/Preferences/Canvas Flow\n.", 
            "title": "Storyboard Nodes"
        }, 
        {
            "location": "/manual/storyboards/storyboard-nodes/#storyboard-nodes", 
            "text": "A storyboard node represents a single instance of a canvas controller in the storyboard. Nodes can then have connections made between them, called  transitions , which define the flow of your user interface.", 
            "title": "Storyboard Nodes"
        }, 
        {
            "location": "/manual/storyboards/storyboard-nodes/#adding-nodes", 
            "text": "To add a node to a storyboard, simply drag the canvas controller's scene file onto the storyboard window, as shown in the video below.  Alternatively, you can use the '+' button in the lower-right corner of the Storyboard Editor window to select an existing canvas controller in the file inspector.  \n     \n     Adding a canvas controller to a storyboard with drag  &  drop.", 
            "title": "Adding Nodes"
        }, 
        {
            "location": "/manual/storyboards/storyboard-nodes/#node-details", 
            "text": "A node represents a single instance of a canvas controller in the storyboard. It will display any  hookable  elements - such as Unity's  UI Buttons  - in the canvas preview area of the node, as shown below. A  hookable  element is one that a transition can be created from, in order to present or dismiss a canvas controller.   \n     \n     A node's canvas preview area displays its 'hookable' elements, such as the pause button shown here.    Note: The canvas preview area is sized according to the  Canvas Scaler's  reference resolution. See the canvas controller's  canvas object  for more information.   By default, all  Unity UI Buttons  are supported as  hookable  elements in a storyboard. This means that any  UI Buttons  in a canvas controller can be used in a storyboard to trigger a transition to another canvas controller. To support additional UI elements, such as a custom button type, please see the  Custom Storyboard Hooks  section of the manual.  When a canvas controller's scene is saved, all  hookable  components have a  Storyboard Hook  added to them, causing them to be displayed in the canvas preview area. A storyboard hook can be excluded from a storyboard by selecting the  Exclude From Storyboard  flag on the hook in your canvas controller's scene.  \n     \n     Exclude a hook from a storyboard. \n       Additionally, the automatic adding of  StoryboardHook  components can be disabled in Canvas Flow's preferences by unchecking  'Auto-Add Hooks On Scene Save' , found in the menu bar at  Unity/Preferences/Canvas Flow .", 
            "title": "Node Details"
        }, 
        {
            "location": "/manual/storyboards/storyboard-transitions/", 
            "text": "Storyboard Transitions\n\n\nStoryboard transitions define the flow of nodes in the storyboard. A connection from one node to another represents a transition between those two nodes - a presentation or dismissal. The hook from which the transition originates defines the trigger for that transition.\n\n\nDirection\n\n\nAll transitions in a storyboard have a direction, which can be one of two values - downstream or upstream. A downstream connection is equivalent to a presentation and is represented by a \nblue\n color. An upstream connection is equivalent to a dismissal and is represented by an \norange\n color.\n\n\n\n    \n\n    \nA downstream transition (presentation) from the menu to the settings screen and an upstream transition (dismissal) from the settings screen back to the menu.\n\n\n\n\n\nCreation\n\n\nTo create a transition between two nodes, drag from the source node's hook to the destination node, as shown in the video below. Canvas Flow automatically detects the direction - downstream or upstream - based on the current state of the flow graph.\n\n\n\n    \n\n    \nCreating transitions between nodes.\n\n    \n\n\n\n\n\n\n\nNote: An upstream transition, or dismissal, is created when a connection is made in which the destination node has a downstream path to the source node. Therefore, to create an upstream transition a downstream path between the nodes must exist.\n\n\n\n\nConfiguration\n\n\nA transition's properties can be configured by selecting its origin hook. This will open the transition inspector, which is shown below and followed by a description of each property.\n\n\n\n    \n\n    \nThe transition inspector.\n\n\n\n\n\n\n\n\n\n\n\nProperty\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nHook Name\n\n\nThe name of the hook that will invoke this transition. This is taken from the game object that the hook component is attached to in the canvas controller.\n\n\n\n\n\n\nAnimated\n\n\nIs the transition animated?\n\n\n\n\n\n\nCustom Animator\n\n\nThe transition's animator. For more information, please see the \ntransition animators\n section of the manual.\n\n\n\n\n\n\nPresentation Mode\n\n\nThe presentation mode of the destination canvas controller (only available on downstream transitions). Please see \npresentation mode\n for more information.\n\n\n\n\n\n\nUser Identifier\n\n\nThe transition's user identifier. This is used to identify the transition when triggering it manually, such as with a \nmanual transition\n.\n\n\n\n\n\n\nLoad Asynchronously\n\n\nShould the canvas controller be loaded asynchronously? By default, canvas controllers are always loaded asynchronously.\n\n\n\n\n\n\nOverride World Position\n\n\nSpecify a world position at which to place the loaded canvas controller. This can be specified as an absolute world position with the \n'Position'\n setting, or as a spacing multiplier with the \n'World Spacing Multiplier'\n setting. If \n'World Spacing Multiplier'\n is selected, the world position for the new canvas will be the source canvas' world position plus the canvas size scaled by the multiplier.\n\n\n\n\n\n\n\n\nPassing Data Between Canvas Controllers\n\n\nWhen a transition occurs in a storyboard, the transition's source canvas controller will have its \nPrepareForStoryboardTransition()\n method called, passing in a \nStoryboardTransition\n.\n\n\nThis gives an opportunity to pass data between canvas controllers, just as you might use a \nconfiguration action\n when presenting a canvas controller from script.\n\n\nFor example, in Canvas Flow's Floaty Cube example, the menu canvas controller uses the \nPrepareForStoryboardTransition()\n method to detect when the loading screen is being presented and to configure it with the name of the scene to load, like so:\n\n\npublic override void PrepareForStoryboardTransition(StoryboardTransition transition)\n{\n    var destination = transition.DestinationCanvasController();\n    if (destination is FCLoadingCanvasController \n\n        transition.direction == StoryboardTransitionDirection.Downstream)\n    {\n        // We are presenting the loading screen. Configure it to present the Game scene.\n        var loadingCanvasController = (FCLoadingCanvasController)destination;\n        loadingCanvasController.SceneToLoad = \nFCGameScene\n;\n    }\n}\n\n\n\n\nManual Transitions\n\n\nManual transitions are transitions that have no origin hook - i.e. they must be triggered manually. These can be used to invoke a storyboard transition in response to non-UI events, such as a \ncollider\n being intersected or a timer expiring.\n\n\nTo create a manual transition, drag from the source node's \n'Manual Transitions'\n element to the destination node and enter a user identifier, as shown in the video below.\n\n\n\n    \n\n    \nCreating a manual transition between nodes.\n\n    \n\n\n\n\n\nTo trigger a manual transition, call \nPerformTransitionWithIdentifier()\n from the source canvas controller, passing in the transition's \nuserIdentifier\n.\n\n\nFor example, in Canvas Flow's Floaty Cube example, an event is raised when the player reaches a target height. The game overlay screen subscribes to this event, and in the callback it triggers its manual transition named \n\"PresentGameCompleteScreen\"\n, like so:\n\n\npublic void OnPlayerReachedHeight()\n{\n    PerformTransitionWithIdentifier(\nPresentGameCompleteScreen\n);\n}\n\n\n\n\n\n\nNote: Any storyboard transition - not just manual transitions - can be triggered by passing its \nUser Identifier\n to \nPerformTransitionWithIdentifier()\n.\n\n\n\n\nEntry Transition\n\n\nWhen the first canvas controller is added to a storyboard, an entry transition pointing to the new canvas controller is automatically created. This is shown by the blue wire connecting the 'Entry' node to the newly-added canvas controller.\n\n\n\n    \n\n    \nThe storyboard's entry transition.\n\n    \n\n\n\n\n\nThe storyboard's entry transition determines which canvas controller is presented when the storyboard is presented - i.e. the storyboard's entry point. To change the storyboard's entry point, select the \n'Make storyboard entry point'\n button on the canvas controller's node, as shown below.\n\n\n\n    \n\n    \nSet a storyboard's entry point.\n\n    \n\n\n\n\n\n\n\nNote: A node can only become the entry point if it has no downstream transitions pointing to it. Similarly, if a node is the entry point, a downstream connection cannot be made to it.\n\n\n\n\nThe entry transition can be configured just like any other transition, as described above, with the exception that it cannot be deleted; a storyboard must have an entry point.\n\n\nExit Transition\n\n\nA storyboard exit transition is optional and is not always required. It is used in the event that you want to dismiss the entire storyboard. It will dismiss all canvas controllers that are in the storyboard's initial canvas controller's presentation hierarchy, including the initial canvas controller itself. It is the equivalent of calling \nDismissAllCanvasControllers\n.\n\n\nTo create an exit transition, drag from a hook or manual transition element to the \nExit Transition\n node.", 
            "title": "Storyboard Transitions"
        }, 
        {
            "location": "/manual/storyboards/storyboard-transitions/#storyboard-transitions", 
            "text": "Storyboard transitions define the flow of nodes in the storyboard. A connection from one node to another represents a transition between those two nodes - a presentation or dismissal. The hook from which the transition originates defines the trigger for that transition.", 
            "title": "Storyboard Transitions"
        }, 
        {
            "location": "/manual/storyboards/storyboard-transitions/#direction", 
            "text": "All transitions in a storyboard have a direction, which can be one of two values - downstream or upstream. A downstream connection is equivalent to a presentation and is represented by a  blue  color. An upstream connection is equivalent to a dismissal and is represented by an  orange  color.  \n     \n     A downstream transition (presentation) from the menu to the settings screen and an upstream transition (dismissal) from the settings screen back to the menu.", 
            "title": "Direction"
        }, 
        {
            "location": "/manual/storyboards/storyboard-transitions/#creation", 
            "text": "To create a transition between two nodes, drag from the source node's hook to the destination node, as shown in the video below. Canvas Flow automatically detects the direction - downstream or upstream - based on the current state of the flow graph.  \n     \n     Creating transitions between nodes. \n        Note: An upstream transition, or dismissal, is created when a connection is made in which the destination node has a downstream path to the source node. Therefore, to create an upstream transition a downstream path between the nodes must exist.", 
            "title": "Creation"
        }, 
        {
            "location": "/manual/storyboards/storyboard-transitions/#configuration", 
            "text": "A transition's properties can be configured by selecting its origin hook. This will open the transition inspector, which is shown below and followed by a description of each property.  \n     \n     The transition inspector.      Property  Description      Hook Name  The name of the hook that will invoke this transition. This is taken from the game object that the hook component is attached to in the canvas controller.    Animated  Is the transition animated?    Custom Animator  The transition's animator. For more information, please see the  transition animators  section of the manual.    Presentation Mode  The presentation mode of the destination canvas controller (only available on downstream transitions). Please see  presentation mode  for more information.    User Identifier  The transition's user identifier. This is used to identify the transition when triggering it manually, such as with a  manual transition .    Load Asynchronously  Should the canvas controller be loaded asynchronously? By default, canvas controllers are always loaded asynchronously.    Override World Position  Specify a world position at which to place the loaded canvas controller. This can be specified as an absolute world position with the  'Position'  setting, or as a spacing multiplier with the  'World Spacing Multiplier'  setting. If  'World Spacing Multiplier'  is selected, the world position for the new canvas will be the source canvas' world position plus the canvas size scaled by the multiplier.", 
            "title": "Configuration"
        }, 
        {
            "location": "/manual/storyboards/storyboard-transitions/#passing-data-between-canvas-controllers", 
            "text": "When a transition occurs in a storyboard, the transition's source canvas controller will have its  PrepareForStoryboardTransition()  method called, passing in a  StoryboardTransition .  This gives an opportunity to pass data between canvas controllers, just as you might use a  configuration action  when presenting a canvas controller from script.  For example, in Canvas Flow's Floaty Cube example, the menu canvas controller uses the  PrepareForStoryboardTransition()  method to detect when the loading screen is being presented and to configure it with the name of the scene to load, like so:  public override void PrepareForStoryboardTransition(StoryboardTransition transition)\n{\n    var destination = transition.DestinationCanvasController();\n    if (destination is FCLoadingCanvasController  \n        transition.direction == StoryboardTransitionDirection.Downstream)\n    {\n        // We are presenting the loading screen. Configure it to present the Game scene.\n        var loadingCanvasController = (FCLoadingCanvasController)destination;\n        loadingCanvasController.SceneToLoad =  FCGameScene ;\n    }\n}", 
            "title": "Passing Data Between Canvas Controllers"
        }, 
        {
            "location": "/manual/storyboards/storyboard-transitions/#manual-transitions", 
            "text": "Manual transitions are transitions that have no origin hook - i.e. they must be triggered manually. These can be used to invoke a storyboard transition in response to non-UI events, such as a  collider  being intersected or a timer expiring.  To create a manual transition, drag from the source node's  'Manual Transitions'  element to the destination node and enter a user identifier, as shown in the video below.  \n     \n     Creating a manual transition between nodes. \n       To trigger a manual transition, call  PerformTransitionWithIdentifier()  from the source canvas controller, passing in the transition's  userIdentifier .  For example, in Canvas Flow's Floaty Cube example, an event is raised when the player reaches a target height. The game overlay screen subscribes to this event, and in the callback it triggers its manual transition named  \"PresentGameCompleteScreen\" , like so:  public void OnPlayerReachedHeight()\n{\n    PerformTransitionWithIdentifier( PresentGameCompleteScreen );\n}   Note: Any storyboard transition - not just manual transitions - can be triggered by passing its  User Identifier  to  PerformTransitionWithIdentifier() .", 
            "title": "Manual Transitions"
        }, 
        {
            "location": "/manual/storyboards/storyboard-transitions/#entry-transition", 
            "text": "When the first canvas controller is added to a storyboard, an entry transition pointing to the new canvas controller is automatically created. This is shown by the blue wire connecting the 'Entry' node to the newly-added canvas controller.  \n     \n     The storyboard's entry transition. \n       The storyboard's entry transition determines which canvas controller is presented when the storyboard is presented - i.e. the storyboard's entry point. To change the storyboard's entry point, select the  'Make storyboard entry point'  button on the canvas controller's node, as shown below.  \n     \n     Set a storyboard's entry point. \n        Note: A node can only become the entry point if it has no downstream transitions pointing to it. Similarly, if a node is the entry point, a downstream connection cannot be made to it.   The entry transition can be configured just like any other transition, as described above, with the exception that it cannot be deleted; a storyboard must have an entry point.", 
            "title": "Entry Transition"
        }, 
        {
            "location": "/manual/storyboards/storyboard-transitions/#exit-transition", 
            "text": "A storyboard exit transition is optional and is not always required. It is used in the event that you want to dismiss the entire storyboard. It will dismiss all canvas controllers that are in the storyboard's initial canvas controller's presentation hierarchy, including the initial canvas controller itself. It is the equivalent of calling  DismissAllCanvasControllers .  To create an exit transition, drag from a hook or manual transition element to the  Exit Transition  node.", 
            "title": "Exit Transition"
        }, 
        {
            "location": "/manual/storyboards/presenting-a-storyboard/", 
            "text": "Presenting A Storyboard\n\n\nStoryboards are presented from a scene. This could be a game scene, a menu scene, or any other content scene, over which the user interface is presented.\n\n\nTo present a storyboard, create a new game object in the scene, add the \nStoryboard\n component, and select your storyboard asset in the \nStoryboard\n field, as shown below. Run the scene and the storyboard will be presented.\n\n\n\n    \n\n    \nPresenting a storyboard from an empty scene.\n\n\n\n\n\n\n\nNote: A single \nUnity EventSystem\n is required to be present for canvases to receive input events. Therefore, depending on your game's structure, you may wish to place an Event System (\nGame Object/UI/Event System\n) in the scene presenting your storyboard.\n\n\n\n\nPresenting In World Space\n\n\nBy default, storyboards are presented in screen space. To present a storyboard in world space, simply select the storyboard component in the scene and change its \npresentation space\n to \nWorld Space\n. This will cause the storyboard to be presented in world space and embedded within the specified container.\n\n\n\n    \n\n    \nPresenting a storyboard in world space.\n\n\n\n\n\n\n\nNote that any subsequent storyboard transitions, as well as manual calls to \nPresentCanvasController\nT\n()\n, will automatically detect whether they should be presented in world space or screen space. If the presenting canvas controller is in world space, the presented canvas controller will also be in world space. Likewise, if the presenting canvas controller is in screen space, the presented canvas controller will also be in screen space.\n\n\n\n\nCallbacks\n\n\nAs shown above, three \nUnityEvent\n callbacks are available on a \nStoryboard\n component.\n\n\nThese callbacks can be particularly useful for passing scene data to the user interface, such as references to scene objects. For example, Canvas Flow's Floaty Cube example uses the \nStoryboardWillPresentInitialCanvasController\n callback to pass a reference to the player object to the initial game overlay screen. This allows the game overlay screen to display the player's current height. It is implemented like so:\n\n\npublic void OnGameStoryboardWillPresentInitialCanvasController(StoryboardTransition transition)\n{\n    var gameOverlayCanvasController =\n        transition.DestinationCanvasController\nFCGameOverlayCanvasController\n();\n    gameOverlayCanvasController.ConfigureWithPlayer(player);\n}\n\n\n\n\n\n\nNote: The callbacks pass a \nStoryboardTransition\n object, allowing you to access the canvas controllers involved.\n\n\n\n\nFor more information, please see the \nStoryboard component's documentation\n.", 
            "title": "Presenting A Storyboard"
        }, 
        {
            "location": "/manual/storyboards/presenting-a-storyboard/#presenting-a-storyboard", 
            "text": "Storyboards are presented from a scene. This could be a game scene, a menu scene, or any other content scene, over which the user interface is presented.  To present a storyboard, create a new game object in the scene, add the  Storyboard  component, and select your storyboard asset in the  Storyboard  field, as shown below. Run the scene and the storyboard will be presented.  \n     \n     Presenting a storyboard from an empty scene.    Note: A single  Unity EventSystem  is required to be present for canvases to receive input events. Therefore, depending on your game's structure, you may wish to place an Event System ( Game Object/UI/Event System ) in the scene presenting your storyboard.", 
            "title": "Presenting A Storyboard"
        }, 
        {
            "location": "/manual/storyboards/presenting-a-storyboard/#presenting-in-world-space", 
            "text": "By default, storyboards are presented in screen space. To present a storyboard in world space, simply select the storyboard component in the scene and change its  presentation space  to  World Space . This will cause the storyboard to be presented in world space and embedded within the specified container.  \n     \n     Presenting a storyboard in world space.    Note that any subsequent storyboard transitions, as well as manual calls to  PresentCanvasController T () , will automatically detect whether they should be presented in world space or screen space. If the presenting canvas controller is in world space, the presented canvas controller will also be in world space. Likewise, if the presenting canvas controller is in screen space, the presented canvas controller will also be in screen space.", 
            "title": "Presenting In World Space"
        }, 
        {
            "location": "/manual/storyboards/presenting-a-storyboard/#callbacks", 
            "text": "As shown above, three  UnityEvent  callbacks are available on a  Storyboard  component.  These callbacks can be particularly useful for passing scene data to the user interface, such as references to scene objects. For example, Canvas Flow's Floaty Cube example uses the  StoryboardWillPresentInitialCanvasController  callback to pass a reference to the player object to the initial game overlay screen. This allows the game overlay screen to display the player's current height. It is implemented like so:  public void OnGameStoryboardWillPresentInitialCanvasController(StoryboardTransition transition)\n{\n    var gameOverlayCanvasController =\n        transition.DestinationCanvasController FCGameOverlayCanvasController ();\n    gameOverlayCanvasController.ConfigureWithPlayer(player);\n}   Note: The callbacks pass a  StoryboardTransition  object, allowing you to access the canvas controllers involved.   For more information, please see the  Storyboard component's documentation .", 
            "title": "Callbacks"
        }, 
        {
            "location": "/manual/storyboards/custom-storyboard-hooks/", 
            "text": "Custom Storyboard Hooks\n\n\nCustom \nStoryboard Hooks\n allow you to use your own button types in storyboards. They will show up in the canvas preview area as \nhookable\n elements, just as native UI Buttons do.\n\n\n\n\nSee also: \nCreating a Custom Storyboard Hook For UI.Toggle\n\n\n\n\nOverview\n\n\nA storyboard hook is a component that is attached to game objects in your canvas controller's scene. Any game object in the canvas controller's scene with a \nStoryboardHook\n component will become \nhookable\n in a storyboard.\n\n\nYou do not use the \nStoryboardHook\n component directly, however. Instead, a subclass is created that adds support for a single target component type - the component that you wish to make \nhookable\n. It is this \nStoryboardHook\n subclass that is then added to any game objects with the target component type. Additionally, the process of adding \nStoryboardHook\n subclasses to their relevant game objects can be performed automatically for you by Canvas Flow, each time a canvas controller's scene is saved.\n\n\nFor example, Canvas Flow includes one such \nStoryboardHook\n subclass - \nStoryboardHookUnityEngineUIButton\n - which is a storyboard hook for native \nUI Button\n components. It can be (and is automatically) added to any game object with a \nUI.Button\n component in order to make it \nhookable\n in a storyboard.\n\n\nIn order to make your own buttons \nhookable\n in a storyboard, you must create a similar \nStoryboardHook\n subclass for your custom button type, as documented below.\n\n\n\n\nCanvas Flow's default storyboard hook for native \nUI Button\n components is included as a .cs file. This means you can easily inspect the source code, which is recommended when creating your first custom storyboard hook. It can be found in the Project inspector at \nCanvas Flow/Storyboard Hooks/StoryboardHookUnityEngineUIButton.cs\n.\n\n\n\n\n1. Create A New Storyboard Hook Subclass\n\n\nTo begin creating a new storyboard hook, open Unity's \nCreate\n menu - by either right-clicking in the Project window or selecting Assets in the menu bar - and selecting \nCreate/Canvas Flow/Storyboard Hook\n. Enter a name and a directory for your new hook. This will generate a new \nStoryboardHook\n subclass at the specified location.\n\n\nThe generated script contains three methods for you to implement.\n\n\n\n\nConnect()\n\n\nReset()\n\n\nAutoAddComponentType\n\n\n\n\n2. Implement The Connect Method\n\n\nWhen a canvas controller is loaded from a storyboard at runtime, its connected hooks will be provided with a callback via the \nConnect()\n method. Your hook's responsibility is to simply invoke this callback when it deems itself to have been triggered. Invoking the provided callback is all that is required to trigger a storyboard transition.\n\n\nSo, in the case of the \nStoryboardHookUnityEngineUIButton\n, the callback passed to the \nConnect()\n method is attached to the button's \nonClick\n handler.  This means that when the button is clicked, the callback will be invoked, triggering the storyboard transition.\n\n\nThe source code for the \nStoryboardHookUnityEngineUIButton\n's \nConnect()\n method is therefore:\n\n\npublic override void Connect(System.Action\nStoryboardHook\n invokeTransition)\n{\n    // For a Unity UI Button we invoke our storyboard transition when\n    // our Button is clicked.\n    button.onClick.AddListener(() =\n {\n        invokeTransition(this);\n    });\n}\n\n\n\n\nYou may wish to do some additional logic here. For example, if we were making a hook to be used with a UI Toggle switch, we might only wish to trigger the transition when the toggle is switched on, like so:\n\n\npublic override void Connect(System.Action\nStoryboardHook\n invokeTransition)\n{\n    toggle.onValueChanged.AddListener(() =\n\n    {\n        // Only invoke the transition if the toggle is switched on.\n        if (toggle.isOn)\n        {\n            invokeTransition(this);\n        }\n    });\n}\n\n\n\n\n\n\nNote: You can pass your hook to the callback with \nthis\n, as above. This causes it to be included in the subsequent \nStoryboardTransition\n object that is created and passed to methods such as \nPrepareForStoryboardTransition\n.\n\n\n\n\n3. Implement The Reset Method\n\n\nThe \nReset()\n method is called on your hook in the Unity Editor when the component is added to a game object or the user resets it in the inspector. A hook can be automatically added to a game object when the scene is saved or manually added in the inspector. In either case, the \nReset()\n method is where you must do any configuration you require.\n\n\nIn the case of the \nStoryboardHookUnityEngineUIButton\n, the \nReset()\n method obtains the required reference to the \nButton\n component that is used in the \nConnect()\n method above, like so:\n\n\nprotected override void Reset()\n{\n    // Always call base.Reset() when overriding Reset() in a custom hook.\n    base.Reset();\n\n    // Store a reference to the Button component.\n    button = GetComponent\nUnityEngine.UI.Button\n();\n}\n\n\n\n\nYou might wish to follow a similar pattern, storing a reference to your custom button type that can later be used in the \nConnect()\n method.\n\n\n4. Implement The Auto-Add Component Type Property (Optional)\n\n\nWhen a canvas controller scene is saved in the Editor, Canvas Flow will ensure that storyboard hooks are present on any game objects with the hook's 'auto-add' component type. Here you can return the target type of your hook, such as your custom button type, to have your hook automatically added to any game objects with the target component type.\n\n\nFor example, Canvas Flow's default storyboard hook for native \nUI Button\n components returns the \nUI.Button\n component here, causing it to automatically be added to any game objects with a \nUI.Button\n component.\n\n\npublic override System.Type AutoAddComponentType\n{\n    get\n    {\n        // Automatically add this hook to game objects with a Unity UI\n        // Button component when the scene is saved.\n        return typeof(UnityEngine.UI.Button);\n    }\n}\n\n\n\n\n\n\nNote: This is an optional step. You may return \nnull\n here if you do not want your custom storyboard hook to automatically be added to the target component type when the scene is saved. Additionally, you can turn off \nauto-add\n for all storyboard hooks in Canvas Flow's preferences, found in the menu bar at \nUnity/Preferences/Canvas Flow\n.", 
            "title": "Custom Storyboard Hooks"
        }, 
        {
            "location": "/manual/storyboards/custom-storyboard-hooks/#custom-storyboard-hooks", 
            "text": "Custom  Storyboard Hooks  allow you to use your own button types in storyboards. They will show up in the canvas preview area as  hookable  elements, just as native UI Buttons do.   See also:  Creating a Custom Storyboard Hook For UI.Toggle", 
            "title": "Custom Storyboard Hooks"
        }, 
        {
            "location": "/manual/storyboards/custom-storyboard-hooks/#overview", 
            "text": "A storyboard hook is a component that is attached to game objects in your canvas controller's scene. Any game object in the canvas controller's scene with a  StoryboardHook  component will become  hookable  in a storyboard.  You do not use the  StoryboardHook  component directly, however. Instead, a subclass is created that adds support for a single target component type - the component that you wish to make  hookable . It is this  StoryboardHook  subclass that is then added to any game objects with the target component type. Additionally, the process of adding  StoryboardHook  subclasses to their relevant game objects can be performed automatically for you by Canvas Flow, each time a canvas controller's scene is saved.  For example, Canvas Flow includes one such  StoryboardHook  subclass -  StoryboardHookUnityEngineUIButton  - which is a storyboard hook for native  UI Button  components. It can be (and is automatically) added to any game object with a  UI.Button  component in order to make it  hookable  in a storyboard.  In order to make your own buttons  hookable  in a storyboard, you must create a similar  StoryboardHook  subclass for your custom button type, as documented below.   Canvas Flow's default storyboard hook for native  UI Button  components is included as a .cs file. This means you can easily inspect the source code, which is recommended when creating your first custom storyboard hook. It can be found in the Project inspector at  Canvas Flow/Storyboard Hooks/StoryboardHookUnityEngineUIButton.cs .", 
            "title": "Overview"
        }, 
        {
            "location": "/manual/storyboards/custom-storyboard-hooks/#1-create-a-new-storyboard-hook-subclass", 
            "text": "To begin creating a new storyboard hook, open Unity's  Create  menu - by either right-clicking in the Project window or selecting Assets in the menu bar - and selecting  Create/Canvas Flow/Storyboard Hook . Enter a name and a directory for your new hook. This will generate a new  StoryboardHook  subclass at the specified location.  The generated script contains three methods for you to implement.   Connect()  Reset()  AutoAddComponentType", 
            "title": "1. Create A New Storyboard Hook Subclass"
        }, 
        {
            "location": "/manual/storyboards/custom-storyboard-hooks/#2-implement-the-connect-method", 
            "text": "When a canvas controller is loaded from a storyboard at runtime, its connected hooks will be provided with a callback via the  Connect()  method. Your hook's responsibility is to simply invoke this callback when it deems itself to have been triggered. Invoking the provided callback is all that is required to trigger a storyboard transition.  So, in the case of the  StoryboardHookUnityEngineUIButton , the callback passed to the  Connect()  method is attached to the button's  onClick  handler.  This means that when the button is clicked, the callback will be invoked, triggering the storyboard transition.  The source code for the  StoryboardHookUnityEngineUIButton 's  Connect()  method is therefore:  public override void Connect(System.Action StoryboardHook  invokeTransition)\n{\n    // For a Unity UI Button we invoke our storyboard transition when\n    // our Button is clicked.\n    button.onClick.AddListener(() =  {\n        invokeTransition(this);\n    });\n}  You may wish to do some additional logic here. For example, if we were making a hook to be used with a UI Toggle switch, we might only wish to trigger the transition when the toggle is switched on, like so:  public override void Connect(System.Action StoryboardHook  invokeTransition)\n{\n    toggle.onValueChanged.AddListener(() = \n    {\n        // Only invoke the transition if the toggle is switched on.\n        if (toggle.isOn)\n        {\n            invokeTransition(this);\n        }\n    });\n}   Note: You can pass your hook to the callback with  this , as above. This causes it to be included in the subsequent  StoryboardTransition  object that is created and passed to methods such as  PrepareForStoryboardTransition .", 
            "title": "2. Implement The Connect Method"
        }, 
        {
            "location": "/manual/storyboards/custom-storyboard-hooks/#3-implement-the-reset-method", 
            "text": "The  Reset()  method is called on your hook in the Unity Editor when the component is added to a game object or the user resets it in the inspector. A hook can be automatically added to a game object when the scene is saved or manually added in the inspector. In either case, the  Reset()  method is where you must do any configuration you require.  In the case of the  StoryboardHookUnityEngineUIButton , the  Reset()  method obtains the required reference to the  Button  component that is used in the  Connect()  method above, like so:  protected override void Reset()\n{\n    // Always call base.Reset() when overriding Reset() in a custom hook.\n    base.Reset();\n\n    // Store a reference to the Button component.\n    button = GetComponent UnityEngine.UI.Button ();\n}  You might wish to follow a similar pattern, storing a reference to your custom button type that can later be used in the  Connect()  method.", 
            "title": "3. Implement The Reset Method"
        }, 
        {
            "location": "/manual/storyboards/custom-storyboard-hooks/#4-implement-the-auto-add-component-type-property-optional", 
            "text": "When a canvas controller scene is saved in the Editor, Canvas Flow will ensure that storyboard hooks are present on any game objects with the hook's 'auto-add' component type. Here you can return the target type of your hook, such as your custom button type, to have your hook automatically added to any game objects with the target component type.  For example, Canvas Flow's default storyboard hook for native  UI Button  components returns the  UI.Button  component here, causing it to automatically be added to any game objects with a  UI.Button  component.  public override System.Type AutoAddComponentType\n{\n    get\n    {\n        // Automatically add this hook to game objects with a Unity UI\n        // Button component when the scene is saved.\n        return typeof(UnityEngine.UI.Button);\n    }\n}   Note: This is an optional step. You may return  null  here if you do not want your custom storyboard hook to automatically be added to the target component type when the scene is saved. Additionally, you can turn off  auto-add  for all storyboard hooks in Canvas Flow's preferences, found in the menu bar at  Unity/Preferences/Canvas Flow .", 
            "title": "4. Implement The Auto-Add Component Type Property (Optional)"
        }, 
        {
            "location": "/manual/transition-animators/introduction/", 
            "text": "Transition Animators\n\n\nTransition animators are responsible for animating the transition between two canvas controllers.\n\n\nCanvas Flow includes five transition animators by default, which are:\n\n\n\n\nDefault\n\n\nFade To Color\n\n\nSlide\n\n\nScale\n\n\nScale \n Fade Background\n\n\n\n\nTo use a transition animator, you first create an instance of it, as described in \nUsing A Transition Animator\n.\n\n\nYou may also create your own transition animators to implement a custom transition animation between canvas controllers, as outlined in the \nCustom Transition Animators\n section.", 
            "title": "Introduction"
        }, 
        {
            "location": "/manual/transition-animators/introduction/#transition-animators", 
            "text": "Transition animators are responsible for animating the transition between two canvas controllers.  Canvas Flow includes five transition animators by default, which are:   Default  Fade To Color  Slide  Scale  Scale   Fade Background   To use a transition animator, you first create an instance of it, as described in  Using A Transition Animator .  You may also create your own transition animators to implement a custom transition animation between canvas controllers, as outlined in the  Custom Transition Animators  section.", 
            "title": "Transition Animators"
        }, 
        {
            "location": "/manual/transition-animators/default-transition-animators/transition-animator-default/", 
            "text": "Default Transition Animator\n\n\n\n\nTo use a transition animator, you first create an instance of it, as described in \nUsing A Transition Animator\n.\n\n\n\n\nDescription\n\n\nThe default transition animator presents content from the bottom of the screen, sliding it upwards. It dismisses content by performing the reverse - animating onscreen content downwards.\n\n\n\n    \n\n    \nA default transition animator.\n\n    \n\n\n\n\n\nConfiguration\n\n\n\n    \n\n    \nThe configurable properties of a default transition animator.\n\n    \n\n\n\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nDuration\n\n\nThe duration of the transition.\n\n\n\n\n\n\nCurve\n\n\nThe animation curve of the transition.\n\n\n\n\n\n\nUse Scaled Time\n\n\nAnimate with scaled time. By default this transition uses unscaled time - i.e. it won't be affected by changes to 'Time.timeScale'. This allows it to animate when the game is paused, for example. Enable this if you want the transition to be affected by changes to 'Time.timeScale'.", 
            "title": "Default Transition Animator"
        }, 
        {
            "location": "/manual/transition-animators/default-transition-animators/transition-animator-default/#default-transition-animator", 
            "text": "To use a transition animator, you first create an instance of it, as described in  Using A Transition Animator .", 
            "title": "Default Transition Animator"
        }, 
        {
            "location": "/manual/transition-animators/default-transition-animators/transition-animator-default/#description", 
            "text": "The default transition animator presents content from the bottom of the screen, sliding it upwards. It dismisses content by performing the reverse - animating onscreen content downwards.  \n     \n     A default transition animator.", 
            "title": "Description"
        }, 
        {
            "location": "/manual/transition-animators/default-transition-animators/transition-animator-default/#configuration", 
            "text": "The configurable properties of a default transition animator. \n          Name  Description      Duration  The duration of the transition.    Curve  The animation curve of the transition.    Use Scaled Time  Animate with scaled time. By default this transition uses unscaled time - i.e. it won't be affected by changes to 'Time.timeScale'. This allows it to animate when the game is paused, for example. Enable this if you want the transition to be affected by changes to 'Time.timeScale'.", 
            "title": "Configuration"
        }, 
        {
            "location": "/manual/transition-animators/default-transition-animators/transition-animator-fade-to-color/", 
            "text": "Fade To Color Transition Animator\n\n\n\n\nTo use a transition animator, you first create an instance of it, as described in \nUsing A Transition Animator\n.\n\n\n\n\nDescription\n\n\nThe 'fade to color' transition animator creates a color fade transition between screens.\n\n\nIt will first fade from the source content to the specified color - the 'pre-fade' - and then fade from the specified color to the destination content - the 'post-fade'.\n\n\n\n    \n\n    \nA fade to color transition animator.\n\n    \n\n\n\n\n\nConfiguration\n\n\n\n    \n\n    \nThe configurable properties of a fade to color transition animator.\n\n    \n\n\n\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nColor\n\n\nThe color of the transition.\n\n\n\n\n\n\nPre-fade Settings\n\n\nThe settings for the 'pre-fade' section of the transition.\n\n\n\n\n\n\nDuration\n\n\nThe duration of the pre-fade transition.\n\n\n\n\n\n\nCurve\n\n\nThe animation curve of the pre-fade transition.\n\n\n\n\n\n\nPre-fade Settings\n\n\nThe settings for the 'post-fade' section of the transition.\n\n\n\n\n\n\nDuration\n\n\nThe duration of the post-fade transition.\n\n\n\n\n\n\nCurve\n\n\nThe animation curve of the post-fade transition.\n\n\n\n\n\n\nUse Scaled Time\n\n\nAnimate with scaled time. By default this transition uses unscaled time - i.e. it won't be affected by changes to 'Time.timeScale'. This allows it to animate when the game is paused, for example. Enable this if you want the transition to be affected by changes to 'Time.timeScale'.", 
            "title": "Fade To Color Transition Animator"
        }, 
        {
            "location": "/manual/transition-animators/default-transition-animators/transition-animator-fade-to-color/#fade-to-color-transition-animator", 
            "text": "To use a transition animator, you first create an instance of it, as described in  Using A Transition Animator .", 
            "title": "Fade To Color Transition Animator"
        }, 
        {
            "location": "/manual/transition-animators/default-transition-animators/transition-animator-fade-to-color/#description", 
            "text": "The 'fade to color' transition animator creates a color fade transition between screens.  It will first fade from the source content to the specified color - the 'pre-fade' - and then fade from the specified color to the destination content - the 'post-fade'.  \n     \n     A fade to color transition animator.", 
            "title": "Description"
        }, 
        {
            "location": "/manual/transition-animators/default-transition-animators/transition-animator-fade-to-color/#configuration", 
            "text": "The configurable properties of a fade to color transition animator. \n          Name  Description      Color  The color of the transition.    Pre-fade Settings  The settings for the 'pre-fade' section of the transition.    Duration  The duration of the pre-fade transition.    Curve  The animation curve of the pre-fade transition.    Pre-fade Settings  The settings for the 'post-fade' section of the transition.    Duration  The duration of the post-fade transition.    Curve  The animation curve of the post-fade transition.    Use Scaled Time  Animate with scaled time. By default this transition uses unscaled time - i.e. it won't be affected by changes to 'Time.timeScale'. This allows it to animate when the game is paused, for example. Enable this if you want the transition to be affected by changes to 'Time.timeScale'.", 
            "title": "Configuration"
        }, 
        {
            "location": "/manual/transition-animators/default-transition-animators/transition-animator-slide/", 
            "text": "Slide Transition Animator\n\n\n\n\nTo use a transition animator, you first create an instance of it, as described in \nUsing A Transition Animator\n.\n\n\n\n\nDescription\n\n\nThe slide transition animation presents content by sliding it in from an off-screen location. It dismisses content by performing the reverse - sliding it to an off-screen location.\n\n\nIn addition to the presented canvas controller, the presenting canvas controller can also be animated to and from an off-screen location. This gives the appearance of the content sliding out as the presented content slides in.\n\n\nWith the \npresentingCanvasParallaxScalar\n property, you can scale the amount by which the presenter moves, creating parallax effects. A value of 1 will animate fully to the off-screen location (no parallax), whilst 0.5 would animate halfway to the off-screen location. A value of 0 has the same effect as disabling \nanimatePresentingCanvas\n.\n\n\n\n    \n\n    \nA slide transition animator.\n\n    \n\n\n\n\n\nConfiguration\n\n\n\n    \n\n    \nThe configurable properties of a slide transition animator.\n\n    \n\n\n\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nDuration\n\n\nThe duration of the transition.\n\n\n\n\n\n\nCurve\n\n\nThe animation curve of the transition.\n\n\n\n\n\n\nUse Scaled Time\n\n\nAnimate with scaled time. By default this transition uses unscaled time - i.e. it won't be affected by changes to 'Time.timeScale'. This allows it to animate when the game is paused, for example. Enable this if you want the transition to be affected by changes to 'Time.timeScale'.\n\n\n\n\n\n\nPresented Canvas\n\n\n\n\n\n\n\n\nPresented Canvas Off Screen Location\n\n\nThe off-screen location of the presented canvas.\n\n\n\n\n\n\nPresenting Canvas\n\n\n\n\n\n\n\n\nAnimate Presenting Canvas\n\n\nAnimate the presenting canvas.\n\n\n\n\n\n\nPresenting Canvas Off Screen Location\n\n\nThe off-screen location of the presenting canvas.\n\n\n\n\n\n\nPresenting Canvas Parallax Scalar\n\n\nThe presenting canvas' parallax scalar. A value of 1 will animate fully to the off-screen location (no parallax), whilst 0.5 would animate halfway to the off-screen location.", 
            "title": "Slide Transition Animator"
        }, 
        {
            "location": "/manual/transition-animators/default-transition-animators/transition-animator-slide/#slide-transition-animator", 
            "text": "To use a transition animator, you first create an instance of it, as described in  Using A Transition Animator .", 
            "title": "Slide Transition Animator"
        }, 
        {
            "location": "/manual/transition-animators/default-transition-animators/transition-animator-slide/#description", 
            "text": "The slide transition animation presents content by sliding it in from an off-screen location. It dismisses content by performing the reverse - sliding it to an off-screen location.  In addition to the presented canvas controller, the presenting canvas controller can also be animated to and from an off-screen location. This gives the appearance of the content sliding out as the presented content slides in.  With the  presentingCanvasParallaxScalar  property, you can scale the amount by which the presenter moves, creating parallax effects. A value of 1 will animate fully to the off-screen location (no parallax), whilst 0.5 would animate halfway to the off-screen location. A value of 0 has the same effect as disabling  animatePresentingCanvas .  \n     \n     A slide transition animator.", 
            "title": "Description"
        }, 
        {
            "location": "/manual/transition-animators/default-transition-animators/transition-animator-slide/#configuration", 
            "text": "The configurable properties of a slide transition animator. \n          Name  Description      Duration  The duration of the transition.    Curve  The animation curve of the transition.    Use Scaled Time  Animate with scaled time. By default this transition uses unscaled time - i.e. it won't be affected by changes to 'Time.timeScale'. This allows it to animate when the game is paused, for example. Enable this if you want the transition to be affected by changes to 'Time.timeScale'.    Presented Canvas     Presented Canvas Off Screen Location  The off-screen location of the presented canvas.    Presenting Canvas     Animate Presenting Canvas  Animate the presenting canvas.    Presenting Canvas Off Screen Location  The off-screen location of the presenting canvas.    Presenting Canvas Parallax Scalar  The presenting canvas' parallax scalar. A value of 1 will animate fully to the off-screen location (no parallax), whilst 0.5 would animate halfway to the off-screen location.", 
            "title": "Configuration"
        }, 
        {
            "location": "/manual/transition-animators/default-transition-animators/transition-animator-scale/", 
            "text": "Scale Transition Animator\n\n\n\n\nTo use a transition animator, you first create an instance of it, as described in \nUsing A Transition Animator\n.\n\n\n\n\nDescription\n\n\nThe scale transition animator presents content by scaling it up from the center of the screen. It dismisses content by performing the reverse - scaling content down.\n\n\nThe reverseCurveOnUpstream flag causes the animation curve to be evaluated backwards on upstream transitions.\n\n\n\n    \n\n    \nA scale transition animator.\n\n    \n\n\n\n\n\nConfiguration\n\n\n\n    \n\n    \nThe configurable properties of a scale transition animator.\n\n    \n\n\n\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nDuration\n\n\nThe duration of the transition.\n\n\n\n\n\n\nCurve\n\n\nThe animation curve of the transition.\n\n\n\n\n\n\nReverse Curve On Upstream\n\n\nReverse the animation curve for upstream transitions.\n\n\n\n\n\n\nUse Scaled Time\n\n\nAnimate with scaled time. By default this transition uses unscaled time - i.e. it won't be affected by changes to 'Time.timeScale'. This allows it to animate when the game is paused, for example. Enable this if you want the transition to be affected by changes to 'Time.timeScale'.", 
            "title": "Scale Transition Animator"
        }, 
        {
            "location": "/manual/transition-animators/default-transition-animators/transition-animator-scale/#scale-transition-animator", 
            "text": "To use a transition animator, you first create an instance of it, as described in  Using A Transition Animator .", 
            "title": "Scale Transition Animator"
        }, 
        {
            "location": "/manual/transition-animators/default-transition-animators/transition-animator-scale/#description", 
            "text": "The scale transition animator presents content by scaling it up from the center of the screen. It dismisses content by performing the reverse - scaling content down.  The reverseCurveOnUpstream flag causes the animation curve to be evaluated backwards on upstream transitions.  \n     \n     A scale transition animator.", 
            "title": "Description"
        }, 
        {
            "location": "/manual/transition-animators/default-transition-animators/transition-animator-scale/#configuration", 
            "text": "The configurable properties of a scale transition animator. \n          Name  Description      Duration  The duration of the transition.    Curve  The animation curve of the transition.    Reverse Curve On Upstream  Reverse the animation curve for upstream transitions.    Use Scaled Time  Animate with scaled time. By default this transition uses unscaled time - i.e. it won't be affected by changes to 'Time.timeScale'. This allows it to animate when the game is paused, for example. Enable this if you want the transition to be affected by changes to 'Time.timeScale'.", 
            "title": "Configuration"
        }, 
        {
            "location": "/manual/transition-animators/default-transition-animators/transition-animator-scale-and-fade/", 
            "text": "Scale And Fade Background Transition Animator\n\n\n\n\nTo use a transition animator, you first create an instance of it, as described in \nUsing A Transition Animator\n.\n\n\n\n\nDescription\n\n\nThe 'scale and fade background' transition animator presents content by scaling it up from the center of the screen, whilst fading in the backgroundImage property. It dismisses content by performing the reverse - scaling content down and fading out the backgroundImage property.\n\n\nThe \ncontentToScalePropertyName\n field allows you to specify what content gets scaled in your transition. You can set this to the name of any \nRectTransform\n property on your canvas controller. If none is specified or the property does not exist, the canvas controller's 'content' transform will be scaled.\n\n\nThe \nreverseScaleCurveOnUpstream\n and \nreverseFadeCurveOnUpstream\n flags cause the relevant animation curves to be evaluated backwards on upstream transitions.\n\n\n\n    \n\n    \nA scale transition animator.\n\n    \n\n\n\n\n\nConfiguration\n\n\n\n    \n\n    \nThe configurable properties of a scale and fade background transition animator.\n\n    \n\n\n\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nDuration\n\n\nThe duration of the transition.\n\n\n\n\n\n\nScale Settings\n\n\n\n\n\n\n\n\nScale Curve\n\n\nThe animation curve for the scaling animation of the transition.\n\n\n\n\n\n\nContent To Scale Property Name\n\n\nThe property name of the content to be scaled.\n\n\n\n\n\n\nReverse Scale Curve On Upstream\n\n\nReverse the scale animation curve for upstream transitions.\n\n\n\n\n\n\nFade Settings\n\n\n\n\n\n\n\n\nFade Curve\n\n\nThe animation curve for the fading animation of the transition.\n\n\n\n\n\n\nReverse Fade Curve On Upstream\n\n\nReverse the fade animation curve for upstream transitions.\n\n\n\n\n\n\nUse Scaled Time\n\n\nAnimate with scaled time. By default this transition uses unscaled time - i.e. it won't be affected by changes to 'Time.timeScale'. This allows it to animate when the game is paused, for example. Enable this if you want the transition to be affected by changes to 'Time.timeScale'.", 
            "title": "Scale And Fade Background Transition Animator"
        }, 
        {
            "location": "/manual/transition-animators/default-transition-animators/transition-animator-scale-and-fade/#scale-and-fade-background-transition-animator", 
            "text": "To use a transition animator, you first create an instance of it, as described in  Using A Transition Animator .", 
            "title": "Scale And Fade Background Transition Animator"
        }, 
        {
            "location": "/manual/transition-animators/default-transition-animators/transition-animator-scale-and-fade/#description", 
            "text": "The 'scale and fade background' transition animator presents content by scaling it up from the center of the screen, whilst fading in the backgroundImage property. It dismisses content by performing the reverse - scaling content down and fading out the backgroundImage property.  The  contentToScalePropertyName  field allows you to specify what content gets scaled in your transition. You can set this to the name of any  RectTransform  property on your canvas controller. If none is specified or the property does not exist, the canvas controller's 'content' transform will be scaled.  The  reverseScaleCurveOnUpstream  and  reverseFadeCurveOnUpstream  flags cause the relevant animation curves to be evaluated backwards on upstream transitions.  \n     \n     A scale transition animator.", 
            "title": "Description"
        }, 
        {
            "location": "/manual/transition-animators/default-transition-animators/transition-animator-scale-and-fade/#configuration", 
            "text": "The configurable properties of a scale and fade background transition animator. \n          Name  Description      Duration  The duration of the transition.    Scale Settings     Scale Curve  The animation curve for the scaling animation of the transition.    Content To Scale Property Name  The property name of the content to be scaled.    Reverse Scale Curve On Upstream  Reverse the scale animation curve for upstream transitions.    Fade Settings     Fade Curve  The animation curve for the fading animation of the transition.    Reverse Fade Curve On Upstream  Reverse the fade animation curve for upstream transitions.    Use Scaled Time  Animate with scaled time. By default this transition uses unscaled time - i.e. it won't be affected by changes to 'Time.timeScale'. This allows it to animate when the game is paused, for example. Enable this if you want the transition to be affected by changes to 'Time.timeScale'.", 
            "title": "Configuration"
        }, 
        {
            "location": "/manual/transition-animators/using-a-transition-animator/", 
            "text": "Using A Transition Animator\n\n\nCreate An Instance\n\n\nTo use a transition animator, begin by creating an instance of it. All available transition animators are listed in Unity's \nCreate\n menu, accessed by either right-clicking in the Project window or selecting Assets in the menu bar.\n\n\n\n    \n\n    \nThe available transition animators are listed in the Create menu.\n\n    \n\n\n\n\n\nThis will create a new \ntransition animator\n asset in your project. Select the new transition animator instance to open the inspector and view its properties. Here you can adjust any exposed properties on the transition animator, allowing you to tweak each transition animator on a per instance basis. For example, the \nFade To Color\n animator exposes the following properties:\n\n\n\n    \n\n    \nThe 'Fade To Color' transition animator inspector.\n\n    \n\n\n\n\n\n\n\nYou can have many instances of the same transition animator in your project, each configured differently. For example, you might have two instances of the 'Fade To Color' animator, one that fades to black, and one that fades to white.\n\n\n\n\nUsing With Storyboards\n\n\nTo use this new transition animator instance in a storyboard transition, simply select the transition in the storyboard, and drop the instance onto the \nCustom Animator\n field, as shown in the video below. This transition will now be animated by the specified instance.\n\n\n\n    \n\n    \nSetting a transition animator on a storyboard transition.\n\n    \n\n\n\n\n\nUsing Directly With Canvas Controllers\n\n\nTo use a transition animator instance when presenting and dismissing canvas controllers from script, you must provide, or \nvend\n, the animator instance to Canvas Flow when the transition is about to be performed. This process is as follows:\n\n\nWhen a transition is to be performed, the target canvas controller's\n1\n \ntransitioningAnimatorVendor\n will be asked to provide an animator for the transition. You should therefore specify the target canvas controller's \ntransitioningAnimatorVendor\n and return your animator instance in the \nTransitioningAnimatorForContext\n method.\n\n\n1. The target canvas controller is the canvas controller being acted upon - i.e. the canvas controler being presented or being dismissed. Therefore, in a presentation, this will be the transition context's \ndestinationCanvasController\n, whereas in a dismissal, this will be the transition context's \nsourceCanvasController\n.\n\n\nFor example, in Canvas Flow's Transitions example, the menu screen sets itself as the \ntransitioningAnimatorVendor\n when presenting a canvas controller. This is done in the configuration action, as shown below.\n\n\nPresentCanvasController\nTEFadeTransitionCanvasController\n(\n    configuration: (fadeDescriptionCanvasController) =\n\n{\n    fadeDescriptionCanvasController.transitioningAnimatorVendor = this;\n});\n\n\n\n\nThen the menu screen implements the required \nTransitioningAnimatorForContext\n method, returning the appropriate transition animator based upon the context.\n\n\n// Set in the inspector.\npublic CanvasControllerTransitioningAnimator fadeTransitionAnimator;\n\npublic ICanvasControllerTransitioningAnimator TransitioningAnimatorForContext(\n    CanvasControllerTransitionContext transitionContext)\n{\n    // The presented canvas controller is the destination on downstream transitions (Present)\n    // and the source on upstream transitions (Dismiss).\n    CanvasController presentedCanvasController = (transitionContext.isUpstream) ?\n        transitionContext.sourceCanvasController : transitionContext.destinationCanvasController;\n\n    if (presentedCanvasController is TEFadeTransitionCanvasController)\n    {\n      return fadeTransitionAnimator;\n    }\n\n    return null\n}\n\n\n\n\n\n\nYou may return \nnull\n in your TransitioningAnimatorForContext implementation to use the default transition animator. For example, in the above implementation, we only use our fade animator if we are transitioning to or from the \nTEFadeTransitionCanvasController\n, otherwise \nnull\n is returned and the default animator is used.", 
            "title": "Using A Transition Animator"
        }, 
        {
            "location": "/manual/transition-animators/using-a-transition-animator/#using-a-transition-animator", 
            "text": "", 
            "title": "Using A Transition Animator"
        }, 
        {
            "location": "/manual/transition-animators/using-a-transition-animator/#create-an-instance", 
            "text": "To use a transition animator, begin by creating an instance of it. All available transition animators are listed in Unity's  Create  menu, accessed by either right-clicking in the Project window or selecting Assets in the menu bar.  \n     \n     The available transition animators are listed in the Create menu. \n       This will create a new  transition animator  asset in your project. Select the new transition animator instance to open the inspector and view its properties. Here you can adjust any exposed properties on the transition animator, allowing you to tweak each transition animator on a per instance basis. For example, the  Fade To Color  animator exposes the following properties:  \n     \n     The 'Fade To Color' transition animator inspector. \n        You can have many instances of the same transition animator in your project, each configured differently. For example, you might have two instances of the 'Fade To Color' animator, one that fades to black, and one that fades to white.", 
            "title": "Create An Instance"
        }, 
        {
            "location": "/manual/transition-animators/using-a-transition-animator/#using-with-storyboards", 
            "text": "To use this new transition animator instance in a storyboard transition, simply select the transition in the storyboard, and drop the instance onto the  Custom Animator  field, as shown in the video below. This transition will now be animated by the specified instance.  \n     \n     Setting a transition animator on a storyboard transition.", 
            "title": "Using With Storyboards"
        }, 
        {
            "location": "/manual/transition-animators/using-a-transition-animator/#using-directly-with-canvas-controllers", 
            "text": "To use a transition animator instance when presenting and dismissing canvas controllers from script, you must provide, or  vend , the animator instance to Canvas Flow when the transition is about to be performed. This process is as follows:  When a transition is to be performed, the target canvas controller's 1   transitioningAnimatorVendor  will be asked to provide an animator for the transition. You should therefore specify the target canvas controller's  transitioningAnimatorVendor  and return your animator instance in the  TransitioningAnimatorForContext  method.  1. The target canvas controller is the canvas controller being acted upon - i.e. the canvas controler being presented or being dismissed. Therefore, in a presentation, this will be the transition context's  destinationCanvasController , whereas in a dismissal, this will be the transition context's  sourceCanvasController .  For example, in Canvas Flow's Transitions example, the menu screen sets itself as the  transitioningAnimatorVendor  when presenting a canvas controller. This is done in the configuration action, as shown below.  PresentCanvasController TEFadeTransitionCanvasController (\n    configuration: (fadeDescriptionCanvasController) = \n{\n    fadeDescriptionCanvasController.transitioningAnimatorVendor = this;\n});  Then the menu screen implements the required  TransitioningAnimatorForContext  method, returning the appropriate transition animator based upon the context.  // Set in the inspector.\npublic CanvasControllerTransitioningAnimator fadeTransitionAnimator;\n\npublic ICanvasControllerTransitioningAnimator TransitioningAnimatorForContext(\n    CanvasControllerTransitionContext transitionContext)\n{\n    // The presented canvas controller is the destination on downstream transitions (Present)\n    // and the source on upstream transitions (Dismiss).\n    CanvasController presentedCanvasController = (transitionContext.isUpstream) ?\n        transitionContext.sourceCanvasController : transitionContext.destinationCanvasController;\n\n    if (presentedCanvasController is TEFadeTransitionCanvasController)\n    {\n      return fadeTransitionAnimator;\n    }\n\n    return null\n}   You may return  null  in your TransitioningAnimatorForContext implementation to use the default transition animator. For example, in the above implementation, we only use our fade animator if we are transitioning to or from the  TEFadeTransitionCanvasController , otherwise  null  is returned and the default animator is used.", 
            "title": "Using Directly With Canvas Controllers"
        }, 
        {
            "location": "/manual/transition-animators/custom-transition-animators/", 
            "text": "Custom Transition Animators\n\n\nYou may create your own transition animators to implement a custom transition animation between canvas controllers. If following the steps below, your custom transition animator will be displayed in Unity's \nCreate\n menu alongside the default transition animators, and will therefore also be compatible with storyboards.\n\n\n\n\nCanvas Flow's default transition animators are included as .cs files. This means you can easily inspect their source code, which is recommended when creating your first custom transition animator. They can be found in the Project inspector at \nCanvas Flow/Transition Animators/\n.\n\n\n\n\n\n\n\n\nSee also: \nCreating A Custom Transition Animator Using DOTween\n\n\n\n\n1. Create A Custom Transition Animator Script\n\n\nTo begin creating a new transition animator, open Unity's \nCreate\n menu - by either right-clicking in the Project window or selecting Assets in the menu bar - and selecting \nCreate/Canvas Flow/Custom Transition Animator\n. Enter a name and a directory for your new animator. This will generate a new transition animator script file at the specified location.\n\n\nThe generated script contains two methods for you to implement.\n\n\n\n\nAnimateTransition()\n\n\nAnimateTransitionForInitialCanvasController()\n\n\n\n\n2. The Animate Transition Method\n\n\nAs described in \nUsing A Transition Animator\n, an instance of your custom transition animator will be \nvended\n to Canvas Flow at runtime when the transition is about to be performed. Once this has occurred, Canvas Flow will tell the transition animator to perform the transition by calling its \nAnimateTransition()\n method. This is where you can perform your custom animation. Please see \nPerforming The Animation\n for more details.\n\n\npublic override void AnimateTransition(CanvasControllerTransitionContext transitionContext)\n{\n    /*  \n      *  Do your custom animation with the source and destination content\n      *  here. For example:\n      *\n      *  CanvasController source = transitionContext.sourceCanvasController;\n      *  CanvasController destination = transitionContext.destinationCanvasController;\n      *\n      *  source.ContentPosition = ...\n      *  destination.ContentScale = ...\n      */\n\n    /*  \n     *  Call CompleteTransition() on the transition context once you have\n     *  performed your custom animation.\n     */\n    transitionContext.CompleteTransition();\n}\n\n\n\n\n\n\nWhen your transition animator has completed its animation, you must call \nCompleteTransition\n on the provided transition context. This tells Canvas Flow that the custom animation has been performed and to complete the transition.\n\n\n\n\n3. The Animate Transition For Initial Canvas Controller Method (Optional)\n\n\nThe \nAnimateTransitionForInitialCanvasController()\n method is called on your transition animator when the transition is presenting or dismissing an initial canvas controller. An initial canvas controller is one with no presenter - i.e. it was the first canvas controller presented, perhaps from a storyboard entry transition or using \nPresentInitialCanvasController\n. Therefore, you only need to implement this method if you intend to use your transition animator on transitions involving an initial canvas controller.\n\n\nThe only difference from the \nAnimateTransition\n method is that either the context's \nsourceCanvasController\n or \ndestinationCanvasController\n will be null, depending on whether the transition context \nisUpstream\n - i.e. it is presenting/dismissing to \n'nothing'\n.\n\n\nThe default transition animator, found in \nCanvas Flow/Transition Animators/DefaultTransitionAnimator.cs\n simply forwards this method to \nAnimateTransition()\n as it only ever operates on the presented canvas, like so:\n\n\npublic override void AnimateTransitionInvolvingInitialCanvasController(\n    CanvasControllerTransitionContext transitionContext)\n{\n    /*\n     *  We support transitions to and from the initial canvas controller by\n     *  default in our main AnimateTransition() method as we only operate on the\n     *  presented canvas controller, so we can just forward to that method.\n     */\n\n    AnimateTransition(transitionContext);\n}\n\n\n\n\nPlease see \nCanvas Flow/Transition Animators/FadeToColorTransitionAnimator.cs\n for an example of how different behaviour can be implemented when presenting/dismissing the initial canvas controller.\n\n\n4. Performing The Animation\n\n\nBelow is an example of a complete \nAnimateTransition\n method, which animates the presented canvas controller from/to the bottom of the screen. This will serve as a basis for presenting several useful pointers when animating canvas controllers.\n\n\n\n\nNote that you are free to animate the context's canvas controllers however you wish, including using external animation tools.\n\n\n\n\npublic override void AnimateTransition(CanvasControllerTransitionContext transitionContext)\n{\n    // Determine the target canvas controller - the one being presented or dismissed.\n    var targetCanvasController = (transitionContext.isUpstream) ?\n        transitionContext.sourceCanvasController :\n            transitionContext.destinationCanvasController;\n\n    // Determine the content's start position.\n    Vector3 contentStartPosition = (transitionContext.isUpstream) ?\n        targetCanvasController.OnScreenContentPosition() :\n            targetCanvasController.OffScreenBottomContentPosition();\n\n    // Determine the content's end position.\n    Vector3 contentEndPosition = (transitionContext.isUpstream) ?\n        targetCanvasController.OffScreenBottomContentPosition() :\n            targetCanvasController.OnScreenContentPosition();\n\n    // Create a routine lasting `duration` seconds.\n    Routine animation = new Routine(duration);\n\n    // Execute the routine.\n    animation.Run(OnUpdate: (progress01) =\n\n    {\n        // The update action is called every frame for the routine's duration,\n        // passing in a progress01 value.\n\n        // Move the canvas controller's content from the start position\n        // to the end position, each frame.\n        targetCanvasController.ContentPosition = Vector3.LerpUnclamped(\n                    contentStartPosition,\n                    contentEndPosition,\n                    progress01);\n\n    }, OnComplete: () =\n\n    {\n        // The completion action is called after `duration` seconds.\n        transitionContext.CompleteTransition();\n    });\n}\n\n\n\n\nThe Content Transform\n\n\nTo move a canvas controller's content, the \nContentPosition\n (or \ncontent.localPosition\n) should be animated. Animating the canvas' transform itself will cause the canvas' \ncamera\n to move with it, which, although moving the canvas in world space, will have no effect on the canvas' screen position. \n\n\nSimilarly, to scale or rotate the canvas, you should also perform these operations on the canvas controller's \ncontent\n transform.\n\n\nUse The Helper Positioning Methods\n\n\nA canvas controller has several extension methods to help with positioning a canvas controller's content transform. These are used above to calculate the content's on/off-screen position.\n\n\n\n\nOnScreenContentPosition\n\n\nOffScreenBottomContentPosition\n\n\nOffScreenLeftContentPosition\n\n\nOffScreenTopContentPosition\n\n\n\n\nRoutine\n\n\nThe above example, as well as all default transition animators, use Canvas Flow's \nRoutine\n class to perform their animation. You may also use this class to easily create a \ncoroutine\n with a progress and completion callback, as above.\n\n\nComplete The Transition\n\n\nWhen your transition animator has completed its animation, you \nmust\n call \nCompleteTransition\n on the provided transition context. This tells Canvas Flow that the custom animation has been performed and to complete the transition.\n\n\n5. Use Your Custom Transition Animator\n\n\nOnce your custom transition animator is complete, it will be available to select in Unity's \nCreate\n menu. Please refer to \nUsing A Transition Animator\n to create an instance of your custom animator.", 
            "title": "Custom Transition Animators"
        }, 
        {
            "location": "/manual/transition-animators/custom-transition-animators/#custom-transition-animators", 
            "text": "You may create your own transition animators to implement a custom transition animation between canvas controllers. If following the steps below, your custom transition animator will be displayed in Unity's  Create  menu alongside the default transition animators, and will therefore also be compatible with storyboards.   Canvas Flow's default transition animators are included as .cs files. This means you can easily inspect their source code, which is recommended when creating your first custom transition animator. They can be found in the Project inspector at  Canvas Flow/Transition Animators/ .     See also:  Creating A Custom Transition Animator Using DOTween", 
            "title": "Custom Transition Animators"
        }, 
        {
            "location": "/manual/transition-animators/custom-transition-animators/#1-create-a-custom-transition-animator-script", 
            "text": "To begin creating a new transition animator, open Unity's  Create  menu - by either right-clicking in the Project window or selecting Assets in the menu bar - and selecting  Create/Canvas Flow/Custom Transition Animator . Enter a name and a directory for your new animator. This will generate a new transition animator script file at the specified location.  The generated script contains two methods for you to implement.   AnimateTransition()  AnimateTransitionForInitialCanvasController()", 
            "title": "1. Create A Custom Transition Animator Script"
        }, 
        {
            "location": "/manual/transition-animators/custom-transition-animators/#2-the-animate-transition-method", 
            "text": "As described in  Using A Transition Animator , an instance of your custom transition animator will be  vended  to Canvas Flow at runtime when the transition is about to be performed. Once this has occurred, Canvas Flow will tell the transition animator to perform the transition by calling its  AnimateTransition()  method. This is where you can perform your custom animation. Please see  Performing The Animation  for more details.  public override void AnimateTransition(CanvasControllerTransitionContext transitionContext)\n{\n    /*  \n      *  Do your custom animation with the source and destination content\n      *  here. For example:\n      *\n      *  CanvasController source = transitionContext.sourceCanvasController;\n      *  CanvasController destination = transitionContext.destinationCanvasController;\n      *\n      *  source.ContentPosition = ...\n      *  destination.ContentScale = ...\n      */\n\n    /*  \n     *  Call CompleteTransition() on the transition context once you have\n     *  performed your custom animation.\n     */\n    transitionContext.CompleteTransition();\n}   When your transition animator has completed its animation, you must call  CompleteTransition  on the provided transition context. This tells Canvas Flow that the custom animation has been performed and to complete the transition.", 
            "title": "2. The Animate Transition Method"
        }, 
        {
            "location": "/manual/transition-animators/custom-transition-animators/#3-the-animate-transition-for-initial-canvas-controller-method-optional", 
            "text": "The  AnimateTransitionForInitialCanvasController()  method is called on your transition animator when the transition is presenting or dismissing an initial canvas controller. An initial canvas controller is one with no presenter - i.e. it was the first canvas controller presented, perhaps from a storyboard entry transition or using  PresentInitialCanvasController . Therefore, you only need to implement this method if you intend to use your transition animator on transitions involving an initial canvas controller.  The only difference from the  AnimateTransition  method is that either the context's  sourceCanvasController  or  destinationCanvasController  will be null, depending on whether the transition context  isUpstream  - i.e. it is presenting/dismissing to  'nothing' .  The default transition animator, found in  Canvas Flow/Transition Animators/DefaultTransitionAnimator.cs  simply forwards this method to  AnimateTransition()  as it only ever operates on the presented canvas, like so:  public override void AnimateTransitionInvolvingInitialCanvasController(\n    CanvasControllerTransitionContext transitionContext)\n{\n    /*\n     *  We support transitions to and from the initial canvas controller by\n     *  default in our main AnimateTransition() method as we only operate on the\n     *  presented canvas controller, so we can just forward to that method.\n     */\n\n    AnimateTransition(transitionContext);\n}  Please see  Canvas Flow/Transition Animators/FadeToColorTransitionAnimator.cs  for an example of how different behaviour can be implemented when presenting/dismissing the initial canvas controller.", 
            "title": "3. The Animate Transition For Initial Canvas Controller Method (Optional)"
        }, 
        {
            "location": "/manual/transition-animators/custom-transition-animators/#4-performing-the-animation", 
            "text": "Below is an example of a complete  AnimateTransition  method, which animates the presented canvas controller from/to the bottom of the screen. This will serve as a basis for presenting several useful pointers when animating canvas controllers.   Note that you are free to animate the context's canvas controllers however you wish, including using external animation tools.   public override void AnimateTransition(CanvasControllerTransitionContext transitionContext)\n{\n    // Determine the target canvas controller - the one being presented or dismissed.\n    var targetCanvasController = (transitionContext.isUpstream) ?\n        transitionContext.sourceCanvasController :\n            transitionContext.destinationCanvasController;\n\n    // Determine the content's start position.\n    Vector3 contentStartPosition = (transitionContext.isUpstream) ?\n        targetCanvasController.OnScreenContentPosition() :\n            targetCanvasController.OffScreenBottomContentPosition();\n\n    // Determine the content's end position.\n    Vector3 contentEndPosition = (transitionContext.isUpstream) ?\n        targetCanvasController.OffScreenBottomContentPosition() :\n            targetCanvasController.OnScreenContentPosition();\n\n    // Create a routine lasting `duration` seconds.\n    Routine animation = new Routine(duration);\n\n    // Execute the routine.\n    animation.Run(OnUpdate: (progress01) = \n    {\n        // The update action is called every frame for the routine's duration,\n        // passing in a progress01 value.\n\n        // Move the canvas controller's content from the start position\n        // to the end position, each frame.\n        targetCanvasController.ContentPosition = Vector3.LerpUnclamped(\n                    contentStartPosition,\n                    contentEndPosition,\n                    progress01);\n\n    }, OnComplete: () = \n    {\n        // The completion action is called after `duration` seconds.\n        transitionContext.CompleteTransition();\n    });\n}", 
            "title": "4. Performing The Animation"
        }, 
        {
            "location": "/manual/transition-animators/custom-transition-animators/#the-content-transform", 
            "text": "To move a canvas controller's content, the  ContentPosition  (or  content.localPosition ) should be animated. Animating the canvas' transform itself will cause the canvas'  camera  to move with it, which, although moving the canvas in world space, will have no effect on the canvas' screen position.   Similarly, to scale or rotate the canvas, you should also perform these operations on the canvas controller's  content  transform.", 
            "title": "The Content Transform"
        }, 
        {
            "location": "/manual/transition-animators/custom-transition-animators/#use-the-helper-positioning-methods", 
            "text": "A canvas controller has several extension methods to help with positioning a canvas controller's content transform. These are used above to calculate the content's on/off-screen position.   OnScreenContentPosition  OffScreenBottomContentPosition  OffScreenLeftContentPosition  OffScreenTopContentPosition", 
            "title": "Use The Helper Positioning Methods"
        }, 
        {
            "location": "/manual/transition-animators/custom-transition-animators/#routine", 
            "text": "The above example, as well as all default transition animators, use Canvas Flow's  Routine  class to perform their animation. You may also use this class to easily create a  coroutine  with a progress and completion callback, as above.", 
            "title": "Routine"
        }, 
        {
            "location": "/manual/transition-animators/custom-transition-animators/#complete-the-transition", 
            "text": "When your transition animator has completed its animation, you  must  call  CompleteTransition  on the provided transition context. This tells Canvas Flow that the custom animation has been performed and to complete the transition.", 
            "title": "Complete The Transition"
        }, 
        {
            "location": "/manual/transition-animators/custom-transition-animators/#5-use-your-custom-transition-animator", 
            "text": "Once your custom transition animator is complete, it will be available to select in Unity's  Create  menu. Please refer to  Using A Transition Animator  to create an instance of your custom animator.", 
            "title": "5. Use Your Custom Transition Animator"
        }, 
        {
            "location": "/manual/miscellaneous/preferences/", 
            "text": "Preferences\n\n\nThe Canvas Flow preferences window is located in the Unity menu-bar at \nUnity, Preferences, Canvas Flow\n.\n\n\n\n    \n\n    \nThe Canvas Flow preferences window.\n\n\n\n\n\nStoryboards\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nStoryboard Scroll Direction\n\n\nSet the direction that storyboard content will move when scrolling.\n\n\n\n\n\n\n\n\nCanvas Controllers\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nAuto-Add Hooks On Scene Save\n\n\nWhen saving a Canvas Controller scene, Canvas Flow can automatically add storyboard hooks to the appropriate game objects. This will allow the objects to be \nhookable\n in the storyboard editor window. You may want to disable this if you are not working with storyboards.\n\n\n\n\n\n\nCanvas Scaler Reference Resolution\n\n\nSet the Canvas Scaler component's default reference resolution for new canvas controllers. This should be set to the resolution at which you are designing your UI. In addition to the Canvas Scaler, this will affect the proportions of the canvas controller in the storyboard editor.\n\n\n\n\n\n\n\n\nCanvas Controller Play-Mode Adjustments\n\n\nIt can be useful to run a canvas controller scene directly in the editor to preview changes quickly. Canvas Flow will make the following temporary adjustments when you enter play-mode from a canvas controller scene directly to make this process simpler. \nNote that these adjustments are only applied in the editor when entering play-mode from a canvas controller scene \ndirectly\n and are discarded once play-mode is exited.\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nCamera Clear Flags\n\n\nEnable this to set the canvas controller's Camera Clear Flags to 'SolidColor' when running the scene directly in the editor. By default, canvas controllers have their clear flags set to 'Depth'. This allows them to be transparent over your game's content. However, when running directly in the editor, your game's main camera will not be present to clear the screen.\n\n\n\n\n\n\nCreate EventSystem (If Necessary)\n\n\nEnable this to create an EventSystem (if one doesn't exist) when running the scene directly in the editor. By default, canvas controllers have no EventSystem, expecting one to be present elsewhere in your game. However, when running directly in the editor, your main EventSystem will not be present to accept input events.", 
            "title": "Preferences"
        }, 
        {
            "location": "/manual/miscellaneous/preferences/#preferences", 
            "text": "The Canvas Flow preferences window is located in the Unity menu-bar at  Unity, Preferences, Canvas Flow .  \n     \n     The Canvas Flow preferences window.", 
            "title": "Preferences"
        }, 
        {
            "location": "/manual/miscellaneous/preferences/#storyboards", 
            "text": "Name  Description      Storyboard Scroll Direction  Set the direction that storyboard content will move when scrolling.", 
            "title": "Storyboards"
        }, 
        {
            "location": "/manual/miscellaneous/preferences/#canvas-controllers", 
            "text": "Name  Description      Auto-Add Hooks On Scene Save  When saving a Canvas Controller scene, Canvas Flow can automatically add storyboard hooks to the appropriate game objects. This will allow the objects to be  hookable  in the storyboard editor window. You may want to disable this if you are not working with storyboards.    Canvas Scaler Reference Resolution  Set the Canvas Scaler component's default reference resolution for new canvas controllers. This should be set to the resolution at which you are designing your UI. In addition to the Canvas Scaler, this will affect the proportions of the canvas controller in the storyboard editor.", 
            "title": "Canvas Controllers"
        }, 
        {
            "location": "/manual/miscellaneous/preferences/#canvas-controller-play-mode-adjustments", 
            "text": "It can be useful to run a canvas controller scene directly in the editor to preview changes quickly. Canvas Flow will make the following temporary adjustments when you enter play-mode from a canvas controller scene directly to make this process simpler.  Note that these adjustments are only applied in the editor when entering play-mode from a canvas controller scene  directly  and are discarded once play-mode is exited.     Name  Description      Camera Clear Flags  Enable this to set the canvas controller's Camera Clear Flags to 'SolidColor' when running the scene directly in the editor. By default, canvas controllers have their clear flags set to 'Depth'. This allows them to be transparent over your game's content. However, when running directly in the editor, your game's main camera will not be present to clear the screen.    Create EventSystem (If Necessary)  Enable this to create an EventSystem (if one doesn't exist) when running the scene directly in the editor. By default, canvas controllers have no EventSystem, expecting one to be present elsewhere in your game. However, when running directly in the editor, your main EventSystem will not be present to accept input events.", 
            "title": "Canvas Controller Play-Mode Adjustments"
        }, 
        {
            "location": "/manual/tutorials/custom-storyboard-hook-toggle/custom-storyboard-hook-toggle/", 
            "text": "Creating a Custom Storyboard Hook For UI.Toggle\n\n\nIn this tutorial, we will add support for Toggles in storyboards, which will allow us to use a toggle in a storyboard to trigger a transition to another canvas controller. This is done by creating a \nCustom Storyboard Hook\n and should hopefully serve as a good example for creating custom storyboard hooks for other components, such as custom button types, too.\n\n\nTo illustrate, the transition shown below was configured in a storyboard and is being triggered by a \nUI.Toggle\n being switched on.\n\n\n\n    \n\n    \n\n\n\n\n\n\n\nCreate a new storyboard hook\n\n\nBegin by creating a new storyboard hook script. This is done by selecting \nCreate/Canvas Flow/Storyboard Hook\n in Unity's Create menu, found in the menu bar at \nAssets/Create\n or by right-clicking in the project window.\n\n\nThis will create a new script at the specified location, with three methods for us to implement.\n\n\nSpecify the Auto-Add type\n\n\nFirstly, let's implement the \nAutoAddComponentType\n method. We want our hook to be automatically added to any Toggles in our UI, so we can return the Toggle type here, like so:\n\n\npublic override System.Type AutoAddComponentType\n{\n    get\n    {\n        return typeof(UnityEngine.UI.Toggle);\n    }\n}\n\n\n\n\nImplement the Reset \n Connect methods\n\n\nWe now have two remaining methods left to implement - \nConnect\n and \nReset\n. In our \nConnect\n method, we need to connect the provided \ninvokeTransition\n action to our toggle so that when the toggle is switched on, the storyboard transition is triggered. Therefore, we first need a reference to our Toggle component. We can obtain this reference in the \nReset\n method and store it in a public field on our component (so it gets serialized by Unity), like so:\n\n\npublic UnityEngine.UI.Toggle toggle;\n\nprotected override void Reset()\n{\n    // Always call base.Reset() when overriding Reset() in a custom hook.\n    base.Reset();\n\n    toggle = GetComponent\nUnityEngine.UI.Toggle\n();\n}\n\n\n\n\nGreat, so now let's write the code to attach the transition callback to the toggle in the \nConnect\n method.\n\n\npublic override void Connect(System.Action\nStoryboardHook\n invokeTransition)\n{\n    toggle.onValueChanged.AddListener((isOn) =\n\n    {\n        if (isOn)\n        {\n            invokeTransition(this);\n        }\n    });\n}\n\n\n\n\nHere we attach a callback to our toggle's \nonValueChanged\n event. Notice here how we are observing the toggle's \nisOn\n property. If the toggle has been switched on, we will invoke the storyboard transition. Otherwise, if it has been switched off, we will ignore it.\n\n\nAnd that's it!\n\n\nUse it\n\n\nNow, if we add a toggle element in a canvas controller, like so\u2026\n\n\n\n\n\u2026 the toggle is available to use in a storyboard!\n\n\n\n\nWhich, when connected, causes our transition to be invoked when the toggle is switched on but not off, like so:\n\n\n\n    \n\n    \n\n\n\n\n\n\n\nThe above video uses the built-in Scale And Fade animator, as well as the \nKeepPresenterVisible\n setting on the transition.\n\n\n\n\nAnd that's all that is required to implement a custom hook for UI.Toggle!\n\n\nSource\n\n\nFor reference, the entire storyboard hook file we just created looks like this:\n\n\nusing P7.CanvasFlow;\n\npublic class ToggleStoryboardHook : StoryboardHook\n{\n    public UnityEngine.UI.Toggle toggle;\n\n    protected override void Reset()\n    {\n        // Always call base.Reset() when overriding Reset() in a custom hook.\n        base.Reset();\n\n        toggle = GetComponent\nUnityEngine.UI.Toggle\n();\n    }\n\n    public override System.Type AutoAddComponentType\n    {\n        get\n        {\n            return typeof(UnityEngine.UI.Toggle);\n        }\n    }\n\n    public override void Connect(System.Action\nStoryboardHook\n invokeTransition)\n    {\n        toggle.onValueChanged.AddListener((isOn) =\n\n        {\n            if (isOn)\n            {\n                invokeTransition(this);\n            }\n        });\n    }\n}", 
            "title": "Creating a Custom Storyboard Hook For UI.Toggle"
        }, 
        {
            "location": "/manual/tutorials/custom-storyboard-hook-toggle/custom-storyboard-hook-toggle/#creating-a-custom-storyboard-hook-for-uitoggle", 
            "text": "In this tutorial, we will add support for Toggles in storyboards, which will allow us to use a toggle in a storyboard to trigger a transition to another canvas controller. This is done by creating a  Custom Storyboard Hook  and should hopefully serve as a good example for creating custom storyboard hooks for other components, such as custom button types, too.  To illustrate, the transition shown below was configured in a storyboard and is being triggered by a  UI.Toggle  being switched on.", 
            "title": "Creating a Custom Storyboard Hook For UI.Toggle"
        }, 
        {
            "location": "/manual/tutorials/custom-storyboard-hook-toggle/custom-storyboard-hook-toggle/#create-a-new-storyboard-hook", 
            "text": "Begin by creating a new storyboard hook script. This is done by selecting  Create/Canvas Flow/Storyboard Hook  in Unity's Create menu, found in the menu bar at  Assets/Create  or by right-clicking in the project window.  This will create a new script at the specified location, with three methods for us to implement.", 
            "title": "Create a new storyboard hook"
        }, 
        {
            "location": "/manual/tutorials/custom-storyboard-hook-toggle/custom-storyboard-hook-toggle/#specify-the-auto-add-type", 
            "text": "Firstly, let's implement the  AutoAddComponentType  method. We want our hook to be automatically added to any Toggles in our UI, so we can return the Toggle type here, like so:  public override System.Type AutoAddComponentType\n{\n    get\n    {\n        return typeof(UnityEngine.UI.Toggle);\n    }\n}", 
            "title": "Specify the Auto-Add type"
        }, 
        {
            "location": "/manual/tutorials/custom-storyboard-hook-toggle/custom-storyboard-hook-toggle/#implement-the-reset-connect-methods", 
            "text": "We now have two remaining methods left to implement -  Connect  and  Reset . In our  Connect  method, we need to connect the provided  invokeTransition  action to our toggle so that when the toggle is switched on, the storyboard transition is triggered. Therefore, we first need a reference to our Toggle component. We can obtain this reference in the  Reset  method and store it in a public field on our component (so it gets serialized by Unity), like so:  public UnityEngine.UI.Toggle toggle;\n\nprotected override void Reset()\n{\n    // Always call base.Reset() when overriding Reset() in a custom hook.\n    base.Reset();\n\n    toggle = GetComponent UnityEngine.UI.Toggle ();\n}  Great, so now let's write the code to attach the transition callback to the toggle in the  Connect  method.  public override void Connect(System.Action StoryboardHook  invokeTransition)\n{\n    toggle.onValueChanged.AddListener((isOn) = \n    {\n        if (isOn)\n        {\n            invokeTransition(this);\n        }\n    });\n}  Here we attach a callback to our toggle's  onValueChanged  event. Notice here how we are observing the toggle's  isOn  property. If the toggle has been switched on, we will invoke the storyboard transition. Otherwise, if it has been switched off, we will ignore it.  And that's it!", 
            "title": "Implement the Reset &amp; Connect methods"
        }, 
        {
            "location": "/manual/tutorials/custom-storyboard-hook-toggle/custom-storyboard-hook-toggle/#use-it", 
            "text": "Now, if we add a toggle element in a canvas controller, like so\u2026   \u2026 the toggle is available to use in a storyboard!   Which, when connected, causes our transition to be invoked when the toggle is switched on but not off, like so:  \n     \n        The above video uses the built-in Scale And Fade animator, as well as the  KeepPresenterVisible  setting on the transition.   And that's all that is required to implement a custom hook for UI.Toggle!", 
            "title": "Use it"
        }, 
        {
            "location": "/manual/tutorials/custom-storyboard-hook-toggle/custom-storyboard-hook-toggle/#source", 
            "text": "For reference, the entire storyboard hook file we just created looks like this:  using P7.CanvasFlow;\n\npublic class ToggleStoryboardHook : StoryboardHook\n{\n    public UnityEngine.UI.Toggle toggle;\n\n    protected override void Reset()\n    {\n        // Always call base.Reset() when overriding Reset() in a custom hook.\n        base.Reset();\n\n        toggle = GetComponent UnityEngine.UI.Toggle ();\n    }\n\n    public override System.Type AutoAddComponentType\n    {\n        get\n        {\n            return typeof(UnityEngine.UI.Toggle);\n        }\n    }\n\n    public override void Connect(System.Action StoryboardHook  invokeTransition)\n    {\n        toggle.onValueChanged.AddListener((isOn) = \n        {\n            if (isOn)\n            {\n                invokeTransition(this);\n            }\n        });\n    }\n}", 
            "title": "Source"
        }, 
        {
            "location": "/manual/tutorials/custom-transition-animator-dotween/custom-transition-animator-dotween/", 
            "text": "Creating A Custom Transition Animator Using DOTween\n\n\nCanvas Flow allows you to fully customize the animations between canvas controllers, as outlined in \nCustom Transition Animators\n. The reference documentation, as well as the included built-in animators, all use the \nRoutine\n class to animate values over time, such as the position of the canvas controller's content. Whilst you are free to also use this class and follow this pattern, some people may feel more comfortable using the popular \nDOTween\n animation framework. Therefore, this tutorial will show you how you can easily use DOTween in a custom transition animator to do your animation. Below are the two example transition animations we will create.\n\n\n\n\n\n\n\n\nSlide\n\n\nSpin\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFirstly, if you haven't done so already, make sure DOTween is imported into your project in the usual way.\n\n\nCreate a new custom transition animator\n\n\nBegin by creating a new custom transition animator. This is done by selecting \nCreate/Canvas Flow/Custom Transition Animator\n in Unity's Create menu, found in the menu bar at \nAssets/Create\n or by right-clicking in the project window.\n\n\nThis will create a new script at the specified location, with two methods for us to implement.\n\n\nImplement the AnimationTransition method\n\n\nAs documented in the manual, we perform our animation in the \nAnimateTransition\n method. This method is passed a \ntransition context\n, which provides us with the canvas controllers involved in the transition, as well as some other transitional information.\n\n\npublic override void AnimateTransition(CanvasControllerTransitionContext transitionContext)\n{\n    // Perform our animation.\n}\n\n\n\n\nDetermine the target canvas controller\n\n\nSo firstly, let's get a reference to the canvas controller we want to animate. We get this from the transition context's \nsource\n and \ndestination\n properties - but which one? As shown in the videos above, we are going to animate just the present\ned\n canvas controller (the yellow one). This canvas controller will be the \ndestination\n of a presentation transition (downstream), but the \nsource\n of a dismissal transition (upstream), as shown below:\n\n\n\n\n\n\n\n\nAction\n\n\nDirection\n\n\nVisual Description (Presented Highlighted)\n\n\n\n\n\n\n\n\n\n\nPresent\n\n\nDownstream\n\n\nsource ---\n \ndestination\n\n\n\n\n\n\nDismiss\n\n\nUpstream\n\n\ndestination \n---- \nsource\n\n\n\n\n\n\n\n\nSo, we can get our \ntarget\n canvas controller based on the direction of the transition, like so:\n\n\nCanvasController targetCanvasController = (transitionContext.isUpstream) ?\n    transitionContext.sourceCanvasController :\n        transitionContext.destinationCanvasController;\n\n\n\n\nDetermine the animation's start \n end positions\n\n\nNow let's animate the target canvas controller. In this first example, we will simply slide the canvas controller's content up from the bottom of the screen. We will therefore need to calculate the start and end positions for the content. Again this will vary based upon the direction of the transition - if it is being presented, we want the content to start \noff-screen-bottom\n and move \non-screen\n; if it is being dismissed we want to start \non-screen\n and move \noff-screen-bottom\n. We can do this like so:\n\n\nVector3 contentStartPosition = (transitionContext.isUpstream) ?\n    targetCanvasController.OnScreenContentPosition() :\n        targetCanvasController.OffScreenBottomContentPosition();\n\nVector3 contentEndPosition = (transitionContext.isUpstream) ?\n    targetCanvasController.OffScreenBottomContentPosition() :\n        targetCanvasController.OnScreenContentPosition();\n\n\n\n\nDOTween\n\n\nAnd now to actually perform the animation with DOTween. We first set our content's position to the start position and then use DOTween's \nTo\n method to animate the content over time. Notice how we specify a completion handler on the last line, which calls \nCompleteTransition\n. As specified in the documentation, you must call \nCompleteTransition\n on the provided transition context once your animation has finished. This is easily done using a DOTween completion handler.\n\n\n// Set the content position to the start position.\ntargetCanvasController.ContentPosition = contentStartPosition;\n\n// Tween using DOTween.\nDOTween.To(() =\n\n            targetCanvasController.ContentPosition,\n            x =\n targetCanvasController.ContentPosition = x,\n            contentEndPosition,\n            duration).OnComplete(transitionContext.CompleteTransition);\n\n\n\n\n\n\nThe \nduration\n property above is specified as a public field on the script. This will allow it to be adjusted in the inspector later, without editing your transition animator's code.\n\n\n\n\nImplement AnimateTransitionForInitialCanvasController to support initial transitions\n\n\nIn an initial transition, the present\ner\n - the canvas controller presenting or being dismissed to - may be null. As we only ever operate on the present\ned\n canvas controller, we can just forward to our \nAnimateTransition\n implementation, like so:\n\n\npublic override void AnimateTransitionForInitialCanvasController(\n    CanvasControllerTransitionContext transitionContext)\n{\n    AnimateTransition(transitionContext);\n}\n\n\n\n\nAnd that's it! We can use our new animator by creating a new instance of it (\nCreate/Canvas Flow/Your-Transition-Animator-Instance\n), as described in \nUsing A Transition Animator\n.\n\n\n\n\nWhich gives us a custom transition animated with DOTween:\n\n\n\n\n\nMultiple DOTweens\n\n\nLet's create something a little more custom-looking and create a spin and scale up animation. Using the same code as above to determine our target canvas controller, we can now create two DOTweens - one to rotate the content, and one to scale it up.\n\n\n// Determine the content's start and end scale.\nVector3 contentStartScale = (transitionContext.isUpstream) ?\n    Vector3.one : Vector3.zero;\nVector3 contentEndScale = (transitionContext.isUpstream) ?\n    Vector3.zero : Vector3.one;\n\n// Tween the scale.\ntargetCanvasController.ContentScale = contentStartScale;\nDOTween.To(() =\n\n            targetCanvasController.ContentScale,\n            x =\n targetCanvasController.ContentScale = x,\n            contentEndScale,\n            duration).OnComplete(transitionContext.CompleteTransition);\n\n// Determine the content's start and end rotation.\nfloat rotation = 180f;\nVector3 contentStartRotation = (transitionContext.isUpstream) ?\n    new Vector3(0f, 0f, 0f) : new Vector3(0f, 0f, rotation);\nVector3 contentEndRotation = (transitionContext.isUpstream) ?\n    new Vector3(0f, 0f, rotation) : new Vector3(0f, 0f, 0f);\n\n// Tween the rotation\ntargetCanvasController.content.localRotation = Quaternion.Euler(contentStartRotation);\nDOTween.To(() =\n\n            targetCanvasController.content.localRotation,\n            x =\n targetCanvasController.content.localRotation = x,\n            contentEndRotation,\n            duration);\n\n\n\n\n\n\nNotice how we only specify the completion handler once on the scale tween - we only need to call \nCompleteTransition\n once when the animation has finished.\n\n\n\n\nWhich gives us the following:\n\n\n\n\n\nSlide Transition Animator Source\n\n\nFor reference, the complete slide transition animator we just created looks like this:\n\n\nusing DG.Tweening;\nusing P7.CanvasFlow;\nusing UnityEngine;\n\n// Easily create instances of this transition animator in the Unity menu.\n[CreateAssetMenu(fileName = \nDOTweenExampleTransitionAnimator\n,\n                 menuName = \nCanvas Flow/DOTweenExampleTransitionAnimator Instance\n,\n                 order = 500)]\n\npublic class DOTweenExampleTransitionAnimator : CanvasControllerTransitioningAnimator,\n    ICanvasControllerTransitioningAnimator\n{\n    public float duration = 0.4f;\n\n    public override void AnimateTransition(CanvasControllerTransitionContext transitionContext)\n    {\n        // Determine the target canvas controller - the one being presented or dismissed.\n        CanvasController targetCanvasController = (transitionContext.isUpstream) ?\n            transitionContext.sourceCanvasController :\n                transitionContext.destinationCanvasController;\n\n        // Determine the content's start and end positions.\n        Vector3 contentStartPosition = (transitionContext.isUpstream) ?\n            targetCanvasController.OnScreenContentPosition() :\n                targetCanvasController.OffScreenBottomContentPosition();\n\n        Vector3 contentEndPosition = (transitionContext.isUpstream) ?\n            targetCanvasController.OffScreenBottomContentPosition() :\n                targetCanvasController.OnScreenContentPosition();\n\n        // Set the content position to the start position.\n        targetCanvasController.ContentPosition = contentStartPosition;\n\n        // Tween using DOTween.\n        DOTween.To(() =\n\n                    targetCanvasController.ContentPosition,\n                    x =\n targetCanvasController.ContentPosition = x,\n                    contentEndPosition,\n                    duration).OnComplete(transitionContext.CompleteTransition);\n    }\n\n    public override void AnimateTransitionForInitialCanvasController(\n        CanvasControllerTransitionContext transitionContext)\n    {\n        AnimateTransition(transitionContext);\n    }\n}\n\n\n\n\nSpin Transition Animator Source\n\n\nFor reference, the complete spin transition animator we just created looks like this:\n\n\nusing DG.Tweening;\nusing P7.CanvasFlow;\nusing UnityEngine;\n\n// Easily create instances of this transition animator in the Unity menu.\n[CreateAssetMenu(fileName = \nDOTweenExampleTransitionAnimator\n,\n                 menuName = \nCanvas Flow/DOTweenExampleTransitionAnimator Instance\n,\n                 order = 500)]\n\npublic class DOTweenExampleTransitionAnimator : CanvasControllerTransitioningAnimator,\n    ICanvasControllerTransitioningAnimator\n{\n    public float duration = 0.4f;\n\n    public override void AnimateTransition(CanvasControllerTransitionContext transitionContext)\n    {\n        // Determine the target canvas controller - the one being presented or dismissed.\n        CanvasController targetCanvasController = (transitionContext.isUpstream) ?\n            transitionContext.sourceCanvasController :\n                transitionContext.destinationCanvasController;\n\n        // Determine the content's start and end scale.\n        Vector3 contentStartScale = (transitionContext.isUpstream) ?\n            Vector3.one : Vector3.zero;\n        Vector3 contentEndScale = (transitionContext.isUpstream) ?\n            Vector3.zero : Vector3.one;\n\n        // Tween the scale.\n        targetCanvasController.ContentScale = contentStartScale;\n        DOTween.To(() =\n\n                   targetCanvasController.ContentScale,\n                   x =\n targetCanvasController.ContentScale = x,\n                   contentEndScale,\n                   duration).OnComplete(transitionContext.CompleteTransition);\n\n        // Determine the content's start and end rotation.\n        float rotation = 180f;\n        Vector3 contentStartRotation = (transitionContext.isUpstream) ?\n            new Vector3(0f, 0f, 0f) : new Vector3(0f, 0f, rotation);\n        Vector3 contentEndRotation = (transitionContext.isUpstream) ?\n            new Vector3(0f, 0f, rotation) : new Vector3(0f, 0f, 0f);\n\n        // Tween the rotation\n        targetCanvasController.content.localRotation = Quaternion.Euler(contentStartRotation);\n        DOTween.To(() =\n\n                   targetCanvasController.content.localRotation,\n                   x =\n targetCanvasController.content.localRotation = x,\n                   contentEndRotation,\n                   duration);\n    }\n\n    public override void AnimateTransitionForInitialCanvasController(\n        CanvasControllerTransitionContext transitionContext)\n    {\n        AnimateTransition(transitionContext);\n    }\n}", 
            "title": "Creating A Custom Transition Animator Using DOTween"
        }, 
        {
            "location": "/manual/tutorials/custom-transition-animator-dotween/custom-transition-animator-dotween/#creating-a-custom-transition-animator-using-dotween", 
            "text": "Canvas Flow allows you to fully customize the animations between canvas controllers, as outlined in  Custom Transition Animators . The reference documentation, as well as the included built-in animators, all use the  Routine  class to animate values over time, such as the position of the canvas controller's content. Whilst you are free to also use this class and follow this pattern, some people may feel more comfortable using the popular  DOTween  animation framework. Therefore, this tutorial will show you how you can easily use DOTween in a custom transition animator to do your animation. Below are the two example transition animations we will create.     Slide  Spin            Firstly, if you haven't done so already, make sure DOTween is imported into your project in the usual way.", 
            "title": "Creating A Custom Transition Animator Using DOTween"
        }, 
        {
            "location": "/manual/tutorials/custom-transition-animator-dotween/custom-transition-animator-dotween/#create-a-new-custom-transition-animator", 
            "text": "Begin by creating a new custom transition animator. This is done by selecting  Create/Canvas Flow/Custom Transition Animator  in Unity's Create menu, found in the menu bar at  Assets/Create  or by right-clicking in the project window.  This will create a new script at the specified location, with two methods for us to implement.", 
            "title": "Create a new custom transition animator"
        }, 
        {
            "location": "/manual/tutorials/custom-transition-animator-dotween/custom-transition-animator-dotween/#implement-the-animationtransition-method", 
            "text": "As documented in the manual, we perform our animation in the  AnimateTransition  method. This method is passed a  transition context , which provides us with the canvas controllers involved in the transition, as well as some other transitional information.  public override void AnimateTransition(CanvasControllerTransitionContext transitionContext)\n{\n    // Perform our animation.\n}", 
            "title": "Implement the AnimationTransition method"
        }, 
        {
            "location": "/manual/tutorials/custom-transition-animator-dotween/custom-transition-animator-dotween/#determine-the-target-canvas-controller", 
            "text": "So firstly, let's get a reference to the canvas controller we want to animate. We get this from the transition context's  source  and  destination  properties - but which one? As shown in the videos above, we are going to animate just the present ed  canvas controller (the yellow one). This canvas controller will be the  destination  of a presentation transition (downstream), but the  source  of a dismissal transition (upstream), as shown below:     Action  Direction  Visual Description (Presented Highlighted)      Present  Downstream  source ---   destination    Dismiss  Upstream  destination  ----  source     So, we can get our  target  canvas controller based on the direction of the transition, like so:  CanvasController targetCanvasController = (transitionContext.isUpstream) ?\n    transitionContext.sourceCanvasController :\n        transitionContext.destinationCanvasController;", 
            "title": "Determine the target canvas controller"
        }, 
        {
            "location": "/manual/tutorials/custom-transition-animator-dotween/custom-transition-animator-dotween/#determine-the-animations-start-end-positions", 
            "text": "Now let's animate the target canvas controller. In this first example, we will simply slide the canvas controller's content up from the bottom of the screen. We will therefore need to calculate the start and end positions for the content. Again this will vary based upon the direction of the transition - if it is being presented, we want the content to start  off-screen-bottom  and move  on-screen ; if it is being dismissed we want to start  on-screen  and move  off-screen-bottom . We can do this like so:  Vector3 contentStartPosition = (transitionContext.isUpstream) ?\n    targetCanvasController.OnScreenContentPosition() :\n        targetCanvasController.OffScreenBottomContentPosition();\n\nVector3 contentEndPosition = (transitionContext.isUpstream) ?\n    targetCanvasController.OffScreenBottomContentPosition() :\n        targetCanvasController.OnScreenContentPosition();", 
            "title": "Determine the animation's start &amp; end positions"
        }, 
        {
            "location": "/manual/tutorials/custom-transition-animator-dotween/custom-transition-animator-dotween/#dotween", 
            "text": "And now to actually perform the animation with DOTween. We first set our content's position to the start position and then use DOTween's  To  method to animate the content over time. Notice how we specify a completion handler on the last line, which calls  CompleteTransition . As specified in the documentation, you must call  CompleteTransition  on the provided transition context once your animation has finished. This is easily done using a DOTween completion handler.  // Set the content position to the start position.\ntargetCanvasController.ContentPosition = contentStartPosition;\n\n// Tween using DOTween.\nDOTween.To(() = \n            targetCanvasController.ContentPosition,\n            x =  targetCanvasController.ContentPosition = x,\n            contentEndPosition,\n            duration).OnComplete(transitionContext.CompleteTransition);   The  duration  property above is specified as a public field on the script. This will allow it to be adjusted in the inspector later, without editing your transition animator's code.", 
            "title": "DOTween"
        }, 
        {
            "location": "/manual/tutorials/custom-transition-animator-dotween/custom-transition-animator-dotween/#implement-animatetransitionforinitialcanvascontroller-to-support-initial-transitions", 
            "text": "In an initial transition, the present er  - the canvas controller presenting or being dismissed to - may be null. As we only ever operate on the present ed  canvas controller, we can just forward to our  AnimateTransition  implementation, like so:  public override void AnimateTransitionForInitialCanvasController(\n    CanvasControllerTransitionContext transitionContext)\n{\n    AnimateTransition(transitionContext);\n}  And that's it! We can use our new animator by creating a new instance of it ( Create/Canvas Flow/Your-Transition-Animator-Instance ), as described in  Using A Transition Animator .   Which gives us a custom transition animated with DOTween:", 
            "title": "Implement AnimateTransitionForInitialCanvasController to support initial transitions"
        }, 
        {
            "location": "/manual/tutorials/custom-transition-animator-dotween/custom-transition-animator-dotween/#multiple-dotweens", 
            "text": "Let's create something a little more custom-looking and create a spin and scale up animation. Using the same code as above to determine our target canvas controller, we can now create two DOTweens - one to rotate the content, and one to scale it up.  // Determine the content's start and end scale.\nVector3 contentStartScale = (transitionContext.isUpstream) ?\n    Vector3.one : Vector3.zero;\nVector3 contentEndScale = (transitionContext.isUpstream) ?\n    Vector3.zero : Vector3.one;\n\n// Tween the scale.\ntargetCanvasController.ContentScale = contentStartScale;\nDOTween.To(() = \n            targetCanvasController.ContentScale,\n            x =  targetCanvasController.ContentScale = x,\n            contentEndScale,\n            duration).OnComplete(transitionContext.CompleteTransition);\n\n// Determine the content's start and end rotation.\nfloat rotation = 180f;\nVector3 contentStartRotation = (transitionContext.isUpstream) ?\n    new Vector3(0f, 0f, 0f) : new Vector3(0f, 0f, rotation);\nVector3 contentEndRotation = (transitionContext.isUpstream) ?\n    new Vector3(0f, 0f, rotation) : new Vector3(0f, 0f, 0f);\n\n// Tween the rotation\ntargetCanvasController.content.localRotation = Quaternion.Euler(contentStartRotation);\nDOTween.To(() = \n            targetCanvasController.content.localRotation,\n            x =  targetCanvasController.content.localRotation = x,\n            contentEndRotation,\n            duration);   Notice how we only specify the completion handler once on the scale tween - we only need to call  CompleteTransition  once when the animation has finished.   Which gives us the following:", 
            "title": "Multiple DOTweens"
        }, 
        {
            "location": "/manual/tutorials/custom-transition-animator-dotween/custom-transition-animator-dotween/#slide-transition-animator-source", 
            "text": "For reference, the complete slide transition animator we just created looks like this:  using DG.Tweening;\nusing P7.CanvasFlow;\nusing UnityEngine;\n\n// Easily create instances of this transition animator in the Unity menu.\n[CreateAssetMenu(fileName =  DOTweenExampleTransitionAnimator ,\n                 menuName =  Canvas Flow/DOTweenExampleTransitionAnimator Instance ,\n                 order = 500)]\n\npublic class DOTweenExampleTransitionAnimator : CanvasControllerTransitioningAnimator,\n    ICanvasControllerTransitioningAnimator\n{\n    public float duration = 0.4f;\n\n    public override void AnimateTransition(CanvasControllerTransitionContext transitionContext)\n    {\n        // Determine the target canvas controller - the one being presented or dismissed.\n        CanvasController targetCanvasController = (transitionContext.isUpstream) ?\n            transitionContext.sourceCanvasController :\n                transitionContext.destinationCanvasController;\n\n        // Determine the content's start and end positions.\n        Vector3 contentStartPosition = (transitionContext.isUpstream) ?\n            targetCanvasController.OnScreenContentPosition() :\n                targetCanvasController.OffScreenBottomContentPosition();\n\n        Vector3 contentEndPosition = (transitionContext.isUpstream) ?\n            targetCanvasController.OffScreenBottomContentPosition() :\n                targetCanvasController.OnScreenContentPosition();\n\n        // Set the content position to the start position.\n        targetCanvasController.ContentPosition = contentStartPosition;\n\n        // Tween using DOTween.\n        DOTween.To(() = \n                    targetCanvasController.ContentPosition,\n                    x =  targetCanvasController.ContentPosition = x,\n                    contentEndPosition,\n                    duration).OnComplete(transitionContext.CompleteTransition);\n    }\n\n    public override void AnimateTransitionForInitialCanvasController(\n        CanvasControllerTransitionContext transitionContext)\n    {\n        AnimateTransition(transitionContext);\n    }\n}", 
            "title": "Slide Transition Animator Source"
        }, 
        {
            "location": "/manual/tutorials/custom-transition-animator-dotween/custom-transition-animator-dotween/#spin-transition-animator-source", 
            "text": "For reference, the complete spin transition animator we just created looks like this:  using DG.Tweening;\nusing P7.CanvasFlow;\nusing UnityEngine;\n\n// Easily create instances of this transition animator in the Unity menu.\n[CreateAssetMenu(fileName =  DOTweenExampleTransitionAnimator ,\n                 menuName =  Canvas Flow/DOTweenExampleTransitionAnimator Instance ,\n                 order = 500)]\n\npublic class DOTweenExampleTransitionAnimator : CanvasControllerTransitioningAnimator,\n    ICanvasControllerTransitioningAnimator\n{\n    public float duration = 0.4f;\n\n    public override void AnimateTransition(CanvasControllerTransitionContext transitionContext)\n    {\n        // Determine the target canvas controller - the one being presented or dismissed.\n        CanvasController targetCanvasController = (transitionContext.isUpstream) ?\n            transitionContext.sourceCanvasController :\n                transitionContext.destinationCanvasController;\n\n        // Determine the content's start and end scale.\n        Vector3 contentStartScale = (transitionContext.isUpstream) ?\n            Vector3.one : Vector3.zero;\n        Vector3 contentEndScale = (transitionContext.isUpstream) ?\n            Vector3.zero : Vector3.one;\n\n        // Tween the scale.\n        targetCanvasController.ContentScale = contentStartScale;\n        DOTween.To(() = \n                   targetCanvasController.ContentScale,\n                   x =  targetCanvasController.ContentScale = x,\n                   contentEndScale,\n                   duration).OnComplete(transitionContext.CompleteTransition);\n\n        // Determine the content's start and end rotation.\n        float rotation = 180f;\n        Vector3 contentStartRotation = (transitionContext.isUpstream) ?\n            new Vector3(0f, 0f, 0f) : new Vector3(0f, 0f, rotation);\n        Vector3 contentEndRotation = (transitionContext.isUpstream) ?\n            new Vector3(0f, 0f, rotation) : new Vector3(0f, 0f, 0f);\n\n        // Tween the rotation\n        targetCanvasController.content.localRotation = Quaternion.Euler(contentStartRotation);\n        DOTween.To(() = \n                   targetCanvasController.content.localRotation,\n                   x =  targetCanvasController.content.localRotation = x,\n                   contentEndRotation,\n                   duration);\n    }\n\n    public override void AnimateTransitionForInitialCanvasController(\n        CanvasControllerTransitionContext transitionContext)\n    {\n        AnimateTransition(transitionContext);\n    }\n}", 
            "title": "Spin Transition Animator Source"
        }, 
        {
            "location": "/scripting-reference/contents/", 
            "text": "Contents\n\n\nCanvas Controllers\n\n\n\n\nCanvasController\n\n\nCanvasController Extensions\n\n\nCanvasControllerPresentationMode\n\n\nCanvasControllerTransitionContext\n\n\nCanvasControllerTransitioningAnimator\n\n\nICanvasControllerTransitioningAnimator\n\n\nICanvasControllerTransitioningAnimatorVendor\n\n\n\n\nStoryboards\n\n\n\n\nStoryboard\n\n\nStoryboardData\n\n\nStoryboardHook\n\n\nStoryboardTransition\n\n\nStoryboardTransitionDirection\n\n\nStoryboardTransitionEvent\n\n\n\n\nExtensions \n Convenience\n\n\n\n\nRoutine\n\n\nDynamicObjectExtensions\n\n\nRectTransformExtensions", 
            "title": "Contents"
        }, 
        {
            "location": "/scripting-reference/contents/#contents", 
            "text": "", 
            "title": "Contents"
        }, 
        {
            "location": "/scripting-reference/contents/#canvas-controllers", 
            "text": "CanvasController  CanvasController Extensions  CanvasControllerPresentationMode  CanvasControllerTransitionContext  CanvasControllerTransitioningAnimator  ICanvasControllerTransitioningAnimator  ICanvasControllerTransitioningAnimatorVendor", 
            "title": "Canvas Controllers"
        }, 
        {
            "location": "/scripting-reference/contents/#storyboards", 
            "text": "Storyboard  StoryboardData  StoryboardHook  StoryboardTransition  StoryboardTransitionDirection  StoryboardTransitionEvent", 
            "title": "Storyboards"
        }, 
        {
            "location": "/scripting-reference/contents/#extensions-convenience", 
            "text": "Routine  DynamicObjectExtensions  RectTransformExtensions", 
            "title": "Extensions &amp; Convenience"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/", 
            "text": "CanvasController\n\n\npublic class CanvasController : MonoBehaviour, IStoryboardable;\n\n\nDescription\n\n\nA canvas controller represents a single screen in your user interface. Canvas controllers can present and dismiss other canvas controllers, or screens, allowing you to easily build a user interface flow, presenting and dismissing screens as required. A canvas controller automatically manages the presentation hierarchy, as well as loading and unloading itself as it is presented or dismissed. \n\n\nCanvas controllers should be created with Unity's \nCreate\n menu - found by either right-clicking in the Project window or selecting Assets in the menu bar - and selecting \nCreate/Canvas Flow/Canvas Controller\n. \n\n\nPresent and dismiss canvas controllers with the \nPresentCanvasController\n and \nDismissCanvasController\n methods. To present or dismiss an initial canvas controller use the \nPresentInitialCanvasController\n and \n DismissAllCanvasControllers\n methods. \n\n\nA canvas controller can override its appearance methods to be notified of the appearance events \nCanvasWillAppear\n, \nCanvasDidAppear\n, \nCanvasWillDisappear\n, and \nCanvasDidDisappear\n. \n\n\nCanvas controllers can be used with storyboards to visually define the presentation flow. When working with storyboards, data can be passed between canvas controllers by overriding the \nPrepareForStoryboardTransition\n method. Additionally, storyboard transitions can be triggered from a canvas controller using the \nPerformTransitionWithIdentifier\n method. \n\n\nCanvas controllers can be presented in world space by either setting a storyboard's \nStoryboardPresentationSpace\n to \nWorldSpace\n, or by passing a \nCanvasControllerWorldSpaceContainer\n to \nPresentInitialCanvasController\n. Canvas controllers presented from a world space canvas controller will also be presented in world space and contained within the presenter's container. \n\n\n\n\n\n\n\n\nProperties\n\n\n\n\n\n\n\n\n\n\n\n\nbackgroundImage\n\n\nThe canvas controller's background image.\n\n\n\n\n\n\ncamera\n\n\nThe canvas controller's camera.\n\n\n\n\n\n\ncanvas\n\n\nThe canvas controller's main canvas.\n\n\n\n\n\n\nChildCanvasControllers\n\n\nGet the canvas controller's children.\n\n\n\n\n\n\ncontent\n\n\nThe canvas controller's content transform.\n\n\n\n\n\n\nContentActive\n\n\nEnable/disable the canvas contoller's content. This is equivalent to calling \ncontent.gameObject.activeSelf\n and \ncontent.gameObject.SetActive\n.\n\n\n\n\n\n\nContentPosition\n\n\nGet/set the position of the canvas controller's content. This is equivalent to calling \ncontent.localPosition\n.\n\n\n\n\n\n\nContentScale\n\n\nGet/set the scale of the canvas controller's content. This is equivalent to calling \ncontent.localScale\n.\n\n\n\n\n\n\nHidden\n\n\nHide/show the canvas controller. This will enable/disable both the canvas controller's \ncamera\n and \ncontent\n. Note that if the canvas controller is container within a \nCanvasControllerWorldSpaceContainer\n, only its content will be affected.\n\n\n\n\n\n\nIsBeingDismissed\n\n\nIs the canvas controller currently being dismissed?\n\n\n\n\n\n\nIsBeingPresented\n\n\nIs the canvas controller currently being presented?\n\n\n\n\n\n\nIsEmbeddedInWorldSpaceContainer\n\n\nIs the canvas controller embedded in a world space container?\n\n\n\n\n\n\nIsTransitioning\n\n\nIs the canvas controller currently transitioning?\n\n\n\n\n\n\npresentationMode\n\n\nThe canvas controller's presentation mode.\n\n\n\n\n\n\nPresentedCanvasController\n\n\nGet the presented canvas controller.\n\n\n\n\n\n\nPresentingCanvasController\n\n\nGet the presenting canvas controller - the canvas controller's presenter.\n\n\n\n\n\n\nscene\n\n\nThe canvas controller's scene.\n\n\n\n\n\n\nStoryboard\n\n\nGet the canvas controller's storyboard.\n\n\n\n\n\n\ntransitioningAnimatorVendor\n\n\nThe canvas controller's 'transitioning animator' vendor.\n\n\n\n\n\n\nWorldSpaceContainer\n\n\nGet the canvas controller's world space container.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMethods\n\n\n\n\n\n\n\n\n\n\n\n\nAddChildCanvasController\n\n\nLoad the specified canvas controller and add it as a child.\n\n\n\n\n\n\nAddChildCanvasController\nT\n\n\nLoad the specified canvas controller and add it as a child.\n\n\n\n\n\n\nAddChildCanvasController\nT\n\n\nLoad the specified canvas controller and add it as a child.\n\n\n\n\n\n\nAwake\n\n\nAwake is called when the canvas controller is loaded.\n\n\n\n\n\n\nCanvasDidAppear\n\n\nOverride this method in your canvas controller to be notified just after the canvas has transitioned on screen. This could be because it has just been presented or has just dismissed its \nPresentedCanvasController\n.\n\n\n\n\n\n\nCanvasDidDisappear\n\n\nOverride this method in your canvas controller to be notified just after the canvas has transitioned off screen. This could be because it has just been dismissed or has just presented a canvas controller.\n\n\n\n\n\n\nCanvasWillAppear\n\n\nOverride this method in your canvas controller to be notified just before the canvas is about to transition on screen. This could be because it is about to be presented or about to dismiss its \nPresentedCanvasController\n.\n\n\n\n\n\n\nCanvasWillDisappear\n\n\nOverride this method in your canvas controller to be notified just before the canvas is about to transition off screen. This could be because it is about to be dismissed or about to present a canvas controller.\n\n\n\n\n\n\nDismissAllCanvasControllers\n\n\nDismisses all canvas controllers in the current hierarchy.\n\n\n\n\n\n\nDismissCanvasController\n\n\nDismiss a canvas controller.\n\n\n\n\n\n\nPerformTransitionWithIdentifier\n\n\nPerform the storyboard transition with this identifier.\n\n\n\n\n\n\nPrepareForStoryboardTransition\n\n\nOverride this method to be notified when the canvas controller is about to be involved in a storyboard transition.\n\n\n\n\n\n\nPresentCanvasController\n\n\nPresent a canvas controller, specifying a name.\n\n\n\n\n\n\nPresentCanvasController\nT\n\n\nPresent a canvas controller, specifying a type.\n\n\n\n\n\n\nPresentCanvasController\nT\n\n\nPresent a canvas controller, specifying a type and a name.\n\n\n\n\n\n\nPresentInitialCanvasController\n\n\nPresent an initial canvas controller, specifying a name.\n\n\n\n\n\n\nPresentInitialCanvasController\nT\n\n\nPresent an initial canvas controller, specifying a type.\n\n\n\n\n\n\nPresentInitialCanvasController\nT\n\n\nPresent an initial canvas controller, specifying a type and a name.\n\n\n\n\n\n\nRemoveAndUnloadChildCanvasController\n\n\nRemove and unload a child canvas controller.\n\n\n\n\n\n\nStart\n\n\nStart is called on the frame when the canvas controller is loaded, after \nAwake\n.\n\n\n\n\n\n\n\n\n\n\nbackgroundImage\n\n\npublic Image backgroundImage;\n\n\nDescription\n\n\nThe canvas controller's background image. \n\n\n\n\ncamera\n\n\npublic new Camera camera;\n\n\nDescription\n\n\nThe canvas controller's camera. \n\n\n\n\ncanvas\n\n\npublic Canvas canvas;\n\n\nDescription\n\n\nThe canvas controller's main canvas. \n\n\n\n\nChildCanvasControllers\n\n\npublic ReadOnlyCollection\nCanvasController\n ChildCanvasControllers;\n\n\nDescription\n\n\nGet the canvas controller's children. \n\n\nUse the \nAddChildCanvasController\n and \nRemoveAndUnloadChildCanvasController\n methods to add and remove child canvas controllers. \n\n\n\n\ncontent\n\n\npublic RectTransform content;\n\n\nDescription\n\n\nThe canvas controller's content transform. \n\n\nAll content should be placed under the content transform. \n\n\n\n\nContentActive\n\n\npublic bool ContentActive;\n\n\nDescription\n\n\nEnable/disable the canvas contoller's content. This is equivalent to calling \ncontent.gameObject.activeSelf\n and \ncontent.gameObject.SetActive\n. \n\n\nIf you intend to hide the canvas controller completely, use the \nHidden\n property as this will disable the canvas' camera as well as the content. \n\n\n\n\nContentPosition\n\n\npublic Vector3 ContentPosition;\n\n\nDescription\n\n\nGet/set the position of the canvas controller's content. This is equivalent to calling \ncontent.localPosition\n. \n\n\n\n\nContentScale\n\n\npublic Vector3 ContentScale;\n\n\nDescription\n\n\nGet/set the scale of the canvas controller's content. This is equivalent to calling \ncontent.localScale\n. \n\n\n\n\nHidden\n\n\npublic bool Hidden;\n\n\nDescription\n\n\nHide/show the canvas controller. This will enable/disable both the canvas controller's \ncamera\n and \ncontent\n. Note that if the canvas controller is container within a \nCanvasControllerWorldSpaceContainer\n, only its content will be affected. \n\n\n\n\nIsBeingDismissed\n\n\npublic bool IsBeingDismissed;\n\n\nDescription\n\n\nIs the canvas controller currently being dismissed? \n\n\nWill return true if the canvas controller is currently involved in a transition in which it is being dismissed. \n\n\n\n\nIsBeingPresented\n\n\npublic bool IsBeingPresented;\n\n\nDescription\n\n\nIs the canvas controller currently being presented? \n\n\nWill return true if the canvas controller is currently involved in a transition in which it is being presented. \n\n\n\n\nIsEmbeddedInWorldSpaceContainer\n\n\npublic bool IsEmbeddedInWorldSpaceContainer;\n\n\nDescription\n\n\nIs the canvas controller embedded in a world space container? \n\n\nWhen a canvas controller is presented in world space, it is contained within a \nCanvasControllerWorldSpaceContainer\n. \n\n\n\n\nIsTransitioning\n\n\npublic bool IsTransitioning;\n\n\nDescription\n\n\nIs the canvas controller currently transitioning? \n\n\nThis returns true on both canvas controllers involved in a transition whilst that transition is executing. \n\n\n\n\npresentationMode\n\n\npublic CanvasControllerPresentationMode presentationMode =\n    CanvasControllerPresentationMode.HidePresenter;\n\n\nDescription\n\n\nThe canvas controller's presentation mode. \n\n\nSee also: \n\n\nCanvasControllerPresentationMode\n \n\n\n\n\nPresentedCanvasController\n\n\npublic CanvasController PresentedCanvasController;\n\n\nDescription\n\n\nGet the presented canvas controller. \n\n\nIf this canvas controller has not presented a canvas controller then the presented canvas controller will be null. \n\n\n\n\nPresentingCanvasController\n\n\npublic CanvasController PresentingCanvasController;\n\n\nDescription\n\n\nGet the presenting canvas controller - the canvas controller's presenter. \n\n\nIf no canvas controller presented this canvas controller then the presenting canvas controller will be null. This is true for initial canvas controllers - canvas controllers presented from a storyboard entry transition or using \nPresentInitialCanvasController\n. \n\n\n\n\nscene\n\n\nprotected Scene scene;\n\n\nDescription\n\n\nThe canvas controller's scene. \n\n\n\n\nStoryboard\n\n\npublic Storyboard Storyboard;\n\n\nDescription\n\n\nGet the canvas controller's storyboard. \n\n\nWhen a canvas controller is presented from a storyboard, this property will be set to the storyboard whom presented it. Otherwise, it will be null. \n\n\n\n\ntransitioningAnimatorVendor\n\n\npublic ICanvasControllerTransitioningAnimatorVendor transitioningAnimatorVendor;\n\n\nDescription\n\n\nThe canvas controller's 'transitioning animator' vendor. \n\n\nWhen a canvas controller is about to be presented or dismissed, it will ask its \ntransitioningAnimatorVendor\n for an animator to animate the transition. Specify a vendor to supply transition animators to a transitioning canvas controller. \n\n\n\n\nWorldSpaceContainer\n\n\npublic CanvasControllerWorldSpaceContainer WorldSpaceContainer;\n\n\nDescription\n\n\nGet the canvas controller's world space container. \n\n\nWhen a canvas controller is presented in world space, it is contained within a \nCanvasControllerWorldSpaceContainer\n. In this scenario, this property will be set to the container. Otherwise, it will be null. \n\n\n\n\nAddChildCanvasController\n\n\npublic void AddChildCanvasController(string canvasControllerName,\n                                     RectTransform childContainer = null,\n                                     System.Action\nCanvasController\n configuration = null,\n                                     System.Action\nCanvasController\n completion = null,\n                                     bool loadAsynchronously = true);\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncanvasControllerName\n\n\nThe name of the canvas controller to add.\n\n\n\n\n\n\nchildContainer\n\n\nThe parent's rect transform under which the child should be added.\n\n\n\n\n\n\nconfiguration\n\n\nA configuration action, called after the canvas controller has been loaded but before it has been added as a child.\n\n\n\n\n\n\ncompletion\n\n\nA completion action, called after the canvas controller has been added as a child.\n\n\n\n\n\n\nloadAsynchronously\n\n\nShould the child canvas controller be loaded asynchronously? By default, all canvas controllers are loaded asynchronously.\n\n\n\n\n\n\n\n\nDescription\n\n\nLoad the specified canvas controller and add it as a child. \n\n\nThis method will load the specified canvas controller and add it as a child of the receiving canvas controller. This causes the child canvas controller to be added to the parent's hierarchy under the specified transform. The child canvas controller's camera will be disabled and it will now be rendered by its parent's camera. \n\n\n\n\nAddChildCanvasController\nT\n\n\npublic void AddChildCanvasController\nT\n(RectTransform childContainer = null,\n                                        System.Action\nT\n configuration = null,\n                                        System.Action\nT\n completion = null,\n                                        bool loadAsynchronously = true)\n    where T : CanvasController;\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nT\n\n\nThe type of the canvas controller to add.\n\n\n\n\n\n\nchildContainer\n\n\nThe parent's rect transform under which the child should be added.\n\n\n\n\n\n\nconfiguration\n\n\nA configuration action, called after the canvas controller has been loaded but before it has been added as a child.\n\n\n\n\n\n\ncompletion\n\n\nA completion action, called after the canvas controller has been added as a child.\n\n\n\n\n\n\nloadAsynchronously\n\n\nShould the child canvas controller be loaded asynchronously? By default, all canvas controllers are loaded asynchronously.\n\n\n\n\n\n\n\n\nDescription\n\n\nLoad the specified canvas controller and add it as a child. \n\n\nThis method will load the specified canvas controller and add it as a child of the receiving canvas controller. This causes the child canvas controller to be added to the parent's hierarchy under the specified transform. The child canvas controller's camera will be disabled and it will now be rendered by its parent's camera. \n\n\n\n\nAddChildCanvasController\nT\n\n\npublic void AddChildCanvasController\nT\n(string canvasControllerName,\n                                        RectTransform childContainer = null,\n                                        System.Action\nT\n configuration = null,\n                                        System.Action\nT\n completion = null,\n                                        bool loadAsynchronously = true)\n    where T : CanvasController;\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nT\n\n\nThe type of the canvas controller to add.\n\n\n\n\n\n\ncanvasControllerName\n\n\nThe name of the canvas controller to add.\n\n\n\n\n\n\nchildContainer\n\n\nThe parent's rect transform under which the child should be added.\n\n\n\n\n\n\nconfiguration\n\n\nA configuration action, called after the canvas controller has been loaded but before it has been added as a child.\n\n\n\n\n\n\ncompletion\n\n\nA completion action, called after the canvas controller has been added as a child.\n\n\n\n\n\n\nloadAsynchronously\n\n\nShould the child canvas controller be loaded asynchronously? By default, all canvas controllers are loaded asynchronously.\n\n\n\n\n\n\n\n\nDescription\n\n\nLoad the specified canvas controller and add it as a child. \n\n\nThis method will load the specified canvas controller and add it as a child of the receiving canvas controller. This causes the child canvas controller to be added to the parent's hierarchy under the specified transform. The child canvas controller's camera will be disabled and it will now be rendered by its parent's camera. \n\n\n\n\nAwake\n\n\nprotected virtual void Awake();\n\n\nDescription\n\n\nAwake is called when the canvas controller is loaded. \n\n\nIf you override Awake, always call \nbase.Awake()\n in your derived class's implementation. \n\n\n\n\nCanvasDidAppear\n\n\nprotected virtual void CanvasDidAppear();\n\n\nDescription\n\n\nOverride this method in your canvas controller to be notified just after the canvas has transitioned on screen. This could be because it has just been presented or has just dismissed its \nPresentedCanvasController\n. \n\n\nSee also: \n\n\nIsBeingPresented\n \n\n\nIsBeingDismissed\n \n\n\n\n\nCanvasDidDisappear\n\n\nprotected virtual void CanvasDidDisappear();\n\n\nDescription\n\n\nOverride this method in your canvas controller to be notified just after the canvas has transitioned off screen. This could be because it has just been dismissed or has just presented a canvas controller. \n\n\nSee also: \n\n\nIsBeingPresented\n \n\n\nIsBeingDismissed\n \n\n\n\n\nCanvasWillAppear\n\n\nprotected virtual void CanvasWillAppear();\n\n\nDescription\n\n\nOverride this method in your canvas controller to be notified just before the canvas is about to transition on screen. This could be because it is about to be presented or about to dismiss its \nPresentedCanvasController\n. \n\n\nSee also: \n\n\nIsBeingPresented\n \n\n\nIsBeingDismissed\n \n\n\n\n\nCanvasWillDisappear\n\n\nprotected virtual void CanvasWillDisappear();\n\n\nDescription\n\n\nOverride this method in your canvas controller to be notified just before the canvas is about to transition off screen. This could be because it is about to be dismissed or about to present a canvas controller. \n\n\nSee also: \n\n\nIsBeingPresented\n \n\n\nIsBeingDismissed\n \n\n\n\n\nDismissAllCanvasControllers\n\n\npublic void DismissAllCanvasControllers(bool animated = true,\n                                        System.Action completion = null);\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nanimated\n\n\nIs the transition animated?\n\n\n\n\n\n\ncompletion\n\n\nA completion action, called after the canvas controller has been dismissed.\n\n\n\n\n\n\n\n\nDescription\n\n\nDismisses all canvas controllers in the current hierarchy. \n\n\nThis method dismisses all canvas controllers in the current presentation stack. Only the top-most canvas controller will be animated in the transition. All canvas controllers in the stack will be unloaded. \n\n\n\n\nDismissCanvasController\n\n\npublic void DismissCanvasController(bool animated = true, System.Action completion = null);\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nanimated\n\n\nIs the transition animated?\n\n\n\n\n\n\ncompletion\n\n\nA completion action, called after the canvas controller has been dismissed.\n\n\n\n\n\n\n\n\nDescription\n\n\nDismiss a canvas controller. \n\n\nThis method dismisses the canvas controller's top-most \nPresentedCanvasController\n - i.e. its PresentedCanvasController's PresentedCanvasController's... etc. If any intermediary canvas controllers exist between this canvas controller and the top-most presented one, they will be unloaded. Only the top-most canvas controller and this canvas controller will be animated during the transition. \n\n\nIf this canvas controller has no \nPresentedCanvasController\n, it will be dismissed by its \nPresentingCanvasController\n. \n\n\nIf this canvas controller is an initial canvas controller, it will be dismissed completely. \n\n\n\n\nPerformTransitionWithIdentifier\n\n\npublic void PerformTransitionWithIdentifier(string identifier);\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nidentifier\n\n\nIdentifier.\n\n\n\n\n\n\n\n\nDescription\n\n\nPerform the storyboard transition with this identifier. \n\n\nIf a canvas controller has been loaded from a storyboard, its storyboard transitions can be triggered with this method. The identifier specified must be set on the transition in the storyboard editor. If a canvas controller has not been loaded from a storyboard, its \nStoryboard\n property will be \nnull\n. \n\n\n\n\nPrepareForStoryboardTransition\n\n\npublic virtual void PrepareForStoryboardTransition(StoryboardTransition transition);\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntransition\n\n\nThe storyboard transition, which provides information about the transition such as the canvas controllers involved.\n\n\n\n\n\n\n\n\nDescription\n\n\nOverride this method to be notified when the canvas controller is about to be involved in a storyboard transition. \n\n\nWhen a transition occurs in a storyboard, the transition's source canvas controller will have its \nPrepareForStoryboardTransition\n method called. This gives an opportunity to pass data between canvas controllers. \n\n\nThis method will only be called on a canvas controller whom has been loaded from a storyboard. \n\n\n\n\nPresentCanvasController\n\n\npublic void PresentCanvasController(string canvasControllerName,\n                                    bool animated = true,\n                                    System.Action\nCanvasController\n configuration = null,\n                                    System.Action\nCanvasController\n completion = null,\n                                    Vector3? canvasWorldPositionOverride = null,\n                                    bool loadAsynchronously = true);\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncanvasControllerName\n\n\nThe name of the canvas controller to present.\n\n\n\n\n\n\nanimated\n\n\nIs the transition animated?\n\n\n\n\n\n\nconfiguration\n\n\nA configuration action, called after the canvas controller has been loaded but before it has been presented.\n\n\n\n\n\n\ncompletion\n\n\nA completion action, called after the canvas controller has been presented.\n\n\n\n\n\n\ncanvasWorldPositionOverride\n\n\nA position in world space at which to place the loaded canvas controller. If no override is specified, the canvas controller will be positioned next to the presenting canvas controller.\n\n\n\n\n\n\nloadAsynchronously\n\n\nShould the canvas controller be loaded asynchronously? By default, all canvas controllers are loaded asynchronously.\n\n\n\n\n\n\n\n\nDescription\n\n\nPresent a canvas controller, specifying a name. \n\n\nThe specified canvas controller's scene will be loaded and subsequently presented by this canvas controller. \n\n\n\n\nPresentCanvasController\nT\n\n\npublic void PresentCanvasController\nT\n(bool animated = true,\n                                       System.Action\nT\n configuration = null,\n                                       System.Action\nT\n completion = null,\n                                       Vector3? canvasWorldPositionOverride = null,\n                                       bool loadAsynchronously = true)\n    where T : CanvasController;\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nT\n\n\nThe type of the canvas controller to present.\n\n\n\n\n\n\nanimated\n\n\nIs the transition animated?\n\n\n\n\n\n\nconfiguration\n\n\nA configuration action, called after the canvas controller has been loaded but before it has been presented.\n\n\n\n\n\n\ncompletion\n\n\nA completion action, called after the canvas controller has been presented.\n\n\n\n\n\n\ncanvasWorldPositionOverride\n\n\nA position in world space at which to place the loaded canvas controller. If no override is specified, the canvas controller will be positioned next to the presenting canvas controller.\n\n\n\n\n\n\nloadAsynchronously\n\n\nShould the canvas controller be loaded asynchronously? By default, all canvas controllers are loaded asynchronously.\n\n\n\n\n\n\n\n\nDescription\n\n\nPresent a canvas controller, specifying a type. \n\n\nThe specified canvas controller's scene will be loaded and subsequently presented by this canvas controller. \n\n\n\n\nPresentCanvasController\nT\n\n\npublic void PresentCanvasController\nT\n(string canvasControllerName,\n                                       bool animated = true,\n                                       System.Action\nT\n configuration = null,\n                                       System.Action\nT\n completion = null,\n                                       Vector3? canvasWorldPositionOverride = null,\n                                       bool loadAsynchronously = true)\n    where T : CanvasController;\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nT\n\n\nThe type of the canvas controller to present.\n\n\n\n\n\n\ncanvasControllerName\n\n\nThe name of the canvas controller to present.\n\n\n\n\n\n\nanimated\n\n\nIs the transition animated?\n\n\n\n\n\n\nconfiguration\n\n\nA configuration action, called after the canvas controller has been loaded but before it has been presented.\n\n\n\n\n\n\ncompletion\n\n\nA completion action, called after the canvas controller has been presented.\n\n\n\n\n\n\ncanvasWorldPositionOverride\n\n\nA position in world space at which to place the loaded canvas controller. If no override is specified, the canvas controller will be positioned next to the presenting canvas controller.\n\n\n\n\n\n\nloadAsynchronously\n\n\nShould the canvas controller be loaded asynchronously? By default, all canvas controllers are loaded asynchronously.\n\n\n\n\n\n\n\n\nDescription\n\n\nPresent a canvas controller, specifying a type and a name. \n\n\nThe specified canvas controller's scene will be loaded and subsequently presented by this canvas controller. \n\n\n\n\nPresentInitialCanvasController\n\n\npublic static void PresentInitialCanvasController(\n    string canvasControllerName,\n    System.Action\nCanvasController\n configuration = null,\n    System.Action\nCanvasController\n completion = null,\n    bool animated = true,\n    Vector3? canvasWorldPositionOverride = null,\n    bool loadAsynchronously = true,\n    CanvasControllerWorldSpaceContainer worldSpaceContainer = null);\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncanvasControllerName\n\n\nThe name of the canvas controller to present.\n\n\n\n\n\n\nconfiguration\n\n\nA configuration action, called after the canvas controller has been loaded but before it has been presented.\n\n\n\n\n\n\ncompletion\n\n\nA completion action, called after the canvas controller has been presented.\n\n\n\n\n\n\nanimated\n\n\nIs the transition animated?\n\n\n\n\n\n\ncanvasWorldPositionOverride\n\n\nA position in world space at which to place the loaded canvas controller. If no override is specified, the canvas controller will be positioned next to the presenting canvas controller.\n\n\n\n\n\n\nloadAsynchronously\n\n\nShould the canvas controller be loaded asynchronously? By default, all canvas controllers are loaded asynchronously.\n\n\n\n\n\n\nworldSpaceContainer\n\n\nSpecify a world space container to present this canvas controller in world space.\n\n\n\n\n\n\n\n\nDescription\n\n\nPresent an initial canvas controller, specifying a name. \n\n\nThis method is used to present an initial canvas controller - the first canvas controller in the hierarchy. From there, the \nPresentCanvasController\n and \nDismissCanvasController\n methods can be used. \n\n\n\n\nPresentInitialCanvasController\nT\n\n\npublic static void PresentInitialCanvasController\nT\n(\n    System.Action\nT\n configuration = null,\n    System.Action\nT\n completion = null,\n    bool animated = true,\n    Vector3? canvasWorldPositionOverride = null,\n    bool loadAsynchronously = true,\n    CanvasControllerWorldSpaceContainer worldSpaceContainer = null)\n    where T : CanvasController;\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nT\n\n\nThe type of the canvas controller to present.\n\n\n\n\n\n\nconfiguration\n\n\nA configuration action, called after the canvas controller has been loaded but before it has been presented.\n\n\n\n\n\n\ncompletion\n\n\nA completion action, called after the canvas controller has been presented.\n\n\n\n\n\n\nanimated\n\n\nIs the transition animated?\n\n\n\n\n\n\ncanvasWorldPositionOverride\n\n\nA position in world space at which to place the loaded canvas controller. If no override is specified, the canvas controller will be positioned next to the presenting canvas controller.\n\n\n\n\n\n\nloadAsynchronously\n\n\nShould the canvas controller be loaded asynchronously? By default, all canvas controllers are loaded asynchronously.\n\n\n\n\n\n\nworldSpaceContainer\n\n\nSpecify a world space container to present this canvas controller in world space.\n\n\n\n\n\n\n\n\nDescription\n\n\nPresent an initial canvas controller, specifying a type. \n\n\nThis method is used to present an initial canvas controller - the first canvas controller in the hierarchy. From there, the \nPresentCanvasController\n and \nDismissCanvasController\n methods can be used. \n\n\n\n\nPresentInitialCanvasController\nT\n\n\npublic static void PresentInitialCanvasController\nT\n(\n    string canvasControllerName,\n    System.Action\nT\n configuration = null,\n    System.Action\nT\n completion = null,\n    bool animated = true,\n    Vector3? canvasWorldPositionOverride = null,\n    bool loadAsynchronously = true,\n    CanvasControllerWorldSpaceContainer worldSpaceContainer = null)\n    where T : CanvasController;\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nT\n\n\nThe type of the canvas controller to present.\n\n\n\n\n\n\ncanvasControllerName\n\n\nThe name of the canvas controller to present.\n\n\n\n\n\n\nconfiguration\n\n\nA configuration action, called after the canvas controller has been loaded but before it has been presented.\n\n\n\n\n\n\ncompletion\n\n\nA completion action, called after the canvas controller has been presented.\n\n\n\n\n\n\nanimated\n\n\nIs the transition animated?\n\n\n\n\n\n\ncanvasWorldPositionOverride\n\n\nA position in world space at which to place the loaded canvas controller. If no override is specified, the canvas controller will be positioned next to the presenting canvas controller.\n\n\n\n\n\n\nloadAsynchronously\n\n\nShould the canvas controller be loaded asynchronously? By default, all canvas controllers are loaded asynchronously.\n\n\n\n\n\n\nworldSpaceContainer\n\n\nSpecify a world space container to present this canvas controller in world space.\n\n\n\n\n\n\n\n\nDescription\n\n\nPresent an initial canvas controller, specifying a type and a name. \n\n\nThis method is used to present an initial canvas controller - the first canvas controller in the hierarchy. From there, the \nPresentCanvasController\n and \nDismissCanvasController\n methods can be used. \n\n\n\n\nRemoveAndUnloadChildCanvasController\n\n\npublic void RemoveAndUnloadChildCanvasController(CanvasController canvasController);\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncanvasController\n\n\nThe child canvas controller to remove and unload.\n\n\n\n\n\n\n\n\nDescription\n\n\nRemove and unload a child canvas controller. \n\n\n\n\nStart\n\n\nprotected virtual void Start();\n\n\nDescription\n\n\nStart is called on the frame when the canvas controller is loaded, after \nAwake\n.", 
            "title": "CanvasController"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#canvascontroller", 
            "text": "public class CanvasController : MonoBehaviour, IStoryboardable;", 
            "title": "CanvasController"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#description", 
            "text": "A canvas controller represents a single screen in your user interface. Canvas controllers can present and dismiss other canvas controllers, or screens, allowing you to easily build a user interface flow, presenting and dismissing screens as required. A canvas controller automatically manages the presentation hierarchy, as well as loading and unloading itself as it is presented or dismissed.   Canvas controllers should be created with Unity's  Create  menu - found by either right-clicking in the Project window or selecting Assets in the menu bar - and selecting  Create/Canvas Flow/Canvas Controller .   Present and dismiss canvas controllers with the  PresentCanvasController  and  DismissCanvasController  methods. To present or dismiss an initial canvas controller use the  PresentInitialCanvasController  and   DismissAllCanvasControllers  methods.   A canvas controller can override its appearance methods to be notified of the appearance events  CanvasWillAppear ,  CanvasDidAppear ,  CanvasWillDisappear , and  CanvasDidDisappear .   Canvas controllers can be used with storyboards to visually define the presentation flow. When working with storyboards, data can be passed between canvas controllers by overriding the  PrepareForStoryboardTransition  method. Additionally, storyboard transitions can be triggered from a canvas controller using the  PerformTransitionWithIdentifier  method.   Canvas controllers can be presented in world space by either setting a storyboard's  StoryboardPresentationSpace  to  WorldSpace , or by passing a  CanvasControllerWorldSpaceContainer  to  PresentInitialCanvasController . Canvas controllers presented from a world space canvas controller will also be presented in world space and contained within the presenter's container.      Properties       backgroundImage  The canvas controller's background image.    camera  The canvas controller's camera.    canvas  The canvas controller's main canvas.    ChildCanvasControllers  Get the canvas controller's children.    content  The canvas controller's content transform.    ContentActive  Enable/disable the canvas contoller's content. This is equivalent to calling  content.gameObject.activeSelf  and  content.gameObject.SetActive .    ContentPosition  Get/set the position of the canvas controller's content. This is equivalent to calling  content.localPosition .    ContentScale  Get/set the scale of the canvas controller's content. This is equivalent to calling  content.localScale .    Hidden  Hide/show the canvas controller. This will enable/disable both the canvas controller's  camera  and  content . Note that if the canvas controller is container within a  CanvasControllerWorldSpaceContainer , only its content will be affected.    IsBeingDismissed  Is the canvas controller currently being dismissed?    IsBeingPresented  Is the canvas controller currently being presented?    IsEmbeddedInWorldSpaceContainer  Is the canvas controller embedded in a world space container?    IsTransitioning  Is the canvas controller currently transitioning?    presentationMode  The canvas controller's presentation mode.    PresentedCanvasController  Get the presented canvas controller.    PresentingCanvasController  Get the presenting canvas controller - the canvas controller's presenter.    scene  The canvas controller's scene.    Storyboard  Get the canvas controller's storyboard.    transitioningAnimatorVendor  The canvas controller's 'transitioning animator' vendor.    WorldSpaceContainer  Get the canvas controller's world space container.        Methods       AddChildCanvasController  Load the specified canvas controller and add it as a child.    AddChildCanvasController T  Load the specified canvas controller and add it as a child.    AddChildCanvasController T  Load the specified canvas controller and add it as a child.    Awake  Awake is called when the canvas controller is loaded.    CanvasDidAppear  Override this method in your canvas controller to be notified just after the canvas has transitioned on screen. This could be because it has just been presented or has just dismissed its  PresentedCanvasController .    CanvasDidDisappear  Override this method in your canvas controller to be notified just after the canvas has transitioned off screen. This could be because it has just been dismissed or has just presented a canvas controller.    CanvasWillAppear  Override this method in your canvas controller to be notified just before the canvas is about to transition on screen. This could be because it is about to be presented or about to dismiss its  PresentedCanvasController .    CanvasWillDisappear  Override this method in your canvas controller to be notified just before the canvas is about to transition off screen. This could be because it is about to be dismissed or about to present a canvas controller.    DismissAllCanvasControllers  Dismisses all canvas controllers in the current hierarchy.    DismissCanvasController  Dismiss a canvas controller.    PerformTransitionWithIdentifier  Perform the storyboard transition with this identifier.    PrepareForStoryboardTransition  Override this method to be notified when the canvas controller is about to be involved in a storyboard transition.    PresentCanvasController  Present a canvas controller, specifying a name.    PresentCanvasController T  Present a canvas controller, specifying a type.    PresentCanvasController T  Present a canvas controller, specifying a type and a name.    PresentInitialCanvasController  Present an initial canvas controller, specifying a name.    PresentInitialCanvasController T  Present an initial canvas controller, specifying a type.    PresentInitialCanvasController T  Present an initial canvas controller, specifying a type and a name.    RemoveAndUnloadChildCanvasController  Remove and unload a child canvas controller.    Start  Start is called on the frame when the canvas controller is loaded, after  Awake .", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#backgroundimage", 
            "text": "public Image backgroundImage;", 
            "title": "backgroundImage"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#description_1", 
            "text": "The canvas controller's background image.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#camera", 
            "text": "public new Camera camera;", 
            "title": "camera"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#description_2", 
            "text": "The canvas controller's camera.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#canvas", 
            "text": "public Canvas canvas;", 
            "title": "canvas"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#description_3", 
            "text": "The canvas controller's main canvas.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#childcanvascontrollers", 
            "text": "public ReadOnlyCollection CanvasController  ChildCanvasControllers;", 
            "title": "ChildCanvasControllers"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#description_4", 
            "text": "Get the canvas controller's children.   Use the  AddChildCanvasController  and  RemoveAndUnloadChildCanvasController  methods to add and remove child canvas controllers.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#content", 
            "text": "public RectTransform content;", 
            "title": "content"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#description_5", 
            "text": "The canvas controller's content transform.   All content should be placed under the content transform.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#contentactive", 
            "text": "public bool ContentActive;", 
            "title": "ContentActive"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#description_6", 
            "text": "Enable/disable the canvas contoller's content. This is equivalent to calling  content.gameObject.activeSelf  and  content.gameObject.SetActive .   If you intend to hide the canvas controller completely, use the  Hidden  property as this will disable the canvas' camera as well as the content.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#contentposition", 
            "text": "public Vector3 ContentPosition;", 
            "title": "ContentPosition"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#description_7", 
            "text": "Get/set the position of the canvas controller's content. This is equivalent to calling  content.localPosition .", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#contentscale", 
            "text": "public Vector3 ContentScale;", 
            "title": "ContentScale"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#description_8", 
            "text": "Get/set the scale of the canvas controller's content. This is equivalent to calling  content.localScale .", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#hidden", 
            "text": "public bool Hidden;", 
            "title": "Hidden"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#description_9", 
            "text": "Hide/show the canvas controller. This will enable/disable both the canvas controller's  camera  and  content . Note that if the canvas controller is container within a  CanvasControllerWorldSpaceContainer , only its content will be affected.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#isbeingdismissed", 
            "text": "public bool IsBeingDismissed;", 
            "title": "IsBeingDismissed"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#description_10", 
            "text": "Is the canvas controller currently being dismissed?   Will return true if the canvas controller is currently involved in a transition in which it is being dismissed.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#isbeingpresented", 
            "text": "public bool IsBeingPresented;", 
            "title": "IsBeingPresented"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#description_11", 
            "text": "Is the canvas controller currently being presented?   Will return true if the canvas controller is currently involved in a transition in which it is being presented.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#isembeddedinworldspacecontainer", 
            "text": "public bool IsEmbeddedInWorldSpaceContainer;", 
            "title": "IsEmbeddedInWorldSpaceContainer"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#description_12", 
            "text": "Is the canvas controller embedded in a world space container?   When a canvas controller is presented in world space, it is contained within a  CanvasControllerWorldSpaceContainer .", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#istransitioning", 
            "text": "public bool IsTransitioning;", 
            "title": "IsTransitioning"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#description_13", 
            "text": "Is the canvas controller currently transitioning?   This returns true on both canvas controllers involved in a transition whilst that transition is executing.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#presentationmode", 
            "text": "public CanvasControllerPresentationMode presentationMode =\n    CanvasControllerPresentationMode.HidePresenter;", 
            "title": "presentationMode"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#description_14", 
            "text": "The canvas controller's presentation mode.   See also:   CanvasControllerPresentationMode", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#presentedcanvascontroller", 
            "text": "public CanvasController PresentedCanvasController;", 
            "title": "PresentedCanvasController"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#description_15", 
            "text": "Get the presented canvas controller.   If this canvas controller has not presented a canvas controller then the presented canvas controller will be null.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#presentingcanvascontroller", 
            "text": "public CanvasController PresentingCanvasController;", 
            "title": "PresentingCanvasController"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#description_16", 
            "text": "Get the presenting canvas controller - the canvas controller's presenter.   If no canvas controller presented this canvas controller then the presenting canvas controller will be null. This is true for initial canvas controllers - canvas controllers presented from a storyboard entry transition or using  PresentInitialCanvasController .", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#scene", 
            "text": "protected Scene scene;", 
            "title": "scene"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#description_17", 
            "text": "The canvas controller's scene.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#storyboard", 
            "text": "public Storyboard Storyboard;", 
            "title": "Storyboard"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#description_18", 
            "text": "Get the canvas controller's storyboard.   When a canvas controller is presented from a storyboard, this property will be set to the storyboard whom presented it. Otherwise, it will be null.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#transitioninganimatorvendor", 
            "text": "public ICanvasControllerTransitioningAnimatorVendor transitioningAnimatorVendor;", 
            "title": "transitioningAnimatorVendor"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#description_19", 
            "text": "The canvas controller's 'transitioning animator' vendor.   When a canvas controller is about to be presented or dismissed, it will ask its  transitioningAnimatorVendor  for an animator to animate the transition. Specify a vendor to supply transition animators to a transitioning canvas controller.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#worldspacecontainer", 
            "text": "public CanvasControllerWorldSpaceContainer WorldSpaceContainer;", 
            "title": "WorldSpaceContainer"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#description_20", 
            "text": "Get the canvas controller's world space container.   When a canvas controller is presented in world space, it is contained within a  CanvasControllerWorldSpaceContainer . In this scenario, this property will be set to the container. Otherwise, it will be null.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#addchildcanvascontroller", 
            "text": "public void AddChildCanvasController(string canvasControllerName,\n                                     RectTransform childContainer = null,\n                                     System.Action CanvasController  configuration = null,\n                                     System.Action CanvasController  completion = null,\n                                     bool loadAsynchronously = true);", 
            "title": "AddChildCanvasController"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#parameters", 
            "text": "Name  Description      canvasControllerName  The name of the canvas controller to add.    childContainer  The parent's rect transform under which the child should be added.    configuration  A configuration action, called after the canvas controller has been loaded but before it has been added as a child.    completion  A completion action, called after the canvas controller has been added as a child.    loadAsynchronously  Should the child canvas controller be loaded asynchronously? By default, all canvas controllers are loaded asynchronously.", 
            "title": "Parameters"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#description_21", 
            "text": "Load the specified canvas controller and add it as a child.   This method will load the specified canvas controller and add it as a child of the receiving canvas controller. This causes the child canvas controller to be added to the parent's hierarchy under the specified transform. The child canvas controller's camera will be disabled and it will now be rendered by its parent's camera.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#addchildcanvascontrollert", 
            "text": "public void AddChildCanvasController T (RectTransform childContainer = null,\n                                        System.Action T  configuration = null,\n                                        System.Action T  completion = null,\n                                        bool loadAsynchronously = true)\n    where T : CanvasController;", 
            "title": "AddChildCanvasController&lt;T&gt;"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#parameters_1", 
            "text": "Name  Description      T  The type of the canvas controller to add.    childContainer  The parent's rect transform under which the child should be added.    configuration  A configuration action, called after the canvas controller has been loaded but before it has been added as a child.    completion  A completion action, called after the canvas controller has been added as a child.    loadAsynchronously  Should the child canvas controller be loaded asynchronously? By default, all canvas controllers are loaded asynchronously.", 
            "title": "Parameters"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#description_22", 
            "text": "Load the specified canvas controller and add it as a child.   This method will load the specified canvas controller and add it as a child of the receiving canvas controller. This causes the child canvas controller to be added to the parent's hierarchy under the specified transform. The child canvas controller's camera will be disabled and it will now be rendered by its parent's camera.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#addchildcanvascontrollert_1", 
            "text": "public void AddChildCanvasController T (string canvasControllerName,\n                                        RectTransform childContainer = null,\n                                        System.Action T  configuration = null,\n                                        System.Action T  completion = null,\n                                        bool loadAsynchronously = true)\n    where T : CanvasController;", 
            "title": "AddChildCanvasController&lt;T&gt;"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#parameters_2", 
            "text": "Name  Description      T  The type of the canvas controller to add.    canvasControllerName  The name of the canvas controller to add.    childContainer  The parent's rect transform under which the child should be added.    configuration  A configuration action, called after the canvas controller has been loaded but before it has been added as a child.    completion  A completion action, called after the canvas controller has been added as a child.    loadAsynchronously  Should the child canvas controller be loaded asynchronously? By default, all canvas controllers are loaded asynchronously.", 
            "title": "Parameters"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#description_23", 
            "text": "Load the specified canvas controller and add it as a child.   This method will load the specified canvas controller and add it as a child of the receiving canvas controller. This causes the child canvas controller to be added to the parent's hierarchy under the specified transform. The child canvas controller's camera will be disabled and it will now be rendered by its parent's camera.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#awake", 
            "text": "protected virtual void Awake();", 
            "title": "Awake"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#description_24", 
            "text": "Awake is called when the canvas controller is loaded.   If you override Awake, always call  base.Awake()  in your derived class's implementation.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#canvasdidappear", 
            "text": "protected virtual void CanvasDidAppear();", 
            "title": "CanvasDidAppear"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#description_25", 
            "text": "Override this method in your canvas controller to be notified just after the canvas has transitioned on screen. This could be because it has just been presented or has just dismissed its  PresentedCanvasController .   See also:   IsBeingPresented    IsBeingDismissed", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#canvasdiddisappear", 
            "text": "protected virtual void CanvasDidDisappear();", 
            "title": "CanvasDidDisappear"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#description_26", 
            "text": "Override this method in your canvas controller to be notified just after the canvas has transitioned off screen. This could be because it has just been dismissed or has just presented a canvas controller.   See also:   IsBeingPresented    IsBeingDismissed", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#canvaswillappear", 
            "text": "protected virtual void CanvasWillAppear();", 
            "title": "CanvasWillAppear"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#description_27", 
            "text": "Override this method in your canvas controller to be notified just before the canvas is about to transition on screen. This could be because it is about to be presented or about to dismiss its  PresentedCanvasController .   See also:   IsBeingPresented    IsBeingDismissed", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#canvaswilldisappear", 
            "text": "protected virtual void CanvasWillDisappear();", 
            "title": "CanvasWillDisappear"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#description_28", 
            "text": "Override this method in your canvas controller to be notified just before the canvas is about to transition off screen. This could be because it is about to be dismissed or about to present a canvas controller.   See also:   IsBeingPresented    IsBeingDismissed", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#dismissallcanvascontrollers", 
            "text": "public void DismissAllCanvasControllers(bool animated = true,\n                                        System.Action completion = null);", 
            "title": "DismissAllCanvasControllers"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#parameters_3", 
            "text": "Name  Description      animated  Is the transition animated?    completion  A completion action, called after the canvas controller has been dismissed.", 
            "title": "Parameters"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#description_29", 
            "text": "Dismisses all canvas controllers in the current hierarchy.   This method dismisses all canvas controllers in the current presentation stack. Only the top-most canvas controller will be animated in the transition. All canvas controllers in the stack will be unloaded.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#dismisscanvascontroller", 
            "text": "public void DismissCanvasController(bool animated = true, System.Action completion = null);", 
            "title": "DismissCanvasController"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#parameters_4", 
            "text": "Name  Description      animated  Is the transition animated?    completion  A completion action, called after the canvas controller has been dismissed.", 
            "title": "Parameters"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#description_30", 
            "text": "Dismiss a canvas controller.   This method dismisses the canvas controller's top-most  PresentedCanvasController  - i.e. its PresentedCanvasController's PresentedCanvasController's... etc. If any intermediary canvas controllers exist between this canvas controller and the top-most presented one, they will be unloaded. Only the top-most canvas controller and this canvas controller will be animated during the transition.   If this canvas controller has no  PresentedCanvasController , it will be dismissed by its  PresentingCanvasController .   If this canvas controller is an initial canvas controller, it will be dismissed completely.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#performtransitionwithidentifier", 
            "text": "public void PerformTransitionWithIdentifier(string identifier);", 
            "title": "PerformTransitionWithIdentifier"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#parameters_5", 
            "text": "Name  Description      identifier  Identifier.", 
            "title": "Parameters"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#description_31", 
            "text": "Perform the storyboard transition with this identifier.   If a canvas controller has been loaded from a storyboard, its storyboard transitions can be triggered with this method. The identifier specified must be set on the transition in the storyboard editor. If a canvas controller has not been loaded from a storyboard, its  Storyboard  property will be  null .", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#prepareforstoryboardtransition", 
            "text": "public virtual void PrepareForStoryboardTransition(StoryboardTransition transition);", 
            "title": "PrepareForStoryboardTransition"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#parameters_6", 
            "text": "Name  Description      transition  The storyboard transition, which provides information about the transition such as the canvas controllers involved.", 
            "title": "Parameters"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#description_32", 
            "text": "Override this method to be notified when the canvas controller is about to be involved in a storyboard transition.   When a transition occurs in a storyboard, the transition's source canvas controller will have its  PrepareForStoryboardTransition  method called. This gives an opportunity to pass data between canvas controllers.   This method will only be called on a canvas controller whom has been loaded from a storyboard.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#presentcanvascontroller", 
            "text": "public void PresentCanvasController(string canvasControllerName,\n                                    bool animated = true,\n                                    System.Action CanvasController  configuration = null,\n                                    System.Action CanvasController  completion = null,\n                                    Vector3? canvasWorldPositionOverride = null,\n                                    bool loadAsynchronously = true);", 
            "title": "PresentCanvasController"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#parameters_7", 
            "text": "Name  Description      canvasControllerName  The name of the canvas controller to present.    animated  Is the transition animated?    configuration  A configuration action, called after the canvas controller has been loaded but before it has been presented.    completion  A completion action, called after the canvas controller has been presented.    canvasWorldPositionOverride  A position in world space at which to place the loaded canvas controller. If no override is specified, the canvas controller will be positioned next to the presenting canvas controller.    loadAsynchronously  Should the canvas controller be loaded asynchronously? By default, all canvas controllers are loaded asynchronously.", 
            "title": "Parameters"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#description_33", 
            "text": "Present a canvas controller, specifying a name.   The specified canvas controller's scene will be loaded and subsequently presented by this canvas controller.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#presentcanvascontrollert", 
            "text": "public void PresentCanvasController T (bool animated = true,\n                                       System.Action T  configuration = null,\n                                       System.Action T  completion = null,\n                                       Vector3? canvasWorldPositionOverride = null,\n                                       bool loadAsynchronously = true)\n    where T : CanvasController;", 
            "title": "PresentCanvasController&lt;T&gt;"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#parameters_8", 
            "text": "Name  Description      T  The type of the canvas controller to present.    animated  Is the transition animated?    configuration  A configuration action, called after the canvas controller has been loaded but before it has been presented.    completion  A completion action, called after the canvas controller has been presented.    canvasWorldPositionOverride  A position in world space at which to place the loaded canvas controller. If no override is specified, the canvas controller will be positioned next to the presenting canvas controller.    loadAsynchronously  Should the canvas controller be loaded asynchronously? By default, all canvas controllers are loaded asynchronously.", 
            "title": "Parameters"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#description_34", 
            "text": "Present a canvas controller, specifying a type.   The specified canvas controller's scene will be loaded and subsequently presented by this canvas controller.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#presentcanvascontrollert_1", 
            "text": "public void PresentCanvasController T (string canvasControllerName,\n                                       bool animated = true,\n                                       System.Action T  configuration = null,\n                                       System.Action T  completion = null,\n                                       Vector3? canvasWorldPositionOverride = null,\n                                       bool loadAsynchronously = true)\n    where T : CanvasController;", 
            "title": "PresentCanvasController&lt;T&gt;"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#parameters_9", 
            "text": "Name  Description      T  The type of the canvas controller to present.    canvasControllerName  The name of the canvas controller to present.    animated  Is the transition animated?    configuration  A configuration action, called after the canvas controller has been loaded but before it has been presented.    completion  A completion action, called after the canvas controller has been presented.    canvasWorldPositionOverride  A position in world space at which to place the loaded canvas controller. If no override is specified, the canvas controller will be positioned next to the presenting canvas controller.    loadAsynchronously  Should the canvas controller be loaded asynchronously? By default, all canvas controllers are loaded asynchronously.", 
            "title": "Parameters"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#description_35", 
            "text": "Present a canvas controller, specifying a type and a name.   The specified canvas controller's scene will be loaded and subsequently presented by this canvas controller.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#presentinitialcanvascontroller", 
            "text": "public static void PresentInitialCanvasController(\n    string canvasControllerName,\n    System.Action CanvasController  configuration = null,\n    System.Action CanvasController  completion = null,\n    bool animated = true,\n    Vector3? canvasWorldPositionOverride = null,\n    bool loadAsynchronously = true,\n    CanvasControllerWorldSpaceContainer worldSpaceContainer = null);", 
            "title": "PresentInitialCanvasController"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#parameters_10", 
            "text": "Name  Description      canvasControllerName  The name of the canvas controller to present.    configuration  A configuration action, called after the canvas controller has been loaded but before it has been presented.    completion  A completion action, called after the canvas controller has been presented.    animated  Is the transition animated?    canvasWorldPositionOverride  A position in world space at which to place the loaded canvas controller. If no override is specified, the canvas controller will be positioned next to the presenting canvas controller.    loadAsynchronously  Should the canvas controller be loaded asynchronously? By default, all canvas controllers are loaded asynchronously.    worldSpaceContainer  Specify a world space container to present this canvas controller in world space.", 
            "title": "Parameters"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#description_36", 
            "text": "Present an initial canvas controller, specifying a name.   This method is used to present an initial canvas controller - the first canvas controller in the hierarchy. From there, the  PresentCanvasController  and  DismissCanvasController  methods can be used.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#presentinitialcanvascontrollert", 
            "text": "public static void PresentInitialCanvasController T (\n    System.Action T  configuration = null,\n    System.Action T  completion = null,\n    bool animated = true,\n    Vector3? canvasWorldPositionOverride = null,\n    bool loadAsynchronously = true,\n    CanvasControllerWorldSpaceContainer worldSpaceContainer = null)\n    where T : CanvasController;", 
            "title": "PresentInitialCanvasController&lt;T&gt;"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#parameters_11", 
            "text": "Name  Description      T  The type of the canvas controller to present.    configuration  A configuration action, called after the canvas controller has been loaded but before it has been presented.    completion  A completion action, called after the canvas controller has been presented.    animated  Is the transition animated?    canvasWorldPositionOverride  A position in world space at which to place the loaded canvas controller. If no override is specified, the canvas controller will be positioned next to the presenting canvas controller.    loadAsynchronously  Should the canvas controller be loaded asynchronously? By default, all canvas controllers are loaded asynchronously.    worldSpaceContainer  Specify a world space container to present this canvas controller in world space.", 
            "title": "Parameters"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#description_37", 
            "text": "Present an initial canvas controller, specifying a type.   This method is used to present an initial canvas controller - the first canvas controller in the hierarchy. From there, the  PresentCanvasController  and  DismissCanvasController  methods can be used.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#presentinitialcanvascontrollert_1", 
            "text": "public static void PresentInitialCanvasController T (\n    string canvasControllerName,\n    System.Action T  configuration = null,\n    System.Action T  completion = null,\n    bool animated = true,\n    Vector3? canvasWorldPositionOverride = null,\n    bool loadAsynchronously = true,\n    CanvasControllerWorldSpaceContainer worldSpaceContainer = null)\n    where T : CanvasController;", 
            "title": "PresentInitialCanvasController&lt;T&gt;"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#parameters_12", 
            "text": "Name  Description      T  The type of the canvas controller to present.    canvasControllerName  The name of the canvas controller to present.    configuration  A configuration action, called after the canvas controller has been loaded but before it has been presented.    completion  A completion action, called after the canvas controller has been presented.    animated  Is the transition animated?    canvasWorldPositionOverride  A position in world space at which to place the loaded canvas controller. If no override is specified, the canvas controller will be positioned next to the presenting canvas controller.    loadAsynchronously  Should the canvas controller be loaded asynchronously? By default, all canvas controllers are loaded asynchronously.    worldSpaceContainer  Specify a world space container to present this canvas controller in world space.", 
            "title": "Parameters"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#description_38", 
            "text": "Present an initial canvas controller, specifying a type and a name.   This method is used to present an initial canvas controller - the first canvas controller in the hierarchy. From there, the  PresentCanvasController  and  DismissCanvasController  methods can be used.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#removeandunloadchildcanvascontroller", 
            "text": "public void RemoveAndUnloadChildCanvasController(CanvasController canvasController);", 
            "title": "RemoveAndUnloadChildCanvasController"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#parameters_13", 
            "text": "Name  Description      canvasController  The child canvas controller to remove and unload.", 
            "title": "Parameters"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#description_39", 
            "text": "Remove and unload a child canvas controller.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#start", 
            "text": "protected virtual void Start();", 
            "title": "Start"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasController/#description_40", 
            "text": "Start is called on the frame when the canvas controller is loaded, after  Awake .", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasControllerExtensions/", 
            "text": "CanvasControllerExtensions\n\n\npublic static class CanvasControllerExtensions;\n\n\nDescription\n\n\nCanvasController\n extension methods. \n\n\n\n\n\n\n\n\nProperties\n\n\n\n\n\n\n\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMethods\n\n\n\n\n\n\n\n\n\n\n\n\nCanvasRectTransform\n\n\nThe canvas controller\u2019s canvas\u2019 \nRectTransform\n component.\n\n\n\n\n\n\nCanvasSize\n\n\nThe canvas controller\u2019s canvas\u2019 size.\n\n\n\n\n\n\nCanvasWorldBounds\n\n\nThe canvas controller\u2019s canvas\u2019 bounds in world space.\n\n\n\n\n\n\nCanvasWorldCorners\n\n\nThe canvas controller\u2019s canvas\u2019 corners in world space.\n\n\n\n\n\n\nCanvasWorldSize\n\n\nThe canvas controller\u2019s canvas\u2019 size in world space. This is the difference between the top right world corner and the bottom left world corner.\n\n\n\n\n\n\nIsScreenSpace\n\n\nIs the canvas controller\u2019s canvas in screen space?\n\n\n\n\n\n\nOffScreenBottomContentPosition\n\n\nThe position for the canvas controller\u2019s content that will position it off the bottom of the screen.\n\n\n\n\n\n\nOffScreenLeftContentPosition\n\n\nThe position for the canvas controller\u2019s content that will position it off the left of the screen.\n\n\n\n\n\n\nOffScreenRightContentPosition\n\n\nThe position for the canvas controller\u2019s content that will position it off the right of the screen.\n\n\n\n\n\n\nOffScreenTopContentPosition\n\n\nThe position for the canvas controller\u2019s content that will position it off the top of the screen.\n\n\n\n\n\n\nOnScreenContentPosition\n\n\nThe on-screen position for the canvas controller\u2019s content.\n\n\n\n\n\n\n\n\n\n\nCanvasRectTransform\n\n\npublic static RectTransform CanvasRectTransform(this CanvasController canvasController);\n\n\nDescription\n\n\nThe canvas controller\u2019s canvas\u2019 \nRectTransform\n component. \n\n\nThis is equivalent to calling \ncanvasController.canvas.GetComponent()\n. \n\n\nSee also: \n\n\nCanvasController.canvas\n \n\n\n\n\nCanvasSize\n\n\npublic static Vector2 CanvasSize(this CanvasController canvasController);\n\n\nDescription\n\n\nThe canvas controller\u2019s canvas\u2019 size. \n\n\nThis is equivalent to calling \ncanvasController.CanvasRectTransform().rect.size\n. \n\n\nSee also: \n\n\nCanvasController.canvas\n \n\n\n\n\nCanvasWorldBounds\n\n\npublic static Bounds CanvasWorldBounds(this CanvasController canvasController);\n\n\nDescription\n\n\nThe canvas controller\u2019s canvas\u2019 bounds in world space. \n\n\nYou might use this method when doing canvas-related world space calculations. For example, Canvas Flow uses this internally to position canvas controller\u2019s next to one another in world space. \n\n\nSee also: \n\n\nCanvasController.canvas\n \n\n\n\n\nCanvasWorldCorners\n\n\npublic static Vector3[] CanvasWorldCorners(this CanvasController canvasController);\n\n\nDescription\n\n\nThe canvas controller\u2019s canvas\u2019 corners in world space. \n\n\nYou might use this method when doing canvas-related world space calculations. For example, Canvas Flow uses this internally to position canvas controller\u2019s next to one another in world space. \n\n\nSee also: \n\n\nCanvasController.canvas\n \n\n\n\n\nCanvasWorldSize\n\n\npublic static Vector2 CanvasWorldSize(this CanvasController canvasController);\n\n\nDescription\n\n\nThe canvas controller\u2019s canvas\u2019 size in world space. This is the difference between the top right world corner and the bottom left world corner. \n\n\nYou might use this method when doing canvas-related world space calculations. For example, Canvas Flow uses this internally to position canvas controller\u2019s next to one another in world space. \n\n\nSee also: \n\n\nCanvasController.canvas\n \n\n\n\n\nIsScreenSpace\n\n\npublic static bool IsScreenSpace(this CanvasController canvasController);\n\n\nDescription\n\n\nIs the canvas controller\u2019s canvas in screen space? \n\n\nReturns \ntrue\n if the canvas controller\u2019s canvas is in a screen space render mode. \n\n\nSee also: \n\n\nCanvasController.canvas\n \n\n\n\n\nOffScreenBottomContentPosition\n\n\npublic static Vector3 OffScreenBottomContentPosition(this CanvasController canvasController);\n\n\nDescription\n\n\nThe position for the canvas controller\u2019s content that will position it off the bottom of the screen. \n\n\nThis is calculated using the height of the canvas controller\u2019s canvas. You might use this method when animating or moving a canvas controller\u2019s content to or from the bottom of the screen. \n\n\nSee also: \n\n\nCanvasController.ContentPosition\n \n\n\nCanvasController.content\n \n\n\nCanvasController.canvas\n \n\n\n\n\nOffScreenLeftContentPosition\n\n\npublic static Vector3 OffScreenLeftContentPosition(this CanvasController canvasController);\n\n\nDescription\n\n\nThe position for the canvas controller\u2019s content that will position it off the left of the screen. \n\n\nThis is calculated using the width of the canvas controller\u2019s canvas. You might use this method when animating or moving a canvas controller\u2019s content to or from the left of the screen. \n\n\nSee also: \n\n\nCanvasController.ContentPosition\n \n\n\nCanvasController.content\n \n\n\nCanvasController.canvas\n \n\n\n\n\nOffScreenRightContentPosition\n\n\npublic static Vector3 OffScreenRightContentPosition(this CanvasController canvasController);\n\n\nDescription\n\n\nThe position for the canvas controller\u2019s content that will position it off the right of the screen. \n\n\nThis is calculated using the width of the canvas controller\u2019s canvas. You might use this method when animating or moving a canvas controller\u2019s content to or from the right of the screen. \n\n\nSee also: \n\n\nCanvasController.ContentPosition\n \n\n\nCanvasController.content\n \n\n\nCanvasController.canvas\n \n\n\n\n\nOffScreenTopContentPosition\n\n\npublic static Vector3 OffScreenTopContentPosition(this CanvasController canvasController);\n\n\nDescription\n\n\nThe position for the canvas controller\u2019s content that will position it off the top of the screen. \n\n\nThis is calculated using the height of the canvas controller\u2019s canvas. You might use this method when animating or moving a canvas controller\u2019s content to or from the top of the screen. \n\n\nSee also: \n\n\nCanvasController.ContentPosition\n \n\n\nCanvasController.content\n \n\n\nCanvasController.canvas\n \n\n\n\n\nOnScreenContentPosition\n\n\npublic static Vector3 OnScreenContentPosition(this CanvasController canvasController);\n\n\nDescription\n\n\nThe on-screen position for the canvas controller\u2019s content. \n\n\nYou might use this method when animating or moving a canvas controller\u2019s content. This is always Vector3.zero. \n\n\nSee also: \n\n\nCanvasController.ContentPosition\n \n\n\nCanvasController.content\n \n\n\nCanvasController.canvas\n \n\n\nCanvasController.camera", 
            "title": "CanvasController Extensions"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasControllerExtensions/#canvascontrollerextensions", 
            "text": "public static class CanvasControllerExtensions;", 
            "title": "CanvasControllerExtensions"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasControllerExtensions/#description", 
            "text": "CanvasController  extension methods.      Properties       None         Methods       CanvasRectTransform  The canvas controller\u2019s canvas\u2019  RectTransform  component.    CanvasSize  The canvas controller\u2019s canvas\u2019 size.    CanvasWorldBounds  The canvas controller\u2019s canvas\u2019 bounds in world space.    CanvasWorldCorners  The canvas controller\u2019s canvas\u2019 corners in world space.    CanvasWorldSize  The canvas controller\u2019s canvas\u2019 size in world space. This is the difference between the top right world corner and the bottom left world corner.    IsScreenSpace  Is the canvas controller\u2019s canvas in screen space?    OffScreenBottomContentPosition  The position for the canvas controller\u2019s content that will position it off the bottom of the screen.    OffScreenLeftContentPosition  The position for the canvas controller\u2019s content that will position it off the left of the screen.    OffScreenRightContentPosition  The position for the canvas controller\u2019s content that will position it off the right of the screen.    OffScreenTopContentPosition  The position for the canvas controller\u2019s content that will position it off the top of the screen.    OnScreenContentPosition  The on-screen position for the canvas controller\u2019s content.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasControllerExtensions/#canvasrecttransform", 
            "text": "public static RectTransform CanvasRectTransform(this CanvasController canvasController);", 
            "title": "CanvasRectTransform"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasControllerExtensions/#description_1", 
            "text": "The canvas controller\u2019s canvas\u2019  RectTransform  component.   This is equivalent to calling  canvasController.canvas.GetComponent() .   See also:   CanvasController.canvas", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasControllerExtensions/#canvassize", 
            "text": "public static Vector2 CanvasSize(this CanvasController canvasController);", 
            "title": "CanvasSize"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasControllerExtensions/#description_2", 
            "text": "The canvas controller\u2019s canvas\u2019 size.   This is equivalent to calling  canvasController.CanvasRectTransform().rect.size .   See also:   CanvasController.canvas", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasControllerExtensions/#canvasworldbounds", 
            "text": "public static Bounds CanvasWorldBounds(this CanvasController canvasController);", 
            "title": "CanvasWorldBounds"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasControllerExtensions/#description_3", 
            "text": "The canvas controller\u2019s canvas\u2019 bounds in world space.   You might use this method when doing canvas-related world space calculations. For example, Canvas Flow uses this internally to position canvas controller\u2019s next to one another in world space.   See also:   CanvasController.canvas", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasControllerExtensions/#canvasworldcorners", 
            "text": "public static Vector3[] CanvasWorldCorners(this CanvasController canvasController);", 
            "title": "CanvasWorldCorners"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasControllerExtensions/#description_4", 
            "text": "The canvas controller\u2019s canvas\u2019 corners in world space.   You might use this method when doing canvas-related world space calculations. For example, Canvas Flow uses this internally to position canvas controller\u2019s next to one another in world space.   See also:   CanvasController.canvas", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasControllerExtensions/#canvasworldsize", 
            "text": "public static Vector2 CanvasWorldSize(this CanvasController canvasController);", 
            "title": "CanvasWorldSize"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasControllerExtensions/#description_5", 
            "text": "The canvas controller\u2019s canvas\u2019 size in world space. This is the difference between the top right world corner and the bottom left world corner.   You might use this method when doing canvas-related world space calculations. For example, Canvas Flow uses this internally to position canvas controller\u2019s next to one another in world space.   See also:   CanvasController.canvas", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasControllerExtensions/#isscreenspace", 
            "text": "public static bool IsScreenSpace(this CanvasController canvasController);", 
            "title": "IsScreenSpace"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasControllerExtensions/#description_6", 
            "text": "Is the canvas controller\u2019s canvas in screen space?   Returns  true  if the canvas controller\u2019s canvas is in a screen space render mode.   See also:   CanvasController.canvas", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasControllerExtensions/#offscreenbottomcontentposition", 
            "text": "public static Vector3 OffScreenBottomContentPosition(this CanvasController canvasController);", 
            "title": "OffScreenBottomContentPosition"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasControllerExtensions/#description_7", 
            "text": "The position for the canvas controller\u2019s content that will position it off the bottom of the screen.   This is calculated using the height of the canvas controller\u2019s canvas. You might use this method when animating or moving a canvas controller\u2019s content to or from the bottom of the screen.   See also:   CanvasController.ContentPosition    CanvasController.content    CanvasController.canvas", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasControllerExtensions/#offscreenleftcontentposition", 
            "text": "public static Vector3 OffScreenLeftContentPosition(this CanvasController canvasController);", 
            "title": "OffScreenLeftContentPosition"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasControllerExtensions/#description_8", 
            "text": "The position for the canvas controller\u2019s content that will position it off the left of the screen.   This is calculated using the width of the canvas controller\u2019s canvas. You might use this method when animating or moving a canvas controller\u2019s content to or from the left of the screen.   See also:   CanvasController.ContentPosition    CanvasController.content    CanvasController.canvas", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasControllerExtensions/#offscreenrightcontentposition", 
            "text": "public static Vector3 OffScreenRightContentPosition(this CanvasController canvasController);", 
            "title": "OffScreenRightContentPosition"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasControllerExtensions/#description_9", 
            "text": "The position for the canvas controller\u2019s content that will position it off the right of the screen.   This is calculated using the width of the canvas controller\u2019s canvas. You might use this method when animating or moving a canvas controller\u2019s content to or from the right of the screen.   See also:   CanvasController.ContentPosition    CanvasController.content    CanvasController.canvas", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasControllerExtensions/#offscreentopcontentposition", 
            "text": "public static Vector3 OffScreenTopContentPosition(this CanvasController canvasController);", 
            "title": "OffScreenTopContentPosition"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasControllerExtensions/#description_10", 
            "text": "The position for the canvas controller\u2019s content that will position it off the top of the screen.   This is calculated using the height of the canvas controller\u2019s canvas. You might use this method when animating or moving a canvas controller\u2019s content to or from the top of the screen.   See also:   CanvasController.ContentPosition    CanvasController.content    CanvasController.canvas", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasControllerExtensions/#onscreencontentposition", 
            "text": "public static Vector3 OnScreenContentPosition(this CanvasController canvasController);", 
            "title": "OnScreenContentPosition"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasControllerExtensions/#description_11", 
            "text": "The on-screen position for the canvas controller\u2019s content.   You might use this method when animating or moving a canvas controller\u2019s content. This is always Vector3.zero.   See also:   CanvasController.ContentPosition    CanvasController.content    CanvasController.canvas    CanvasController.camera", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasControllerPresentationMode/", 
            "text": "CanvasControllerPresentationMode\n\n\npublic enum CanvasControllerPresentationMode;\n\n\nDescription\n\n\nThe presentation mode of a canvas controller. \n\n\nWhen a canvas controller is presented, its presentation mode determines what will happen to its presenter once the presentation transition is complete. By default, the presenter is hidden to prevent rendering a canvas that may not be visible, as denoted by the \nHidePresenter\n presentation mode. \n\n\nThe \nKeepPresenterVisible\n presentation mode indicates that the canvas controller\u2019s presenter should not to be hidden. A transparent canvas controller could use this mode to ensure that its presenting canvas controller can still be seen through its transparent canvas. \n\n\n\n\n\n\n\n\nValues\n\n\n\n\n\n\n\n\n\n\n\n\nHidePresenter\n\n\nUpon presentation, hide the canvas controller\u2019s presenter.\n\n\n\n\n\n\nKeepPresenterVisible\n\n\nUpon presentation, keep the canvas controller\u2019s presenter visible.\n\n\n\n\n\n\n\n\n\n\nHidePresenter\n\n\nHidePresenter,\n\n\nDescription\n\n\nUpon presentation, hide the canvas controller\u2019s presenter. \n\n\n\n\nKeepPresenterVisible\n\n\nKeepPresenterVisible\n\n\nDescription\n\n\nUpon presentation, keep the canvas controller\u2019s presenter visible.", 
            "title": "CanvasControllerPresentationMode"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasControllerPresentationMode/#canvascontrollerpresentationmode", 
            "text": "public enum CanvasControllerPresentationMode;", 
            "title": "CanvasControllerPresentationMode"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasControllerPresentationMode/#description", 
            "text": "The presentation mode of a canvas controller.   When a canvas controller is presented, its presentation mode determines what will happen to its presenter once the presentation transition is complete. By default, the presenter is hidden to prevent rendering a canvas that may not be visible, as denoted by the  HidePresenter  presentation mode.   The  KeepPresenterVisible  presentation mode indicates that the canvas controller\u2019s presenter should not to be hidden. A transparent canvas controller could use this mode to ensure that its presenting canvas controller can still be seen through its transparent canvas.      Values       HidePresenter  Upon presentation, hide the canvas controller\u2019s presenter.    KeepPresenterVisible  Upon presentation, keep the canvas controller\u2019s presenter visible.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasControllerPresentationMode/#hidepresenter", 
            "text": "HidePresenter,", 
            "title": "HidePresenter"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasControllerPresentationMode/#description_1", 
            "text": "Upon presentation, hide the canvas controller\u2019s presenter.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasControllerPresentationMode/#keeppresentervisible", 
            "text": "KeepPresenterVisible", 
            "title": "KeepPresenterVisible"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasControllerPresentationMode/#description_2", 
            "text": "Upon presentation, keep the canvas controller\u2019s presenter visible.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasControllerTransitionContext/", 
            "text": "CanvasControllerTransitionContext\n\n\npublic class CanvasControllerTransitionContext;\n\n\nDescription\n\n\nWhen a transition between two canvas controllers occurs, a transition context is created to describe the transition. This context is passed to the transition\u2019s animator to provide the animator with the necessary data in order to carry out the animation. \n\n\nWhen implementing a custom transition animator, you use the context to access the canvas controllers involved in the transition in order to animate them. The \nsourceCanvasController\n is the canvas controller being transitioned from; the \ndestinationCanvasController\n is the canvas controller being transition to. Note that you always transition from the source to the destination. This includes in an upstream transition - a dismissal - in which the source is the canvas controller being dismissed and the destination is the canvas controller being returned to. \n\n\nIn the event that the transition is presenting or dismissing an initial canvas controller, either the context's \nsourceCanvasController\n or  \ndestinationCanvasController\n will be null, depending on whether the transition is upstream - i.e. it is presenting/dismissing to 'nothing'. \n\n\nYou must call \nCompleteTransition\n on the context when your transition animator has completed its animation. This tells Canvas Flow that the custom animation has been performed and to complete the transition. \n\n\nSee also: \n\n\nCanvasControllerTransitioningAnimator\n \n\n\nCanvasController.transitioningAnimatorVendor\n \n\n\n\n\n\n\n\n\nProperties\n\n\n\n\n\n\n\n\n\n\n\n\ndestinationCanvasController\n\n\nThe canvas controller being transitioned to.\n\n\n\n\n\n\nisUpstream\n\n\nIs the transition upstream?\n\n\n\n\n\n\nsourceCanvasController\n\n\nThe canvas controller being transitioned from.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMethods\n\n\n\n\n\n\n\n\n\n\n\n\nCompleteTransition\n\n\nYou must call \nCompleteTransition()\n on the context when your transition animator has completed its animation. This tells Canvas Flow that the custom animation has been performed and to complete the transition.\n\n\n\n\n\n\nDestinationCanvasController\nT\n\n\nThe canvas controller being transitioned to, if it is of type T.\n\n\n\n\n\n\nSourceCanvasController\nT\n\n\nThe canvas controller being transitioned from, if it is of type T.\n\n\n\n\n\n\n\n\n\n\ndestinationCanvasController\n\n\npublic readonly CanvasController destinationCanvasController;\n\n\nDescription\n\n\nThe canvas controller being transitioned to. \n\n\nIn a downstream transition - a presentation - this is the canvas controller being presented. In an upstream transition - a dismissal - this is the canvas controller whom is being dismissed to. \n\n\n\n\nisUpstream\n\n\npublic readonly bool isUpstream;\n\n\nDescription\n\n\nIs the transition upstream? \n\n\nAn upstream transition refers to a dismissal. If \nfalse\n the transition is downstream, which refers to a presentation. You might use this flag to distinguish between an upstream and a downstream transition (a dismissal or a presentation) in your transition animator. \n\n\n\n\nsourceCanvasController\n\n\npublic readonly CanvasController sourceCanvasController;\n\n\nDescription\n\n\nThe canvas controller being transitioned from. \n\n\nIn a downstream transition - a presentation - this is the canvas controller whom is presenting - the presenter. In an upstream transition - a dismissal - this is the canvas controller being dismissed. \n\n\n\n\nCompleteTransition\n\n\npublic void CompleteTransition();\n\n\nDescription\n\n\nYou must call \nCompleteTransition()\n on the context when your transition animator has completed its animation. This tells Canvas Flow that the custom animation has been performed and to complete the transition. \n\n\n\n\nDestinationCanvasController\nT\n\n\npublic T DestinationCanvasController\nT\n()\n    where T : CanvasController;\n\n\nDescription\n\n\nThe canvas controller being transitioned to, if it is of type T. \n\n\nIn a downstream transition - a presentation - this is the canvas controller being presented. In an upstream transition - a dismissal - this is the canvas controller whom is being dismissed to.  If the \ndestinationCanvasController\n is not of type T, returns null. \n\n\n\n\nSourceCanvasController\nT\n\n\npublic T SourceCanvasController\nT\n()\n    where T : CanvasController;\n\n\nDescription\n\n\nThe canvas controller being transitioned from, if it is of type T. \n\n\nIn a downstream transition - a presentation - this is the canvas controller whom is presenting - the presenter. In an upstream transition - a dismissal - this is the canvas controller being dismissed. If the \nsourceCanvasController\n is not of type T, returns null.", 
            "title": "CanvasControllerTransitionContext"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasControllerTransitionContext/#canvascontrollertransitioncontext", 
            "text": "public class CanvasControllerTransitionContext;", 
            "title": "CanvasControllerTransitionContext"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasControllerTransitionContext/#description", 
            "text": "When a transition between two canvas controllers occurs, a transition context is created to describe the transition. This context is passed to the transition\u2019s animator to provide the animator with the necessary data in order to carry out the animation.   When implementing a custom transition animator, you use the context to access the canvas controllers involved in the transition in order to animate them. The  sourceCanvasController  is the canvas controller being transitioned from; the  destinationCanvasController  is the canvas controller being transition to. Note that you always transition from the source to the destination. This includes in an upstream transition - a dismissal - in which the source is the canvas controller being dismissed and the destination is the canvas controller being returned to.   In the event that the transition is presenting or dismissing an initial canvas controller, either the context's  sourceCanvasController  or   destinationCanvasController  will be null, depending on whether the transition is upstream - i.e. it is presenting/dismissing to 'nothing'.   You must call  CompleteTransition  on the context when your transition animator has completed its animation. This tells Canvas Flow that the custom animation has been performed and to complete the transition.   See also:   CanvasControllerTransitioningAnimator    CanvasController.transitioningAnimatorVendor       Properties       destinationCanvasController  The canvas controller being transitioned to.    isUpstream  Is the transition upstream?    sourceCanvasController  The canvas controller being transitioned from.        Methods       CompleteTransition  You must call  CompleteTransition()  on the context when your transition animator has completed its animation. This tells Canvas Flow that the custom animation has been performed and to complete the transition.    DestinationCanvasController T  The canvas controller being transitioned to, if it is of type T.    SourceCanvasController T  The canvas controller being transitioned from, if it is of type T.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasControllerTransitionContext/#destinationcanvascontroller", 
            "text": "public readonly CanvasController destinationCanvasController;", 
            "title": "destinationCanvasController"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasControllerTransitionContext/#description_1", 
            "text": "The canvas controller being transitioned to.   In a downstream transition - a presentation - this is the canvas controller being presented. In an upstream transition - a dismissal - this is the canvas controller whom is being dismissed to.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasControllerTransitionContext/#isupstream", 
            "text": "public readonly bool isUpstream;", 
            "title": "isUpstream"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasControllerTransitionContext/#description_2", 
            "text": "Is the transition upstream?   An upstream transition refers to a dismissal. If  false  the transition is downstream, which refers to a presentation. You might use this flag to distinguish between an upstream and a downstream transition (a dismissal or a presentation) in your transition animator.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasControllerTransitionContext/#sourcecanvascontroller", 
            "text": "public readonly CanvasController sourceCanvasController;", 
            "title": "sourceCanvasController"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasControllerTransitionContext/#description_3", 
            "text": "The canvas controller being transitioned from.   In a downstream transition - a presentation - this is the canvas controller whom is presenting - the presenter. In an upstream transition - a dismissal - this is the canvas controller being dismissed.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasControllerTransitionContext/#completetransition", 
            "text": "public void CompleteTransition();", 
            "title": "CompleteTransition"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasControllerTransitionContext/#description_4", 
            "text": "You must call  CompleteTransition()  on the context when your transition animator has completed its animation. This tells Canvas Flow that the custom animation has been performed and to complete the transition.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasControllerTransitionContext/#destinationcanvascontrollert", 
            "text": "public T DestinationCanvasController T ()\n    where T : CanvasController;", 
            "title": "DestinationCanvasController&lt;T&gt;"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasControllerTransitionContext/#description_5", 
            "text": "The canvas controller being transitioned to, if it is of type T.   In a downstream transition - a presentation - this is the canvas controller being presented. In an upstream transition - a dismissal - this is the canvas controller whom is being dismissed to.  If the  destinationCanvasController  is not of type T, returns null.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasControllerTransitionContext/#sourcecanvascontrollert", 
            "text": "public T SourceCanvasController T ()\n    where T : CanvasController;", 
            "title": "SourceCanvasController&lt;T&gt;"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasControllerTransitionContext/#description_6", 
            "text": "The canvas controller being transitioned from, if it is of type T.   In a downstream transition - a presentation - this is the canvas controller whom is presenting - the presenter. In an upstream transition - a dismissal - this is the canvas controller being dismissed. If the  sourceCanvasController  is not of type T, returns null.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasControllerTransitioningAnimator/", 
            "text": "CanvasControllerTransitioningAnimator\n\n\npublic abstract class CanvasControllerTransitioningAnimator : ScriptableObject,\n    ICanvasControllerTransitioningAnimator;\n\n\nDescription\n\n\nAn abstract base class for a \nScriptableObject\n based implementation of the \nICanvasControllerTransitioningAnimator\n interface. This class is used when creating a new custom transition animator in Unity's 'Create'  menu. \n\n\nSee also: \n\n\nICanvasControllerTransitioningAnimator\n \n\n\n\n\n\n\n\n\nProperties\n\n\n\n\n\n\n\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMethods\n\n\n\n\n\n\n\n\n\n\n\n\nNone", 
            "title": "CanvasControllerTransitioningAnimator"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasControllerTransitioningAnimator/#canvascontrollertransitioninganimator", 
            "text": "public abstract class CanvasControllerTransitioningAnimator : ScriptableObject,\n    ICanvasControllerTransitioningAnimator;", 
            "title": "CanvasControllerTransitioningAnimator"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasControllerTransitioningAnimator/#description", 
            "text": "An abstract base class for a  ScriptableObject  based implementation of the  ICanvasControllerTransitioningAnimator  interface. This class is used when creating a new custom transition animator in Unity's 'Create'  menu.   See also:   ICanvasControllerTransitioningAnimator       Properties       None         Methods       None", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasControllerWorldSpaceContainer/", 
            "text": "CanvasControllerWorldSpaceContainer\n\n\npublic class CanvasControllerWorldSpaceContainer : MonoBehaviour;\n\n\nDescription\n\n\nA world space container for Canvas Controllers. \n\n\nA canvas controller world space container is used to present canvas controllers in world space. You can either create one in your scene and pass it to \nPresentInitialCanvasController\n or set a storyboard's presentation space to \nWorld Space\n, which will create one automatically for you. The world space container gives you a world canvas, allowing you to freely position your container in world space. Subsequently presented canvas controllers (or storyboards) will then be contained, or embedded, within the world canvas. \n\n\n\n\n\n\n\n\nProperties\n\n\n\n\n\n\n\n\n\n\n\n\nmask\n\n\nA rectangular mask used to clip the contents of the world canvas to its rect.\n\n\n\n\n\n\nworldCamera\n\n\nThe camera used to render the world space UI. By default, this will be the scene's main camera.\n\n\n\n\n\n\nworldCanvas\n\n\nThe world canvas within which canvas controllers will be contained, or embedded.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMethods\n\n\n\n\n\n\n\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\n\n\n\n\nmask\n\n\npublic RectMask2D mask;\n\n\nDescription\n\n\nA rectangular mask used to clip the contents of the world canvas to its rect. \n\n\n\n\nworldCamera\n\n\npublic Camera worldCamera;\n\n\nDescription\n\n\nThe camera used to render the world space UI. By default, this will be the scene's main camera. \n\n\n\n\nworldCanvas\n\n\npublic Canvas worldCanvas;\n\n\nDescription\n\n\nThe world canvas within which canvas controllers will be contained, or embedded.", 
            "title": "CanvasControllerWorldSpaceContainer"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasControllerWorldSpaceContainer/#canvascontrollerworldspacecontainer", 
            "text": "public class CanvasControllerWorldSpaceContainer : MonoBehaviour;", 
            "title": "CanvasControllerWorldSpaceContainer"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasControllerWorldSpaceContainer/#description", 
            "text": "A world space container for Canvas Controllers.   A canvas controller world space container is used to present canvas controllers in world space. You can either create one in your scene and pass it to  PresentInitialCanvasController  or set a storyboard's presentation space to  World Space , which will create one automatically for you. The world space container gives you a world canvas, allowing you to freely position your container in world space. Subsequently presented canvas controllers (or storyboards) will then be contained, or embedded, within the world canvas.      Properties       mask  A rectangular mask used to clip the contents of the world canvas to its rect.    worldCamera  The camera used to render the world space UI. By default, this will be the scene's main camera.    worldCanvas  The world canvas within which canvas controllers will be contained, or embedded.        Methods       None", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasControllerWorldSpaceContainer/#mask", 
            "text": "public RectMask2D mask;", 
            "title": "mask"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasControllerWorldSpaceContainer/#description_1", 
            "text": "A rectangular mask used to clip the contents of the world canvas to its rect.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasControllerWorldSpaceContainer/#worldcamera", 
            "text": "public Camera worldCamera;", 
            "title": "worldCamera"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasControllerWorldSpaceContainer/#description_2", 
            "text": "The camera used to render the world space UI. By default, this will be the scene's main camera.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasControllerWorldSpaceContainer/#worldcanvas", 
            "text": "public Canvas worldCanvas;", 
            "title": "worldCanvas"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/CanvasControllerWorldSpaceContainer/#description_3", 
            "text": "The world canvas within which canvas controllers will be contained, or embedded.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/ICanvasControllerTransitioningAnimator/", 
            "text": "ICanvasControllerTransitioningAnimator\n\n\npublic interface ICanvasControllerTransitioningAnimator;\n\n\nDescription\n\n\nThe \nICanvasControllerTransitioningAnimator\n interface defines the methods required to perform a transition animation between two canvas controllers. To implement a custom transition animation, you create an object that implements this interface - a transition animator. You can then provide, or vend, this animator to Canvas Flow via the target canvas controller's \nCanvasController.transitioningAnimatorVendor\n when the relevant transition is triggered. \n\n\nWhen a transition between canvas controllers is to be performed, Canvas Flow will ask the target canvas controller's\n \nCanvasController.transitioningAnimatorVendor\n for an animator. This is where you can return, or vend, your custom animator. Your animator will then have the appropriate \nAnimateTransition\n method called, where you can perform your transition animation. Please refer to the included transition animators' source code for examples of animating the transition. These can be found in \nCanvas Flow/Transition Animators*. \n\n\nThe recommended way to create a custom transition animator, as documented in the manual, is to use the menu item in the Unity Editor at \nAssets/Create/Canvas Flow/Custom Transition Animator\n. This creates a \nCanvasControllerTransitioningAnimator\n, which is derived from \nScriptableObject\n so it can be used in storyboards, be referenced in the Unity Editor, provide easily tweakable properties, and support having multiple instances. However, you may provide any object that implements this interface as an animator. \n\n\nOnce your transition animator has completed its animation, you must call \nCanvasControllerTransitionContext.CompleteTransition\n on the provided transition context. This tells Canvas Flow that the custom animation has been performed and to complete the transition. * The target canvas controller is the canvas controller being acted upon - i.e. the canvas controler being presented or being dismissed. Therefore, in a downstream transition - a presentation, this will be the \nCanvasControllerTransitionContext.destinationCanvasController\n , whereas in an upstream transition - a dismissal, this will be the \nCanvasControllerTransitionContext.sourceCanvasController\n. \n\n\nSee also: \n\n\nCanvasControllerTransitioningAnimator\n \n\n\nCanvasControllerTransitionContext\n \n\n\nCanvasController.transitioningAnimatorVendor\n \n\n\nRoutine\n \n\n\nCanvasControllerExtensions\n \n\n\nDynamicObjectExtensions\n \n\n\n\n\n\n\n\n\nProperties\n\n\n\n\n\n\n\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMethods\n\n\n\n\n\n\n\n\n\n\n\n\nAnimateTransition\n\n\nPerform your transition animation with the \ntransitionContext\n's canvas controllers.\n\n\n\n\n\n\nAnimateTransitionForInitialCanvasController\n\n\nPerform your transition animation for an initial canvas controller.\n\n\n\n\n\n\n\n\n\n\nAnimateTransition\n\n\nvoid AnimateTransition(CanvasControllerTransitionContext transitionContext);\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntransitionContext\n\n\nThe transition's context, which provides information about the transition such as the canvas controllers involved.\n\n\n\n\n\n\n\n\nDescription\n\n\nPerform your transition animation with the \ntransitionContext\n's canvas controllers. \n\n\nNote that you must call \nCanvasControllerTransitionContext.CompleteTransition\n on the provided transition context when your transition animator has completed its animation. This tells Canvas Flow that the custom animation has been performed and to complete the transition. \n\n\n\n\nAnimateTransitionForInitialCanvasController\n\n\nvoid AnimateTransitionForInitialCanvasController(\n    CanvasControllerTransitionContext transitionContext);\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntransitionContext\n\n\nThe transition's context, which provides information about the transition such as the canvas controllers involved.\n\n\n\n\n\n\n\n\nDescription\n\n\nPerform your transition animation for an initial canvas controller. \n\n\nCanvas Flow will call this method on a transition animator instead of \nAnimateTransition\n when the transition is presenting or dismissing an initial canvas controller. An initial canvas controller is one with no presenter - i.e. it was the first canvas controller presented, perhaps from a storyboard entry transition or using \nCanvasController.PresentInitialCanvasController\n. The only  difference from the \nAnimateTransition\n method is that either the context's \nsourceCanvasController\n or \ndestinationCanvasController\n will be null, depending on whether the transition is upstream - i.e. it is presenting/dismissing to 'nothing'. \n\n\nNote that you must call \nCanvasControllerTransitionContext.CompleteTransition\n on the provided transition context when your transition animator has completed its animation. This tells Canvas Flow that the custom animation has been performed and to complete the transition.", 
            "title": "ICanvasControllerTransitioningAnimator"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/ICanvasControllerTransitioningAnimator/#icanvascontrollertransitioninganimator", 
            "text": "public interface ICanvasControllerTransitioningAnimator;", 
            "title": "ICanvasControllerTransitioningAnimator"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/ICanvasControllerTransitioningAnimator/#description", 
            "text": "The  ICanvasControllerTransitioningAnimator  interface defines the methods required to perform a transition animation between two canvas controllers. To implement a custom transition animation, you create an object that implements this interface - a transition animator. You can then provide, or vend, this animator to Canvas Flow via the target canvas controller's  CanvasController.transitioningAnimatorVendor  when the relevant transition is triggered.   When a transition between canvas controllers is to be performed, Canvas Flow will ask the target canvas controller's   CanvasController.transitioningAnimatorVendor  for an animator. This is where you can return, or vend, your custom animator. Your animator will then have the appropriate  AnimateTransition  method called, where you can perform your transition animation. Please refer to the included transition animators' source code for examples of animating the transition. These can be found in  Canvas Flow/Transition Animators*.   The recommended way to create a custom transition animator, as documented in the manual, is to use the menu item in the Unity Editor at  Assets/Create/Canvas Flow/Custom Transition Animator . This creates a  CanvasControllerTransitioningAnimator , which is derived from  ScriptableObject  so it can be used in storyboards, be referenced in the Unity Editor, provide easily tweakable properties, and support having multiple instances. However, you may provide any object that implements this interface as an animator.   Once your transition animator has completed its animation, you must call  CanvasControllerTransitionContext.CompleteTransition  on the provided transition context. This tells Canvas Flow that the custom animation has been performed and to complete the transition. * The target canvas controller is the canvas controller being acted upon - i.e. the canvas controler being presented or being dismissed. Therefore, in a downstream transition - a presentation, this will be the  CanvasControllerTransitionContext.destinationCanvasController  , whereas in an upstream transition - a dismissal, this will be the  CanvasControllerTransitionContext.sourceCanvasController .   See also:   CanvasControllerTransitioningAnimator    CanvasControllerTransitionContext    CanvasController.transitioningAnimatorVendor    Routine    CanvasControllerExtensions    DynamicObjectExtensions       Properties       None         Methods       AnimateTransition  Perform your transition animation with the  transitionContext 's canvas controllers.    AnimateTransitionForInitialCanvasController  Perform your transition animation for an initial canvas controller.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/ICanvasControllerTransitioningAnimator/#animatetransition", 
            "text": "void AnimateTransition(CanvasControllerTransitionContext transitionContext);", 
            "title": "AnimateTransition"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/ICanvasControllerTransitioningAnimator/#parameters", 
            "text": "Name  Description      transitionContext  The transition's context, which provides information about the transition such as the canvas controllers involved.", 
            "title": "Parameters"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/ICanvasControllerTransitioningAnimator/#description_1", 
            "text": "Perform your transition animation with the  transitionContext 's canvas controllers.   Note that you must call  CanvasControllerTransitionContext.CompleteTransition  on the provided transition context when your transition animator has completed its animation. This tells Canvas Flow that the custom animation has been performed and to complete the transition.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/ICanvasControllerTransitioningAnimator/#animatetransitionforinitialcanvascontroller", 
            "text": "void AnimateTransitionForInitialCanvasController(\n    CanvasControllerTransitionContext transitionContext);", 
            "title": "AnimateTransitionForInitialCanvasController"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/ICanvasControllerTransitioningAnimator/#parameters_1", 
            "text": "Name  Description      transitionContext  The transition's context, which provides information about the transition such as the canvas controllers involved.", 
            "title": "Parameters"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/ICanvasControllerTransitioningAnimator/#description_2", 
            "text": "Perform your transition animation for an initial canvas controller.   Canvas Flow will call this method on a transition animator instead of  AnimateTransition  when the transition is presenting or dismissing an initial canvas controller. An initial canvas controller is one with no presenter - i.e. it was the first canvas controller presented, perhaps from a storyboard entry transition or using  CanvasController.PresentInitialCanvasController . The only  difference from the  AnimateTransition  method is that either the context's  sourceCanvasController  or  destinationCanvasController  will be null, depending on whether the transition is upstream - i.e. it is presenting/dismissing to 'nothing'.   Note that you must call  CanvasControllerTransitionContext.CompleteTransition  on the provided transition context when your transition animator has completed its animation. This tells Canvas Flow that the custom animation has been performed and to complete the transition.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/ICanvasControllerTransitioningAnimatorVendor/", 
            "text": "ICanvasControllerTransitioningAnimatorVendor\n\n\npublic interface ICanvasControllerTransitioningAnimatorVendor;\n\n\nDescription\n\n\nThe \nICanvasControllerTransitioningAnimatorVendor\n interface defines the methods required to supply transition animators to a transitioning canvas controller. \n\n\nWhen a canvas controller is about to be presented or dismissed, it will ask its \nCanvasController.transitioningAnimatorVendor\n for an animator to animate the transition. The vendor returns an \nICanvasControllerTransitioningAnimator\n object that will be used to animate the transition. Different animators may be returned depending on the values of the \nCanvasControllerTransitionContext\n parameter. The vendor may return \nnull\n to have the transition be animated by the default animator. \n\n\nSee also: \n\n\nICanvasControllerTransitioningAnimator\n \n\n\nCanvasControllerTransitionContext\n \n\n\n\n\n\n\n\n\nProperties\n\n\n\n\n\n\n\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMethods\n\n\n\n\n\n\n\n\n\n\n\n\nTransitioningAnimatorForContext\n\n\nReturn the transition animator that will be used to animate the transition. You may return \nnull\n to have the transition be animated by the default animator.\n\n\n\n\n\n\n\n\n\n\nTransitioningAnimatorForContext\n\n\nICanvasControllerTransitioningAnimator TransitioningAnimatorForContext(\n    CanvasControllerTransitionContext transitionContext);\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntransitionContext\n\n\nThe transition's context, which provides information about the transition such as the canvas controllers involved.\n\n\n\n\n\n\n\n\nDescription\n\n\nReturn the transition animator that will be used to animate the transition. You may return \nnull\n to have the transition be animated by the default animator.", 
            "title": "ICanvasControllerTransitioningAnimatorVendor"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/ICanvasControllerTransitioningAnimatorVendor/#icanvascontrollertransitioninganimatorvendor", 
            "text": "public interface ICanvasControllerTransitioningAnimatorVendor;", 
            "title": "ICanvasControllerTransitioningAnimatorVendor"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/ICanvasControllerTransitioningAnimatorVendor/#description", 
            "text": "The  ICanvasControllerTransitioningAnimatorVendor  interface defines the methods required to supply transition animators to a transitioning canvas controller.   When a canvas controller is about to be presented or dismissed, it will ask its  CanvasController.transitioningAnimatorVendor  for an animator to animate the transition. The vendor returns an  ICanvasControllerTransitioningAnimator  object that will be used to animate the transition. Different animators may be returned depending on the values of the  CanvasControllerTransitionContext  parameter. The vendor may return  null  to have the transition be animated by the default animator.   See also:   ICanvasControllerTransitioningAnimator    CanvasControllerTransitionContext       Properties       None         Methods       TransitioningAnimatorForContext  Return the transition animator that will be used to animate the transition. You may return  null  to have the transition be animated by the default animator.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/ICanvasControllerTransitioningAnimatorVendor/#transitioninganimatorforcontext", 
            "text": "ICanvasControllerTransitioningAnimator TransitioningAnimatorForContext(\n    CanvasControllerTransitionContext transitionContext);", 
            "title": "TransitioningAnimatorForContext"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/ICanvasControllerTransitioningAnimatorVendor/#parameters", 
            "text": "Name  Description      transitionContext  The transition's context, which provides information about the transition such as the canvas controllers involved.", 
            "title": "Parameters"
        }, 
        {
            "location": "/scripting-reference/canvas-controller/ICanvasControllerTransitioningAnimatorVendor/#description_1", 
            "text": "Return the transition animator that will be used to animate the transition. You may return  null  to have the transition be animated by the default animator.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/storyboards/Storyboard/", 
            "text": "Storyboard\n\n\npublic class Storyboard : MonoBehaviour, IStoryboardNodeResponder;\n\n\nDescription\n\n\nA storyboard component used to present a storyboard in the scene. \n\n\n\n\n\n\n\n\nProperties\n\n\n\n\n\n\n\n\n\n\n\n\nautomaticPresentationMode\n\n\nThe automatic presentation mode of the storyboard component. Can be one of \nPresentOnAwake\n, \nPresentOnStart\n, or \nDontPresentAutomatically\n.\n\n\n\n\n\n\npresentationSpace\n\n\nThe presentation space in which the storyboard will be presented. Can be either \nScreenSpace\n or \nWorldSpace\n.\n\n\n\n\n\n\nstoryboard\n\n\nThe storyboard asset.\n\n\n\n\n\n\nStoryboardWillDismiss\n\n\nA UnityEvent that is triggered when the storyboard is about to perform its exit transition, i.e. dismiss its initial canvas controller.\n\n\n\n\n\n\nStoryboardWillPerformTransition\n\n\nA UnityEvent that is triggered when the storyboard is about to perform a transition, excluding its initial/entry transition.\n\n\n\n\n\n\nStoryboardWillPresentInitialCanvasController\n\n\nA UnityEvent that is triggered when the storyboard is about to perform its entry transition, i.e. present its initial canvas controller.\n\n\n\n\n\n\nworldSpaceContainer\n\n\nWhen set to \nStoryboardPresentationSpace.WorldSpace\n, the world space container specifies the world canvas in which the subsequently loaded canvas controllers will be contained.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMethods\n\n\n\n\n\n\n\n\n\n\n\n\nPresent\n\n\nPresent the storyboard manually.\n\n\n\n\n\n\n\n\n\n\nautomaticPresentationMode\n\n\npublic AutomaticPresentationMode automaticPresentationMode =\n    AutomaticPresentationMode.PresentOnAwake;\n\n\nDescription\n\n\nThe automatic presentation mode of the storyboard component. Can be one of \nPresentOnAwake\n, \nPresentOnStart\n, or \nDontPresentAutomatically\n. \n\n\n\n\npresentationSpace\n\n\npublic StoryboardPresentationSpace presentationSpace;\n\n\nDescription\n\n\nThe presentation space in which the storyboard will be presented. Can be either \nScreenSpace\n or \nWorldSpace\n. \n\n\n\n\nstoryboard\n\n\npublic StoryboardData storyboard;\n\n\nDescription\n\n\nThe storyboard asset. \n\n\n\n\nStoryboardWillDismiss\n\n\npublic StoryboardTransitionEvent StoryboardWillDismiss;\n\n\nDescription\n\n\nA UnityEvent that is triggered when the storyboard is about to perform its exit transition, i.e. dismiss its initial canvas controller. \n\n\nThis event receives a \nStoryboardTransition\n for the transition to be performed. Therefore, the required method signature to use this event is \npublic void yourMethodName(StoryboardTransition transition)\n. \n\n\n\n\nStoryboardWillPerformTransition\n\n\npublic StoryboardTransitionEvent StoryboardWillPerformTransition;\n\n\nDescription\n\n\nA UnityEvent that is triggered when the storyboard is about to perform a transition, excluding its initial/entry transition. \n\n\nThis event receives a \nStoryboardTransition\n for the transition to be performed. Therefore, the required method signature to use this event is \npublic void yourMethodName(StoryboardTransition transition)\n. \n\n\n\n\nStoryboardWillPresentInitialCanvasController\n\n\npublic StoryboardTransitionEvent StoryboardWillPresentInitialCanvasController;\n\n\nDescription\n\n\nA UnityEvent that is triggered when the storyboard is about to perform its entry transition, i.e. present its initial canvas controller. \n\n\nThis event receives a \nStoryboardTransition\n for the transition to be performed. Therefore, the required method signature to use this event is \npublic void yourMethodName(StoryboardTransition transition)\n. \n\n\n\n\nworldSpaceContainer\n\n\npublic CanvasControllerWorldSpaceContainer worldSpaceContainer;\n\n\nDescription\n\n\nWhen set to \nStoryboardPresentationSpace.WorldSpace\n, the world space container specifies the world canvas in which the subsequently loaded canvas controllers will be contained. \n\n\n\n\nPresent\n\n\npublic void Present();\n\n\nDescription\n\n\nPresent the storyboard manually. \n\n\nThis can be used in conjunction with \nautomaticPresentationMode\n to present the storyboard manually.", 
            "title": "Storyboard"
        }, 
        {
            "location": "/scripting-reference/storyboards/Storyboard/#storyboard", 
            "text": "public class Storyboard : MonoBehaviour, IStoryboardNodeResponder;", 
            "title": "Storyboard"
        }, 
        {
            "location": "/scripting-reference/storyboards/Storyboard/#description", 
            "text": "A storyboard component used to present a storyboard in the scene.      Properties       automaticPresentationMode  The automatic presentation mode of the storyboard component. Can be one of  PresentOnAwake ,  PresentOnStart , or  DontPresentAutomatically .    presentationSpace  The presentation space in which the storyboard will be presented. Can be either  ScreenSpace  or  WorldSpace .    storyboard  The storyboard asset.    StoryboardWillDismiss  A UnityEvent that is triggered when the storyboard is about to perform its exit transition, i.e. dismiss its initial canvas controller.    StoryboardWillPerformTransition  A UnityEvent that is triggered when the storyboard is about to perform a transition, excluding its initial/entry transition.    StoryboardWillPresentInitialCanvasController  A UnityEvent that is triggered when the storyboard is about to perform its entry transition, i.e. present its initial canvas controller.    worldSpaceContainer  When set to  StoryboardPresentationSpace.WorldSpace , the world space container specifies the world canvas in which the subsequently loaded canvas controllers will be contained.        Methods       Present  Present the storyboard manually.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/storyboards/Storyboard/#automaticpresentationmode", 
            "text": "public AutomaticPresentationMode automaticPresentationMode =\n    AutomaticPresentationMode.PresentOnAwake;", 
            "title": "automaticPresentationMode"
        }, 
        {
            "location": "/scripting-reference/storyboards/Storyboard/#description_1", 
            "text": "The automatic presentation mode of the storyboard component. Can be one of  PresentOnAwake ,  PresentOnStart , or  DontPresentAutomatically .", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/storyboards/Storyboard/#presentationspace", 
            "text": "public StoryboardPresentationSpace presentationSpace;", 
            "title": "presentationSpace"
        }, 
        {
            "location": "/scripting-reference/storyboards/Storyboard/#description_2", 
            "text": "The presentation space in which the storyboard will be presented. Can be either  ScreenSpace  or  WorldSpace .", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/storyboards/Storyboard/#storyboard_1", 
            "text": "public StoryboardData storyboard;", 
            "title": "storyboard"
        }, 
        {
            "location": "/scripting-reference/storyboards/Storyboard/#description_3", 
            "text": "The storyboard asset.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/storyboards/Storyboard/#storyboardwilldismiss", 
            "text": "public StoryboardTransitionEvent StoryboardWillDismiss;", 
            "title": "StoryboardWillDismiss"
        }, 
        {
            "location": "/scripting-reference/storyboards/Storyboard/#description_4", 
            "text": "A UnityEvent that is triggered when the storyboard is about to perform its exit transition, i.e. dismiss its initial canvas controller.   This event receives a  StoryboardTransition  for the transition to be performed. Therefore, the required method signature to use this event is  public void yourMethodName(StoryboardTransition transition) .", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/storyboards/Storyboard/#storyboardwillperformtransition", 
            "text": "public StoryboardTransitionEvent StoryboardWillPerformTransition;", 
            "title": "StoryboardWillPerformTransition"
        }, 
        {
            "location": "/scripting-reference/storyboards/Storyboard/#description_5", 
            "text": "A UnityEvent that is triggered when the storyboard is about to perform a transition, excluding its initial/entry transition.   This event receives a  StoryboardTransition  for the transition to be performed. Therefore, the required method signature to use this event is  public void yourMethodName(StoryboardTransition transition) .", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/storyboards/Storyboard/#storyboardwillpresentinitialcanvascontroller", 
            "text": "public StoryboardTransitionEvent StoryboardWillPresentInitialCanvasController;", 
            "title": "StoryboardWillPresentInitialCanvasController"
        }, 
        {
            "location": "/scripting-reference/storyboards/Storyboard/#description_6", 
            "text": "A UnityEvent that is triggered when the storyboard is about to perform its entry transition, i.e. present its initial canvas controller.   This event receives a  StoryboardTransition  for the transition to be performed. Therefore, the required method signature to use this event is  public void yourMethodName(StoryboardTransition transition) .", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/storyboards/Storyboard/#worldspacecontainer", 
            "text": "public CanvasControllerWorldSpaceContainer worldSpaceContainer;", 
            "title": "worldSpaceContainer"
        }, 
        {
            "location": "/scripting-reference/storyboards/Storyboard/#description_7", 
            "text": "When set to  StoryboardPresentationSpace.WorldSpace , the world space container specifies the world canvas in which the subsequently loaded canvas controllers will be contained.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/storyboards/Storyboard/#present", 
            "text": "public void Present();", 
            "title": "Present"
        }, 
        {
            "location": "/scripting-reference/storyboards/Storyboard/#description_8", 
            "text": "Present the storyboard manually.   This can be used in conjunction with  automaticPresentationMode  to present the storyboard manually.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/storyboards/StoryboardData/", 
            "text": "StoryboardData\n\n\npublic class StoryboardData : ScriptableObject;\n\n\nDescription\n\n\nA storyboard asset file containg all of a storyboard's data. \n\n\n\n\n\n\n\n\nProperties\n\n\n\n\n\n\n\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMethods\n\n\n\n\n\n\n\n\n\n\n\n\nNone", 
            "title": "StoryboardData"
        }, 
        {
            "location": "/scripting-reference/storyboards/StoryboardData/#storyboarddata", 
            "text": "public class StoryboardData : ScriptableObject;", 
            "title": "StoryboardData"
        }, 
        {
            "location": "/scripting-reference/storyboards/StoryboardData/#description", 
            "text": "A storyboard asset file containg all of a storyboard's data.      Properties       None         Methods       None", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/storyboards/StoryboardPresentationSpace/", 
            "text": "StoryboardPresentationSpace\n\n\npublic enum StoryboardPresentationSpace;\n\n\nDescription\n\n\nThe presentation space of a storyboard. \n\n\n\n\n\n\n\n\nValues\n\n\n\n\n\n\n\n\n\n\n\n\nScreenSpace\n\n\nThe storyboard will be presented in screen space.\n\n\n\n\n\n\nWorldSpace\n\n\nThe storyboard will be presented in world space.\n\n\n\n\n\n\n\n\n\n\nScreenSpace\n\n\nScreenSpace,\n\n\nDescription\n\n\nThe storyboard will be presented in screen space. \n\n\n\n\nWorldSpace\n\n\nWorldSpace\n\n\nDescription\n\n\nThe storyboard will be presented in world space.", 
            "title": "StoryboardPresentationSpace"
        }, 
        {
            "location": "/scripting-reference/storyboards/StoryboardPresentationSpace/#storyboardpresentationspace", 
            "text": "public enum StoryboardPresentationSpace;", 
            "title": "StoryboardPresentationSpace"
        }, 
        {
            "location": "/scripting-reference/storyboards/StoryboardPresentationSpace/#description", 
            "text": "The presentation space of a storyboard.      Values       ScreenSpace  The storyboard will be presented in screen space.    WorldSpace  The storyboard will be presented in world space.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/storyboards/StoryboardPresentationSpace/#screenspace", 
            "text": "ScreenSpace,", 
            "title": "ScreenSpace"
        }, 
        {
            "location": "/scripting-reference/storyboards/StoryboardPresentationSpace/#description_1", 
            "text": "The storyboard will be presented in screen space.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/storyboards/StoryboardPresentationSpace/#worldspace", 
            "text": "WorldSpace", 
            "title": "WorldSpace"
        }, 
        {
            "location": "/scripting-reference/storyboards/StoryboardPresentationSpace/#description_2", 
            "text": "The storyboard will be presented in world space.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/storyboards/hooks/StoryboardHook/", 
            "text": "StoryboardHook\n\n\npublic abstract class StoryboardHook : MonoBehaviour;\n\n\nDescription\n\n\nA storyboard hook component is attached to game objects to make them \nhookable\n in the storyboard editor. \n\n\nA \nStoryboardTransition\n will contain a reference to the storyboard hook component whom triggered it. You could use this reference to access the hook itself, as well as any other components on the hook's game object. This class is not used directly. It is derived from to create custom storyboard hooks, as documented in the manual. \n\n\n\n\n\n\n\n\nProperties\n\n\n\n\n\n\n\n\n\n\n\n\nAutoAddComponentType\n\n\nOverride to specify the component type to which this hook should be automatically added.\n\n\n\n\n\n\nIdentifier\n\n\nThe hook's unique identifier.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMethods\n\n\n\n\n\n\n\n\n\n\n\n\nCalculateRect01\n\n\nA normalized rect used to position the hook element within the canvas preview area of the node view in the storyboard editor.\n\n\n\n\n\n\nConnect\n\n\nOverride to attach the provided callback to your storyboard hook.\n\n\n\n\n\n\n\n\n\n\nAutoAddComponentType\n\n\npublic virtual System.Type AutoAddComponentType;\n\n\nDescription\n\n\nOverride to specify the component type to which this hook should be automatically added. \n\n\nWhen a canvas controller scene is saved in the Editor, Canvas Flow will ensure that storyboard hooks are present on any game objects with the hook's 'auto-add' component type. Here you can return the target type of your hook, such as your custom button type, to have your hook automatically added to any game objects with the target component type. \n\n\n\n\nIdentifier\n\n\npublic string Identifier;\n\n\nDescription\n\n\nThe hook's unique identifier. \n\n\n\n\nCalculateRect01\n\n\npublic virtual Rect CalculateRect01();\n\n\nDescription\n\n\nA normalized rect used to position the hook element within the canvas preview area of the node view in the storyboard editor. \n\n\nThis method is invoked by Canvas Flow in the Editor when laying out a node's hooks in the storyboard editor. The default implementation of this method calculates the relative position of the hook's \nRectTransform\n component to its highest parent canvas. You may override it to specify a custom implementation. \n\n\n\n\nConnect\n\n\npublic abstract void Connect(System.Action\nStoryboardHook\n invokeTransition);\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ninvokeTransition\n\n\nInvoke transition.\n\n\n\n\n\n\n\n\nDescription\n\n\nOverride to attach the provided callback to your storyboard hook. \n\n\nWhen a canvas controller is loaded from a storyboard at runtime, its connected hooks will be provided with a callback via the \nConnect()\n method. Your hook's responsibility is to simply invoke this callback when it deems itself to have been triggered. Invoking the provided callback is all that is required to trigger a storyboard transition.", 
            "title": "StoryboardHook"
        }, 
        {
            "location": "/scripting-reference/storyboards/hooks/StoryboardHook/#storyboardhook", 
            "text": "public abstract class StoryboardHook : MonoBehaviour;", 
            "title": "StoryboardHook"
        }, 
        {
            "location": "/scripting-reference/storyboards/hooks/StoryboardHook/#description", 
            "text": "A storyboard hook component is attached to game objects to make them  hookable  in the storyboard editor.   A  StoryboardTransition  will contain a reference to the storyboard hook component whom triggered it. You could use this reference to access the hook itself, as well as any other components on the hook's game object. This class is not used directly. It is derived from to create custom storyboard hooks, as documented in the manual.      Properties       AutoAddComponentType  Override to specify the component type to which this hook should be automatically added.    Identifier  The hook's unique identifier.        Methods       CalculateRect01  A normalized rect used to position the hook element within the canvas preview area of the node view in the storyboard editor.    Connect  Override to attach the provided callback to your storyboard hook.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/storyboards/hooks/StoryboardHook/#autoaddcomponenttype", 
            "text": "public virtual System.Type AutoAddComponentType;", 
            "title": "AutoAddComponentType"
        }, 
        {
            "location": "/scripting-reference/storyboards/hooks/StoryboardHook/#description_1", 
            "text": "Override to specify the component type to which this hook should be automatically added.   When a canvas controller scene is saved in the Editor, Canvas Flow will ensure that storyboard hooks are present on any game objects with the hook's 'auto-add' component type. Here you can return the target type of your hook, such as your custom button type, to have your hook automatically added to any game objects with the target component type.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/storyboards/hooks/StoryboardHook/#identifier", 
            "text": "public string Identifier;", 
            "title": "Identifier"
        }, 
        {
            "location": "/scripting-reference/storyboards/hooks/StoryboardHook/#description_2", 
            "text": "The hook's unique identifier.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/storyboards/hooks/StoryboardHook/#calculaterect01", 
            "text": "public virtual Rect CalculateRect01();", 
            "title": "CalculateRect01"
        }, 
        {
            "location": "/scripting-reference/storyboards/hooks/StoryboardHook/#description_3", 
            "text": "A normalized rect used to position the hook element within the canvas preview area of the node view in the storyboard editor.   This method is invoked by Canvas Flow in the Editor when laying out a node's hooks in the storyboard editor. The default implementation of this method calculates the relative position of the hook's  RectTransform  component to its highest parent canvas. You may override it to specify a custom implementation.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/storyboards/hooks/StoryboardHook/#connect", 
            "text": "public abstract void Connect(System.Action StoryboardHook  invokeTransition);", 
            "title": "Connect"
        }, 
        {
            "location": "/scripting-reference/storyboards/hooks/StoryboardHook/#parameters", 
            "text": "Name  Description      invokeTransition  Invoke transition.", 
            "title": "Parameters"
        }, 
        {
            "location": "/scripting-reference/storyboards/hooks/StoryboardHook/#description_4", 
            "text": "Override to attach the provided callback to your storyboard hook.   When a canvas controller is loaded from a storyboard at runtime, its connected hooks will be provided with a callback via the  Connect()  method. Your hook's responsibility is to simply invoke this callback when it deems itself to have been triggered. Invoking the provided callback is all that is required to trigger a storyboard transition.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/storyboards/StoryboardTransition/", 
            "text": "StoryboardTransition\n\n\npublic class StoryboardTransition;\n\n\nDescription\n\n\nA \nStoryboardTransition\n object is created at runtime when a transition in a storyboard is invoked. This object can be used to infer information about the transition, such as the canvas controllers involved, the \ndirection\n of the transition, whether the transition is \nanimated\n, as well as the \ninvokedHook\n that triggered the transition. \n\n\n\n\n\n\n\n\nProperties\n\n\n\n\n\n\n\n\n\n\n\n\nanimated\n\n\nIs the transition animated?\n\n\n\n\n\n\ndirection\n\n\nThe direction of the transition.\n\n\n\n\n\n\ninvokedHook\n\n\nThe \nStoryboardHook\n that triggered this transition.\n\n\n\n\n\n\npresentationMode\n\n\nThe presentation mode of the presented canvas controller.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMethods\n\n\n\n\n\n\n\n\n\n\n\n\nDestinationCanvasController\n\n\nThe transition's destination canvas controller.\n\n\n\n\n\n\nDestinationCanvasController\nT\n\n\nThe transition's destination canvas controller, if it is of type T.\n\n\n\n\n\n\nSourceCanvasController\n\n\nThe transition's source canvas controller.\n\n\n\n\n\n\nSourceCanvasController\nT\n\n\nThe transition's source canvas controller, if it is of type T.\n\n\n\n\n\n\n\n\n\n\nanimated\n\n\npublic readonly bool animated;\n\n\nDescription\n\n\nIs the transition animated? \n\n\n\n\ndirection\n\n\npublic readonly StoryboardTransitionDirection direction;\n\n\nDescription\n\n\nThe direction of the transition. \n\n\n\n\ninvokedHook\n\n\npublic readonly StoryboardHook invokedHook;\n\n\nDescription\n\n\nThe \nStoryboardHook\n that triggered this transition. \n\n\nIf the transition was invoked manually with \nCanvasController.PerformTransitionWithIdentifier\n, this will be null. \n\n\n\n\npresentationMode\n\n\npublic readonly CanvasControllerPresentationMode presentationMode;\n\n\nDescription\n\n\nThe presentation mode of the presented canvas controller. \n\n\n\n\nDestinationCanvasController\n\n\npublic CanvasController DestinationCanvasController();\n\n\nDescription\n\n\nThe transition's destination canvas controller. \n\n\n\n\nDestinationCanvasController\nT\n\n\npublic T DestinationCanvasController\nT\n()\n    where T : CanvasController;\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nT\n\n\nThe type to cast the destination canvas controller to.\n\n\n\n\n\n\n\n\nDescription\n\n\nThe transition's destination canvas controller, if it is of type T. \n\n\n\n\nSourceCanvasController\n\n\npublic CanvasController SourceCanvasController();\n\n\nDescription\n\n\nThe transition's source canvas controller. \n\n\n\n\nSourceCanvasController\nT\n\n\npublic T SourceCanvasController\nT\n()\n    where T : CanvasController;\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nT\n\n\nThe type to cast the source canvas controller to.\n\n\n\n\n\n\n\n\nDescription\n\n\nThe transition's source canvas controller, if it is of type T.", 
            "title": "StoryboardTransition"
        }, 
        {
            "location": "/scripting-reference/storyboards/StoryboardTransition/#storyboardtransition", 
            "text": "public class StoryboardTransition;", 
            "title": "StoryboardTransition"
        }, 
        {
            "location": "/scripting-reference/storyboards/StoryboardTransition/#description", 
            "text": "A  StoryboardTransition  object is created at runtime when a transition in a storyboard is invoked. This object can be used to infer information about the transition, such as the canvas controllers involved, the  direction  of the transition, whether the transition is  animated , as well as the  invokedHook  that triggered the transition.      Properties       animated  Is the transition animated?    direction  The direction of the transition.    invokedHook  The  StoryboardHook  that triggered this transition.    presentationMode  The presentation mode of the presented canvas controller.        Methods       DestinationCanvasController  The transition's destination canvas controller.    DestinationCanvasController T  The transition's destination canvas controller, if it is of type T.    SourceCanvasController  The transition's source canvas controller.    SourceCanvasController T  The transition's source canvas controller, if it is of type T.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/storyboards/StoryboardTransition/#animated", 
            "text": "public readonly bool animated;", 
            "title": "animated"
        }, 
        {
            "location": "/scripting-reference/storyboards/StoryboardTransition/#description_1", 
            "text": "Is the transition animated?", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/storyboards/StoryboardTransition/#direction", 
            "text": "public readonly StoryboardTransitionDirection direction;", 
            "title": "direction"
        }, 
        {
            "location": "/scripting-reference/storyboards/StoryboardTransition/#description_2", 
            "text": "The direction of the transition.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/storyboards/StoryboardTransition/#invokedhook", 
            "text": "public readonly StoryboardHook invokedHook;", 
            "title": "invokedHook"
        }, 
        {
            "location": "/scripting-reference/storyboards/StoryboardTransition/#description_3", 
            "text": "The  StoryboardHook  that triggered this transition.   If the transition was invoked manually with  CanvasController.PerformTransitionWithIdentifier , this will be null.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/storyboards/StoryboardTransition/#presentationmode", 
            "text": "public readonly CanvasControllerPresentationMode presentationMode;", 
            "title": "presentationMode"
        }, 
        {
            "location": "/scripting-reference/storyboards/StoryboardTransition/#description_4", 
            "text": "The presentation mode of the presented canvas controller.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/storyboards/StoryboardTransition/#destinationcanvascontroller", 
            "text": "public CanvasController DestinationCanvasController();", 
            "title": "DestinationCanvasController"
        }, 
        {
            "location": "/scripting-reference/storyboards/StoryboardTransition/#description_5", 
            "text": "The transition's destination canvas controller.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/storyboards/StoryboardTransition/#destinationcanvascontrollert", 
            "text": "public T DestinationCanvasController T ()\n    where T : CanvasController;", 
            "title": "DestinationCanvasController&lt;T&gt;"
        }, 
        {
            "location": "/scripting-reference/storyboards/StoryboardTransition/#parameters", 
            "text": "Name  Description      T  The type to cast the destination canvas controller to.", 
            "title": "Parameters"
        }, 
        {
            "location": "/scripting-reference/storyboards/StoryboardTransition/#description_6", 
            "text": "The transition's destination canvas controller, if it is of type T.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/storyboards/StoryboardTransition/#sourcecanvascontroller", 
            "text": "public CanvasController SourceCanvasController();", 
            "title": "SourceCanvasController"
        }, 
        {
            "location": "/scripting-reference/storyboards/StoryboardTransition/#description_7", 
            "text": "The transition's source canvas controller.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/storyboards/StoryboardTransition/#sourcecanvascontrollert", 
            "text": "public T SourceCanvasController T ()\n    where T : CanvasController;", 
            "title": "SourceCanvasController&lt;T&gt;"
        }, 
        {
            "location": "/scripting-reference/storyboards/StoryboardTransition/#parameters_1", 
            "text": "Name  Description      T  The type to cast the source canvas controller to.", 
            "title": "Parameters"
        }, 
        {
            "location": "/scripting-reference/storyboards/StoryboardTransition/#description_8", 
            "text": "The transition's source canvas controller, if it is of type T.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/storyboards/StoryboardTransitionDirection/", 
            "text": "StoryboardTransitionDirection\n\n\npublic enum StoryboardTransitionDirection;\n\n\nDescription\n\n\nThe direction of a storyboard transition. \n\n\n\n\n\n\n\n\nValues\n\n\n\n\n\n\n\n\n\n\n\n\nDownstream\n\n\nA downstream direction refers to a presentation transition - represented by a blue color in the storyboard editor.\n\n\n\n\n\n\nUpstream\n\n\nAn upstream direction refers to a dismissal transition - represented by an orange color in the storyboard editor.\n\n\n\n\n\n\n\n\n\n\nDownstream\n\n\nDownstream,\n\n\nDescription\n\n\nA downstream direction refers to a presentation transition - represented by a blue color in the storyboard editor. \n\n\n\n\nUpstream\n\n\nUpstream\n\n\nDescription\n\n\nAn upstream direction refers to a dismissal transition - represented by an orange color in the storyboard editor.", 
            "title": "StoryboardTransitionDirection"
        }, 
        {
            "location": "/scripting-reference/storyboards/StoryboardTransitionDirection/#storyboardtransitiondirection", 
            "text": "public enum StoryboardTransitionDirection;", 
            "title": "StoryboardTransitionDirection"
        }, 
        {
            "location": "/scripting-reference/storyboards/StoryboardTransitionDirection/#description", 
            "text": "The direction of a storyboard transition.      Values       Downstream  A downstream direction refers to a presentation transition - represented by a blue color in the storyboard editor.    Upstream  An upstream direction refers to a dismissal transition - represented by an orange color in the storyboard editor.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/storyboards/StoryboardTransitionDirection/#downstream", 
            "text": "Downstream,", 
            "title": "Downstream"
        }, 
        {
            "location": "/scripting-reference/storyboards/StoryboardTransitionDirection/#description_1", 
            "text": "A downstream direction refers to a presentation transition - represented by a blue color in the storyboard editor.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/storyboards/StoryboardTransitionDirection/#upstream", 
            "text": "Upstream", 
            "title": "Upstream"
        }, 
        {
            "location": "/scripting-reference/storyboards/StoryboardTransitionDirection/#description_2", 
            "text": "An upstream direction refers to a dismissal transition - represented by an orange color in the storyboard editor.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/storyboards/StoryboardTransitionEvent/", 
            "text": "StoryboardTransitionEvent\n\n\npublic class StoryboardTransitionEvent : UnityEvent\nStoryboardTransition\n;\n\n\nDescription\n\n\nA UnityEvent type for Storyboard events that passes in a \nStoryboardTransition\n. See \nStoryboard\n for available event callbacks. \n\n\n\n\n\n\n\n\nProperties\n\n\n\n\n\n\n\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMethods\n\n\n\n\n\n\n\n\n\n\n\n\nNone", 
            "title": "StoryboardTransitionEvent"
        }, 
        {
            "location": "/scripting-reference/storyboards/StoryboardTransitionEvent/#storyboardtransitionevent", 
            "text": "public class StoryboardTransitionEvent : UnityEvent StoryboardTransition ;", 
            "title": "StoryboardTransitionEvent"
        }, 
        {
            "location": "/scripting-reference/storyboards/StoryboardTransitionEvent/#description", 
            "text": "A UnityEvent type for Storyboard events that passes in a  StoryboardTransition . See  Storyboard  for available event callbacks.      Properties       None         Methods       None", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/routine/Routine/", 
            "text": "Routine\n\n\npublic class Routine;\n\n\nDescription\n\n\nThe Routine class is a convenience class for easily executing a Unity coroutine with progress callbacks. This can be helpful when animating an object over a duration, for example. \n\n\nTo use the routine class, create an instance of it and call \nRun\n like so: \n\n // Create a routine lasting \nduration\n seconds.\n Routine animation = new Routine(duration);\n\n\n// Execute the routine.\n animation.Run(OnUpdate: (progress01) =\n\n {\n     // The update action is called every frame for the routine's duration,\n     // passing in a progress01 value.\n     // e.g. Vector3.LerpUnclamped(startPos, endPos, progress01);\n }, OnComplete: () =\n\n {\n     // The completion action is called after \nduration\n seconds.\n }); \n\n\nThe Routine class will instantiate a game object to execute the coroutine, and destroy it upon completion. \n\n\n\n\n\n\n\n\nProperties\n\n\n\n\n\n\n\n\n\n\n\n\ndelay\n\n\nThe delay, in seconds, to wait before starting the routine after \nRun\n is called.\n\n\n\n\n\n\nduration\n\n\nThe duration of the routine, in seconds.\n\n\n\n\n\n\nIsRunning\n\n\nIs the routine running?\n\n\n\n\n\n\nupdateMode\n\n\nThe update mode of the routine. Can either be \nUnscaledTime\n or \nScaledTime\n.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMethods\n\n\n\n\n\n\n\n\n\n\n\n\nRoutine\n\n\nInitializes a new instance of the \nRoutine\n class.\n\n\n\n\n\n\nRun\n\n\nRun the routine with the specified OnUpdate and OnComplete callbacks.\n\n\n\n\n\n\nStop\n\n\nStop the routine.\n\n\n\n\n\n\n\n\n\n\ndelay\n\n\npublic float delay;\n\n\nDescription\n\n\nThe delay, in seconds, to wait before starting the routine after \nRun\n is called. \n\n\n\n\nduration\n\n\npublic float duration;\n\n\nDescription\n\n\nThe duration of the routine, in seconds. \n\n\n\n\nIsRunning\n\n\npublic bool IsRunning;\n\n\nDescription\n\n\nIs the routine running? \n\n\n\n\nupdateMode\n\n\npublic RoutineUpdateMode updateMode;\n\n\nDescription\n\n\nThe update mode of the routine. Can either be \nUnscaledTime\n or \nScaledTime\n. \n\n\n\n\nRoutine\n\n\npublic Routine(float duration = 1f,\n               float delay = 0f,\n               RoutineUpdateMode updateMode = RoutineUpdateMode.UnscaledTime);\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nduration\n\n\nThe duration of the routine, in seconds.\n\n\n\n\n\n\ndelay\n\n\nThe delay, in seconds, to wait before starting the routine after  is called.\n\n\n\n\n\n\nupdateMode\n\n\nThe update mode of the routine. Can either be UnscaledTime or ScaledTime.\n\n\n\n\n\n\n\n\nDescription\n\n\nInitializes a new instance of the \nRoutine\n class. \n\n\n\n\nRun\n\n\npublic void Run(System.Action\nfloat\n OnUpdate = null,\n                      System.Action OnComplete = null);\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nOnUpdate\n\n\nThe OnUpdate action. This will be called every frame with a progress value for the routine's duration.\n\n\n\n\n\n\nOnComplete\n\n\nThe OnComplete action. This will be called once when the routine has reached its duration.\n\n\n\n\n\n\n\n\nDescription\n\n\nRun the routine with the specified OnUpdate and OnComplete callbacks. \n\n\n\n\nStop\n\n\npublic void Stop();\n\n\nDescription\n\n\nStop the routine.", 
            "title": "Routine"
        }, 
        {
            "location": "/scripting-reference/routine/Routine/#routine", 
            "text": "public class Routine;", 
            "title": "Routine"
        }, 
        {
            "location": "/scripting-reference/routine/Routine/#description", 
            "text": "The Routine class is a convenience class for easily executing a Unity coroutine with progress callbacks. This can be helpful when animating an object over a duration, for example.   To use the routine class, create an instance of it and call  Run  like so:   // Create a routine lasting  duration  seconds.\n Routine animation = new Routine(duration);  // Execute the routine.\n animation.Run(OnUpdate: (progress01) = \n {\n     // The update action is called every frame for the routine's duration,\n     // passing in a progress01 value.\n     // e.g. Vector3.LerpUnclamped(startPos, endPos, progress01);\n }, OnComplete: () = \n {\n     // The completion action is called after  duration  seconds.\n });   The Routine class will instantiate a game object to execute the coroutine, and destroy it upon completion.      Properties       delay  The delay, in seconds, to wait before starting the routine after  Run  is called.    duration  The duration of the routine, in seconds.    IsRunning  Is the routine running?    updateMode  The update mode of the routine. Can either be  UnscaledTime  or  ScaledTime .        Methods       Routine  Initializes a new instance of the  Routine  class.    Run  Run the routine with the specified OnUpdate and OnComplete callbacks.    Stop  Stop the routine.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/routine/Routine/#delay", 
            "text": "public float delay;", 
            "title": "delay"
        }, 
        {
            "location": "/scripting-reference/routine/Routine/#description_1", 
            "text": "The delay, in seconds, to wait before starting the routine after  Run  is called.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/routine/Routine/#duration", 
            "text": "public float duration;", 
            "title": "duration"
        }, 
        {
            "location": "/scripting-reference/routine/Routine/#description_2", 
            "text": "The duration of the routine, in seconds.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/routine/Routine/#isrunning", 
            "text": "public bool IsRunning;", 
            "title": "IsRunning"
        }, 
        {
            "location": "/scripting-reference/routine/Routine/#description_3", 
            "text": "Is the routine running?", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/routine/Routine/#updatemode", 
            "text": "public RoutineUpdateMode updateMode;", 
            "title": "updateMode"
        }, 
        {
            "location": "/scripting-reference/routine/Routine/#description_4", 
            "text": "The update mode of the routine. Can either be  UnscaledTime  or  ScaledTime .", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/routine/Routine/#routine_1", 
            "text": "public Routine(float duration = 1f,\n               float delay = 0f,\n               RoutineUpdateMode updateMode = RoutineUpdateMode.UnscaledTime);", 
            "title": "Routine"
        }, 
        {
            "location": "/scripting-reference/routine/Routine/#parameters", 
            "text": "Name  Description      duration  The duration of the routine, in seconds.    delay  The delay, in seconds, to wait before starting the routine after  is called.    updateMode  The update mode of the routine. Can either be UnscaledTime or ScaledTime.", 
            "title": "Parameters"
        }, 
        {
            "location": "/scripting-reference/routine/Routine/#description_5", 
            "text": "Initializes a new instance of the  Routine  class.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/routine/Routine/#run", 
            "text": "public void Run(System.Action float  OnUpdate = null,\n                      System.Action OnComplete = null);", 
            "title": "Run"
        }, 
        {
            "location": "/scripting-reference/routine/Routine/#parameters_1", 
            "text": "Name  Description      OnUpdate  The OnUpdate action. This will be called every frame with a progress value for the routine's duration.    OnComplete  The OnComplete action. This will be called once when the routine has reached its duration.", 
            "title": "Parameters"
        }, 
        {
            "location": "/scripting-reference/routine/Routine/#description_6", 
            "text": "Run the routine with the specified OnUpdate and OnComplete callbacks.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/routine/Routine/#stop", 
            "text": "public void Stop();", 
            "title": "Stop"
        }, 
        {
            "location": "/scripting-reference/routine/Routine/#description_7", 
            "text": "Stop the routine.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/extensions/DynamicObjectExtensions/", 
            "text": "DynamicObjectExtensions\n\n\npublic static class DynamicObjectExtensions;\n\n\nDescription\n\n\nDynamic property lookup for classes and structs. \n\n\nThis class uses reflection to dynamically lookup a class or struct property. To use it, include its namespace: \nP7.CanvasFlow.DynamicObjectExtensions\n. \n\n\nCanvas Flow's Scale And Fade Background transition animator uses the \nGetField\n extension method to dynamically find the \ncontentToScalePropertyName\n specified in the animator's inspector. \n\n\n\n\n\n\n\n\nProperties\n\n\n\n\n\n\n\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMethods\n\n\n\n\n\n\n\n\n\n\n\n\nGetField\nT\n\n\nGet the class' field with the specified name and type using reflection.\n\n\n\n\n\n\nGetValueField\nT\n\n\nGet the struct's field with the specified name and type using reflection.\n\n\n\n\n\n\n\n\n\n\nGetField\nT\n\n\npublic static T GetField\nT\n(this Object obj, string fieldName)\n    where T : class;\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nT\n\n\nThe type of the field.\n\n\n\n\n\n\nfieldName\n\n\nThe name of the field.\n\n\n\n\n\n\n\n\nDescription\n\n\nGet the class' field with the specified name and type using reflection. \n\n\n\n\nGetValueField\nT\n\n\npublic static T? GetValueField\nT\n(this Object obj, string fieldName)\n    where T : struct;\n\n\nParameters\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nT\n\n\nThe type of the field.\n\n\n\n\n\n\nfieldName\n\n\nThe name of the field.\n\n\n\n\n\n\n\n\nDescription\n\n\nGet the struct's field with the specified name and type using reflection.", 
            "title": "DynamicObjectExtensions"
        }, 
        {
            "location": "/scripting-reference/extensions/DynamicObjectExtensions/#dynamicobjectextensions", 
            "text": "public static class DynamicObjectExtensions;", 
            "title": "DynamicObjectExtensions"
        }, 
        {
            "location": "/scripting-reference/extensions/DynamicObjectExtensions/#description", 
            "text": "Dynamic property lookup for classes and structs.   This class uses reflection to dynamically lookup a class or struct property. To use it, include its namespace:  P7.CanvasFlow.DynamicObjectExtensions .   Canvas Flow's Scale And Fade Background transition animator uses the  GetField  extension method to dynamically find the  contentToScalePropertyName  specified in the animator's inspector.      Properties       None         Methods       GetField T  Get the class' field with the specified name and type using reflection.    GetValueField T  Get the struct's field with the specified name and type using reflection.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/extensions/DynamicObjectExtensions/#getfieldt", 
            "text": "public static T GetField T (this Object obj, string fieldName)\n    where T : class;", 
            "title": "GetField&lt;T&gt;"
        }, 
        {
            "location": "/scripting-reference/extensions/DynamicObjectExtensions/#parameters", 
            "text": "Name  Description      T  The type of the field.    fieldName  The name of the field.", 
            "title": "Parameters"
        }, 
        {
            "location": "/scripting-reference/extensions/DynamicObjectExtensions/#description_1", 
            "text": "Get the class' field with the specified name and type using reflection.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/extensions/DynamicObjectExtensions/#getvaluefieldt", 
            "text": "public static T? GetValueField T (this Object obj, string fieldName)\n    where T : struct;", 
            "title": "GetValueField&lt;T&gt;"
        }, 
        {
            "location": "/scripting-reference/extensions/DynamicObjectExtensions/#parameters_1", 
            "text": "Name  Description      T  The type of the field.    fieldName  The name of the field.", 
            "title": "Parameters"
        }, 
        {
            "location": "/scripting-reference/extensions/DynamicObjectExtensions/#description_2", 
            "text": "Get the struct's field with the specified name and type using reflection.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/extensions/RectTransformExtensions/", 
            "text": "RectTransformExtensions\n\n\npublic static class RectTransformExtensions;\n\n\nDescription\n\n\nRect transform extension methods. \n\n\n\n\n\n\n\n\nProperties\n\n\n\n\n\n\n\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMethods\n\n\n\n\n\n\n\n\n\n\n\n\nFillParent\n\n\nMake a rect transform fill its parent.\n\n\n\n\n\n\n\n\n\n\nFillParent\n\n\npublic static void FillParent(this RectTransform rectTransform);\n\n\nDescription\n\n\nMake a rect transform fill its parent.", 
            "title": "RectTransformExtensions"
        }, 
        {
            "location": "/scripting-reference/extensions/RectTransformExtensions/#recttransformextensions", 
            "text": "public static class RectTransformExtensions;", 
            "title": "RectTransformExtensions"
        }, 
        {
            "location": "/scripting-reference/extensions/RectTransformExtensions/#description", 
            "text": "Rect transform extension methods.      Properties       None         Methods       FillParent  Make a rect transform fill its parent.", 
            "title": "Description"
        }, 
        {
            "location": "/scripting-reference/extensions/RectTransformExtensions/#fillparent", 
            "text": "public static void FillParent(this RectTransform rectTransform);", 
            "title": "FillParent"
        }, 
        {
            "location": "/scripting-reference/extensions/RectTransformExtensions/#description_1", 
            "text": "Make a rect transform fill its parent.", 
            "title": "Description"
        }, 
        {
            "location": "/release-notes/1.1/", 
            "text": "1.1 Release Notes\n\n\nNew Features\n\n\n\n\nWorld Space Support\n\n\nStoryboards can now be presented in world space by changing their \npresentation space\n to \nWorld Space\n.\n\n\nCanvas Controllers can also be presented in world space from script by passing a \nCanvasControllerWorldSpaceContainer\n to \nCanvasController.PresentInitialCanvasController\nT\n()\n.\n\n\nThe Storyboard component now has a custom inspector.\n\n\nCreated a new example - \n3. World Space UI\n - to demonstrate presenting a storyboard in world space.\n\n\n\n\n\n\n\n\nResolved Issues\n\n\n\n\nFixed an issue that caused an error to be logged to the console when creating a new scene using the right-click menu.", 
            "title": 1.1
        }, 
        {
            "location": "/release-notes/1.1/#11-release-notes", 
            "text": "", 
            "title": "1.1 Release Notes"
        }, 
        {
            "location": "/release-notes/1.1/#new-features", 
            "text": "World Space Support  Storyboards can now be presented in world space by changing their  presentation space  to  World Space .  Canvas Controllers can also be presented in world space from script by passing a  CanvasControllerWorldSpaceContainer  to  CanvasController.PresentInitialCanvasController T () .  The Storyboard component now has a custom inspector.  Created a new example -  3. World Space UI  - to demonstrate presenting a storyboard in world space.", 
            "title": "New Features"
        }, 
        {
            "location": "/release-notes/1.1/#resolved-issues", 
            "text": "Fixed an issue that caused an error to be logged to the console when creating a new scene using the right-click menu.", 
            "title": "Resolved Issues"
        }, 
        {
            "location": "/release-notes/1.0/", 
            "text": "1.0 Release Notes\n\n\n\n\nInitial release.", 
            "title": 1.0
        }, 
        {
            "location": "/release-notes/1.0/#10-release-notes", 
            "text": "Initial release.", 
            "title": "1.0 Release Notes"
        }
    ]
}