{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to the Canvas Flow Online Documentation.\n\n    \n\n    \n\n    \n\n\n\n\n\n\n\nIntroduction\n\n\nCanvas Flow is a user-interface presentation and storyboarding tool for Unity.\n\n\n\n\nMove between screens easily by presenting and dismissing canvases.\n\n\nVisually create your user interface's flow with Storyboards.\n\n\nA range of built-in transition animations or build your own.\n\n\n\n\nContents\n\n\n\n\nManual\n\n\nScripting Reference", 
            "title": "Home"
        }, 
        {
            "location": "/#introduction", 
            "text": "Canvas Flow is a user-interface presentation and storyboarding tool for Unity.   Move between screens easily by presenting and dismissing canvases.  Visually create your user interface's flow with Storyboards.  A range of built-in transition animations or build your own.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#contents", 
            "text": "Manual  Scripting Reference", 
            "title": "Contents"
        }, 
        {
            "location": "/manual/contents/", 
            "text": "Contents\n\n\nCanvas Controllers\n\n\n\n\nIntroduction\n\n\nCreating A Canvas Controller\n\n\nCanvas Controller Scenes\n\n\nPresentation \n Dismissal\n\n\nCanvas Controller Life Cycle\n\n\n\n\nStoryboards\n\n\n\n\nIntroduction\n\n\nCreating A Storyboard\n\n\nStoryboard Nodes\n\n\nStoryboard Transitions\n\n\nPresenting A Storyboard\n\n\nCustom Storyboard Hooks\n\n\n\n\nTransition Animators\n\n\n\n\nIntroduction\n\n\nDefault Transition Animators\n\n\nDefault Transition Animator\n\n\nFade To Color Transition Animator\n\n\nSlide Transition Animator\n\n\nScale Transition Animator\n\n\nScale And Fade Background Transition Animator\n\n\n\n\n\n\nUsing A Transition Animator\n\n\nCustom Transition Animators\n\n\n\n\nVersion History\n\n\n\n\n\n\n\n\nVersion\n\n\nDate\n\n\nChange Log\n\n\n\n\n\n\n\n\n\n\nv1.0\n\n\nMay 8th 2018\n\n\nInitial release", 
            "title": "Contents"
        }, 
        {
            "location": "/manual/contents/#contents", 
            "text": "", 
            "title": "Contents"
        }, 
        {
            "location": "/manual/contents/#canvas-controllers", 
            "text": "Introduction  Creating A Canvas Controller  Canvas Controller Scenes  Presentation   Dismissal  Canvas Controller Life Cycle", 
            "title": "Canvas Controllers"
        }, 
        {
            "location": "/manual/contents/#storyboards", 
            "text": "Introduction  Creating A Storyboard  Storyboard Nodes  Storyboard Transitions  Presenting A Storyboard  Custom Storyboard Hooks", 
            "title": "Storyboards"
        }, 
        {
            "location": "/manual/contents/#transition-animators", 
            "text": "Introduction  Default Transition Animators  Default Transition Animator  Fade To Color Transition Animator  Slide Transition Animator  Scale Transition Animator  Scale And Fade Background Transition Animator    Using A Transition Animator  Custom Transition Animators", 
            "title": "Transition Animators"
        }, 
        {
            "location": "/manual/contents/#version-history", 
            "text": "Version  Date  Change Log      v1.0  May 8th 2018  Initial release", 
            "title": "Version History"
        }, 
        {
            "location": "/manual/canvas-controllers/introduction/", 
            "text": "Introduction\n\n\nA canvas controller represents a single screen in your user interface. Canvas controllers can present and dismiss other canvas controllers, or screens, allowing you to easily build a user interface flow, presenting and dismissing screens as required.\n\n\nA canvas controller automatically manages the presentation hierarchy, as well as loading and unloading itself as it is presented or dismissed. This allows you to build large, complex, or dynamic user interface flows, loading only the necessary screens on demand.\n\n\nCanvas controllers are built with Unity's native \nUI Canvas\n, so any UI components that work with Unity's \nUI.Canvas\n are supported and creating the canvas controller's content will feel very familiar if you have worked with Unity UI before.\n\n\nCanvas controllers can be used in \nStoryboards\n to visually create the user interface's flow.\n\n\nA canvas controller consists of two files - a scene file (\n.unity\n) and a script file (\n.cs\n). The scene file is where you can create your screen's contents. See the \nCanvas Controller Scenes\n section for more information. The script file is where you can do any scripting that your screen may require. See the \nPresentation \n Dismissal\n and \nLife Cycle\n sections for more information.\n\n\n\n    \n\n    \nThe menu canvas controller from the included 'Floaty Cube' example.", 
            "title": "Introduction"
        }, 
        {
            "location": "/manual/canvas-controllers/introduction/#introduction", 
            "text": "A canvas controller represents a single screen in your user interface. Canvas controllers can present and dismiss other canvas controllers, or screens, allowing you to easily build a user interface flow, presenting and dismissing screens as required.  A canvas controller automatically manages the presentation hierarchy, as well as loading and unloading itself as it is presented or dismissed. This allows you to build large, complex, or dynamic user interface flows, loading only the necessary screens on demand.  Canvas controllers are built with Unity's native  UI Canvas , so any UI components that work with Unity's  UI.Canvas  are supported and creating the canvas controller's content will feel very familiar if you have worked with Unity UI before.  Canvas controllers can be used in  Storyboards  to visually create the user interface's flow.  A canvas controller consists of two files - a scene file ( .unity ) and a script file ( .cs ). The scene file is where you can create your screen's contents. See the  Canvas Controller Scenes  section for more information. The script file is where you can do any scripting that your screen may require. See the  Presentation   Dismissal  and  Life Cycle  sections for more information.  \n     \n     The menu canvas controller from the included 'Floaty Cube' example.", 
            "title": "Introduction"
        }, 
        {
            "location": "/manual/canvas-controllers/creating-a-canvas-controller/", 
            "text": "Creating A Canvas Controller\n\n\nTo create a new canvas controller, open Unity's \nCreate\n menu - by either right-clicking in the Project window or selecting Assets in the menu bar - and selecting \nCreate/Canvas Flow/Canvas Controller\n. Enter a name and a directory for your new canvas controller.\n\n\nThis will create two new files at the specified location - a \n.unity\n scene file and a \n.cs\n script file - and open the new canvas controller's scene.\n\n\n\n    \n\n    \nA newly created canvas controller.", 
            "title": "Creating A Canvas Controller"
        }, 
        {
            "location": "/manual/canvas-controllers/creating-a-canvas-controller/#creating-a-canvas-controller", 
            "text": "To create a new canvas controller, open Unity's  Create  menu - by either right-clicking in the Project window or selecting Assets in the menu bar - and selecting  Create/Canvas Flow/Canvas Controller . Enter a name and a directory for your new canvas controller.  This will create two new files at the specified location - a  .unity  scene file and a  .cs  script file - and open the new canvas controller's scene.  \n     \n     A newly created canvas controller.", 
            "title": "Creating A Canvas Controller"
        }, 
        {
            "location": "/manual/canvas-controllers/canvas-controller-scenes/", 
            "text": "Canvas Controller Scenes\n\n\nA canvas controller's scene file contains the main canvas and is where you can create your screen's contents. By default, a canvas controller's scene is structured like so:\n\n\n\n    \n\n    \nA canvas controller's default hierarchy.\n\n    \n\n\n\n\n\nYou should place your UI elements underneath the 'Content' game object, just as the canvas controller's 'Background Image' has been. This allows your UI elements to be clipped to the canvas' rect and ensures that they are compatible with the included transition animators\n1\n.\n\n\n\n    \n\n    \nCreating a canvas controller's content.\n\n    \n\n\n\n\n\n1. The included transition animators animate the 'Content' game object. If you place elements outside of the canvas controller's content, it won't be animated by the included transition animators. You could, however, animate it with a \ncustom transition animator.\n\n\nTODO presentationMode\n\n\n\n\nRoot Canvas Controller Object\n\n\nThe top-level game object contains a single component - your canvas controller's script. Here you can see any properties that you declare in your canvas controller and configure any UI elements, such as button callbacks. \nYou must always keep this object in the root of your canvas controller's scene.\n\n\n\n    \n\n    \nThe canvas controller game object and component.\n\n    \n\n\n\n\n\n\n\nCanvas Object\n\n\nThe canvas game object contains three components - the canvas itself, a \nCanvas Scaler\n, and the Canvas' \nGraphic Raycaster\n.\n\n\n\n    \n\n    \nThe canvas game object and component.\n\n    \n\n\n\n\n\nThe Canvas Scaler's reference resolution should be set to the resolution that you are designing your UI at. If the screen resolution is larger, the UI will be scaled up, and if it\u2019s smaller, the UI will be scaled down. Note that you can change the default value for new canvas controllers in Canvas Flow's preferences, which can be found in the Unity menu at \nUnity/Preferences/Canvas Flow\n\n\n\n    \n\n    \nSet the reference resolution for new canvas controllers in the editor preferences window.", 
            "title": "Canvas Controller Scenes"
        }, 
        {
            "location": "/manual/canvas-controllers/canvas-controller-scenes/#canvas-controller-scenes", 
            "text": "A canvas controller's scene file contains the main canvas and is where you can create your screen's contents. By default, a canvas controller's scene is structured like so:  \n     \n     A canvas controller's default hierarchy. \n       You should place your UI elements underneath the 'Content' game object, just as the canvas controller's 'Background Image' has been. This allows your UI elements to be clipped to the canvas' rect and ensures that they are compatible with the included transition animators 1 .  \n     \n     Creating a canvas controller's content. \n       1. The included transition animators animate the 'Content' game object. If you place elements outside of the canvas controller's content, it won't be animated by the included transition animators. You could, however, animate it with a  custom transition animator.  TODO presentationMode", 
            "title": "Canvas Controller Scenes"
        }, 
        {
            "location": "/manual/canvas-controllers/canvas-controller-scenes/#root-canvas-controller-object", 
            "text": "The top-level game object contains a single component - your canvas controller's script. Here you can see any properties that you declare in your canvas controller and configure any UI elements, such as button callbacks.  You must always keep this object in the root of your canvas controller's scene.  \n     \n     The canvas controller game object and component.", 
            "title": "Root Canvas Controller Object"
        }, 
        {
            "location": "/manual/canvas-controllers/canvas-controller-scenes/#canvas-object", 
            "text": "The canvas game object contains three components - the canvas itself, a  Canvas Scaler , and the Canvas'  Graphic Raycaster .  \n     \n     The canvas game object and component. \n       The Canvas Scaler's reference resolution should be set to the resolution that you are designing your UI at. If the screen resolution is larger, the UI will be scaled up, and if it\u2019s smaller, the UI will be scaled down. Note that you can change the default value for new canvas controllers in Canvas Flow's preferences, which can be found in the Unity menu at  Unity/Preferences/Canvas Flow  \n     \n     Set the reference resolution for new canvas controllers in the editor preferences window.", 
            "title": "Canvas Object"
        }, 
        {
            "location": "/manual/canvas-controllers/presentation-and-dismissal/", 
            "text": "Presentation \n Dismissal\n\n\nCanvas controllers can present and dismiss other canvas controllers,  allowing you to easily build a user interface flow, presenting and dismissing screens as required.\n\n\nA canvas controller automatically manages the presentation hierarchy, as well as loading and unloading itself as it is presented or dismissed. This allows you to build large, complex, or dynamic user interface flows, loading only the necessary screens on demand.\n\n\n\n\nNote: Use storyboards to present and dismiss canvas controllers without scripting by visually creating your user interface's flow. Please see the Storyboards section of the manual for information about using Storyboards.\n\n\n\n\nPresenting From A Canvas Controller\n\n\nCanvas controllers are presented and dismissed using the \nPresentCanvasController\nT\n()\n and \nDismissCanvasController()\n methods.\n\n\nFor example, suppose we have two canvas controllers - \nMenuCanvasController\n and \nSettingsCanvasController\n. In our menu canvas controller is a UI Button that should show the settings screen when pressed.\n\n\nIn the \nMenuCanvasController.cs\n script, we could add the following \nOnClick\n handler:\n\n\npublic void OnSettingsButtonPressed()\n{\n    PresentCanvasController\nSettingsCanvasController\n();\n}\n\n\n\n\nAnd that's it. When this button is pressed, the menu will present the settings screen, dynamically loading the settings canvas controller and animating it on screen.\n\n\nWe could do a similar thing in our settings canvas controller, except this time the button being pressed is a back button and we want to return to the previous screen when it is pressed.\n\n\npublic void OnBackButtonPressed()\n{\n    DismissCanvasController();\n}\n\n\n\n\nThis will cause the settings screen to be animated off-screen and subsequently unloaded, returning to the menu.\n\n\n\n\nPresenting From A Scene\n\n\nIn a game environment, there is usually an existing scene - say the game's level or other 3D content scene - over which a user interface is presented. Once the initial canvas controller has been presented, the \nPresentCanvasController\nT\n()\n and \nDismissCanvasController()\n methods described above can be used. In order to present the initial canvas controller however, the static method \nCanvasController.PresentInitialCanvasController\nT\n()\n is used.\n\n\nSo, for example, say we have an existing game scene called \nLevel1\n, which contains our game's content, and a canvas controller called \nGameOverlayCanvasController\n. When the game scene \nLevel1\n is run, we wish to present the game overlay screen over the game's content.\n\n\nTo do this, we could create a new script in the \nLevel1\n game scene and present the initial \nGameOverlayCanvasController\n in the \nMonoBehaviour\n's \nAwake()\n method, like so:\n\n\nprivate void Awake()\n{\n    CanvasController.PresentInitialCanvasController\nGameOverlayCanvasController\n(animated: false)\n}\n\n\n\n\n\n\nNote how we can specify this presentation to not be animated by using the \nanimated\n parameter.\n\n\n\n\nThe game overlay screen could then use the \nPresentCanvasController\nT\n()\n and \nDismissCanvasController()\n methods described above, perhaps presenting pause or game-over screens, as required.\n\n\n\n\nNote: A single \nUnity EventSystem\n is required to be present for canvases to receive input events. Therefore, depending on your game's structure, you may wish to place an Event System (\nGame Object/UI/Event System\n) in the scene presenting your initial canvas controller.\n\n\n\n\n\n\nConfiguring A (To-Be) Presented Canvas Controller\n\n\nAll \nPresent\u2026()\n methods include a configuration action parameter to allow configuring the loaded canvas controller before it is presented. The configuration action is invoked by Canvas Flow after the canvas controller has been loaded, but before it has begun presenting. The configuration action is specified like so:\n\n\nPresentCanvasController\nGameOverlayCanvasController\n(configuration: (gameOverlayCanvasController) =\n\n{\n    // Configure the newly-loaded gameOverlayCanvasController.\n});\n\n\n\n\nA common use-case for the configuration action is to pass data to the to-be-presented canvas controller. To illustrate, take the earlier example of presenting a game overlay screen in the game's \nLevel1\n scene. Say we now have \nLevel2\n and \nLevel3\n scenes as well, which also display the same game overlay screen as before. However, we want to display the current level number in the top corner of the screen for the player. After adding a label to display the current level, we could also add a \nConfigureWithLevel()\n method to our \ngameOverlayCanvasController\n, which sets the level label's text. \n\n\n// In GameOverlayCanvasController.cs\npublic void ConfigureWithLevel(int levelNumber)\n{\n    currentLevelLabel.text = string.Format(\nLevel {0}\n, levelNumber);\n}\n\n\n\n\nThen when presenting the game overlay screen from the \nAwake()\n method as before, we can use the configuration action to configure it with the level number, which is set in the scene.\n\n\npublic int levelNumber;\n\nprivate void Awake()\n{\n    CanvasController.PresentInitialCanvasController\nGameOverlayCanvasController\n(\n        configuration: (gameOverlayCanvasController) =\n\n    {\n        gameOverlayCanvasController.ConfigureWithLevel(levelNumber);\n    } animated: false);\n}\n\n\n\n\nNow, no matter how many levels we create, the game overlay screen will simply display the level number it is configured with.\n\n\n\n\nNote: Canvas controllers also have a similar \ncompletion:\n action parameter, which is invoked \nafter\n the presentation transition has completed. \n\n\n\n\n\n\nFor information on customizing the transition animation between canvas controllers, please see the Custom Transition Animators section.", 
            "title": "Presentation & Dismissal"
        }, 
        {
            "location": "/manual/canvas-controllers/presentation-and-dismissal/#presentation-dismissal", 
            "text": "Canvas controllers can present and dismiss other canvas controllers,  allowing you to easily build a user interface flow, presenting and dismissing screens as required.  A canvas controller automatically manages the presentation hierarchy, as well as loading and unloading itself as it is presented or dismissed. This allows you to build large, complex, or dynamic user interface flows, loading only the necessary screens on demand.   Note: Use storyboards to present and dismiss canvas controllers without scripting by visually creating your user interface's flow. Please see the Storyboards section of the manual for information about using Storyboards.", 
            "title": "Presentation &amp; Dismissal"
        }, 
        {
            "location": "/manual/canvas-controllers/presentation-and-dismissal/#presenting-from-a-canvas-controller", 
            "text": "Canvas controllers are presented and dismissed using the  PresentCanvasController T ()  and  DismissCanvasController()  methods.  For example, suppose we have two canvas controllers -  MenuCanvasController  and  SettingsCanvasController . In our menu canvas controller is a UI Button that should show the settings screen when pressed.  In the  MenuCanvasController.cs  script, we could add the following  OnClick  handler:  public void OnSettingsButtonPressed()\n{\n    PresentCanvasController SettingsCanvasController ();\n}  And that's it. When this button is pressed, the menu will present the settings screen, dynamically loading the settings canvas controller and animating it on screen.  We could do a similar thing in our settings canvas controller, except this time the button being pressed is a back button and we want to return to the previous screen when it is pressed.  public void OnBackButtonPressed()\n{\n    DismissCanvasController();\n}  This will cause the settings screen to be animated off-screen and subsequently unloaded, returning to the menu.", 
            "title": "Presenting From A Canvas Controller"
        }, 
        {
            "location": "/manual/canvas-controllers/presentation-and-dismissal/#presenting-from-a-scene", 
            "text": "In a game environment, there is usually an existing scene - say the game's level or other 3D content scene - over which a user interface is presented. Once the initial canvas controller has been presented, the  PresentCanvasController T ()  and  DismissCanvasController()  methods described above can be used. In order to present the initial canvas controller however, the static method  CanvasController.PresentInitialCanvasController T ()  is used.  So, for example, say we have an existing game scene called  Level1 , which contains our game's content, and a canvas controller called  GameOverlayCanvasController . When the game scene  Level1  is run, we wish to present the game overlay screen over the game's content.  To do this, we could create a new script in the  Level1  game scene and present the initial  GameOverlayCanvasController  in the  MonoBehaviour 's  Awake()  method, like so:  private void Awake()\n{\n    CanvasController.PresentInitialCanvasController GameOverlayCanvasController (animated: false)\n}   Note how we can specify this presentation to not be animated by using the  animated  parameter.   The game overlay screen could then use the  PresentCanvasController T ()  and  DismissCanvasController()  methods described above, perhaps presenting pause or game-over screens, as required.   Note: A single  Unity EventSystem  is required to be present for canvases to receive input events. Therefore, depending on your game's structure, you may wish to place an Event System ( Game Object/UI/Event System ) in the scene presenting your initial canvas controller.", 
            "title": "Presenting From A Scene"
        }, 
        {
            "location": "/manual/canvas-controllers/presentation-and-dismissal/#configuring-a-to-be-presented-canvas-controller", 
            "text": "All  Present\u2026()  methods include a configuration action parameter to allow configuring the loaded canvas controller before it is presented. The configuration action is invoked by Canvas Flow after the canvas controller has been loaded, but before it has begun presenting. The configuration action is specified like so:  PresentCanvasController GameOverlayCanvasController (configuration: (gameOverlayCanvasController) = \n{\n    // Configure the newly-loaded gameOverlayCanvasController.\n});  A common use-case for the configuration action is to pass data to the to-be-presented canvas controller. To illustrate, take the earlier example of presenting a game overlay screen in the game's  Level1  scene. Say we now have  Level2  and  Level3  scenes as well, which also display the same game overlay screen as before. However, we want to display the current level number in the top corner of the screen for the player. After adding a label to display the current level, we could also add a  ConfigureWithLevel()  method to our  gameOverlayCanvasController , which sets the level label's text.   // In GameOverlayCanvasController.cs\npublic void ConfigureWithLevel(int levelNumber)\n{\n    currentLevelLabel.text = string.Format( Level {0} , levelNumber);\n}  Then when presenting the game overlay screen from the  Awake()  method as before, we can use the configuration action to configure it with the level number, which is set in the scene.  public int levelNumber;\n\nprivate void Awake()\n{\n    CanvasController.PresentInitialCanvasController GameOverlayCanvasController (\n        configuration: (gameOverlayCanvasController) = \n    {\n        gameOverlayCanvasController.ConfigureWithLevel(levelNumber);\n    } animated: false);\n}  Now, no matter how many levels we create, the game overlay screen will simply display the level number it is configured with.   Note: Canvas controllers also have a similar  completion:  action parameter, which is invoked  after  the presentation transition has completed.     For information on customizing the transition animation between canvas controllers, please see the Custom Transition Animators section.", 
            "title": "Configuring A (To-Be) Presented Canvas Controller"
        }, 
        {
            "location": "/manual/canvas-controllers/canvas-controller-life-cycle/", 
            "text": "Canvas Controller Life Cycle\n\n\nCanvas controllers allow you to override certain methods in order to be notified when particular events occur in their life cycle. These include appearance related events, as well as all \nMonoBehaviour\n events.\n\n\nAppearance\n\n\nA canvas controller can override the following methods to receive appearance related callbacks. These could be used, for example, to trigger an animation once a canvas controller has completely transitioned on screen.\n\n\nYou can use the \nIsBeingPresented\n and \nIsBeingDismissed\n methods within the callback to infer the cause of the appearance or disappearance.\n\n\nprotected override void CanvasWillAppear()\n{\n    /*\n     *  Override this method in your canvas controller to be notified just\n     *  before the canvas is about to transition on screen. This could be\n     *  because it is about to be presented or about to dismiss its\n     *  PresentedCanvasController.\n     */\n}\n\nprotected override void CanvasDidAppear()\n{\n    /*\n     *  Override this method in your canvas controller to be notified just\n     *  after the canvas has transitioned on screen. This could be because\n     *  it has just been presented or has just dismissed its\n     *  PresentedCanvasController.\n     */\n}\n\nprotected override void CanvasWillDisappear()\n{\n    /*\n     *  Override this method in your canvas controller to be notified just\n     *  before the canvas is about to transition off screen. This could be\n     *  because it is about to be dismissed or about to present a canvas\n     *  controller.\n     */\n}\n\nprotected override void CanvasDidDisappear()\n{\n    /*\n     *  Override this method in your canvas controller to be notified just\n     *  after the canvas has transitioned off screen. This could be\n     *  because it has just been dismissed or has just presented a canvas\n     *  controller.\n     */\n}\n\n\n\n\nMonoBehaviour\n\n\nA canvas controller is a \nMonoBehaviour\n and as such, all \nMonoBehaviour\n callbacks will be called on a canvas controller.\n\n\nIf implementing \nAwake()\n or \nStart()\n, you should override and call the base implementation like so:\n\n\nprotected override void Awake()\n{\n    base.Awake();\n\n    // Your awake functionality.\n}\n\nprotected override void Start()\n{\n    base.Start();\n\n    // Your start functionality.\n}", 
            "title": "Canvas Controller Life Cycle"
        }, 
        {
            "location": "/manual/canvas-controllers/canvas-controller-life-cycle/#canvas-controller-life-cycle", 
            "text": "Canvas controllers allow you to override certain methods in order to be notified when particular events occur in their life cycle. These include appearance related events, as well as all  MonoBehaviour  events.", 
            "title": "Canvas Controller Life Cycle"
        }, 
        {
            "location": "/manual/canvas-controllers/canvas-controller-life-cycle/#appearance", 
            "text": "A canvas controller can override the following methods to receive appearance related callbacks. These could be used, for example, to trigger an animation once a canvas controller has completely transitioned on screen.  You can use the  IsBeingPresented  and  IsBeingDismissed  methods within the callback to infer the cause of the appearance or disappearance.  protected override void CanvasWillAppear()\n{\n    /*\n     *  Override this method in your canvas controller to be notified just\n     *  before the canvas is about to transition on screen. This could be\n     *  because it is about to be presented or about to dismiss its\n     *  PresentedCanvasController.\n     */\n}\n\nprotected override void CanvasDidAppear()\n{\n    /*\n     *  Override this method in your canvas controller to be notified just\n     *  after the canvas has transitioned on screen. This could be because\n     *  it has just been presented or has just dismissed its\n     *  PresentedCanvasController.\n     */\n}\n\nprotected override void CanvasWillDisappear()\n{\n    /*\n     *  Override this method in your canvas controller to be notified just\n     *  before the canvas is about to transition off screen. This could be\n     *  because it is about to be dismissed or about to present a canvas\n     *  controller.\n     */\n}\n\nprotected override void CanvasDidDisappear()\n{\n    /*\n     *  Override this method in your canvas controller to be notified just\n     *  after the canvas has transitioned off screen. This could be\n     *  because it has just been dismissed or has just presented a canvas\n     *  controller.\n     */\n}", 
            "title": "Appearance"
        }, 
        {
            "location": "/manual/canvas-controllers/canvas-controller-life-cycle/#monobehaviour", 
            "text": "A canvas controller is a  MonoBehaviour  and as such, all  MonoBehaviour  callbacks will be called on a canvas controller.  If implementing  Awake()  or  Start() , you should override and call the base implementation like so:  protected override void Awake()\n{\n    base.Awake();\n\n    // Your awake functionality.\n}\n\nprotected override void Start()\n{\n    base.Start();\n\n    // Your start functionality.\n}", 
            "title": "MonoBehaviour"
        }, 
        {
            "location": "/manual/storyboards/introduction/", 
            "text": "Introduction\n\n\nStoryboards allow you to visually create the flow of your user interface by defining the canvas controllers involved (nodes) and the connections between them (transitions).\n\n\nInstead of writing code to present and dismiss canvas controllers, you can create a storyboard to describe the flow between your screens. Canvas Flow can then automatically present and dismiss your canvas controllers as the relevant buttons, or \n'hooks'\n, are triggered.\n\n\nStoryboards are designed in the Storyboard Editor window, shown below, which can be opened by either double-clicking on a storyboard asset in the project inspector or selecting \nWindow/Canvas Flow/Storyboard\n in the menu bar.\n\n\n\n    \n\n    \nThe in-game storyboard from Canvas Flow's Floaty Cube example, containing four screens.", 
            "title": "Introduction"
        }, 
        {
            "location": "/manual/storyboards/introduction/#introduction", 
            "text": "Storyboards allow you to visually create the flow of your user interface by defining the canvas controllers involved (nodes) and the connections between them (transitions).  Instead of writing code to present and dismiss canvas controllers, you can create a storyboard to describe the flow between your screens. Canvas Flow can then automatically present and dismiss your canvas controllers as the relevant buttons, or  'hooks' , are triggered.  Storyboards are designed in the Storyboard Editor window, shown below, which can be opened by either double-clicking on a storyboard asset in the project inspector or selecting  Window/Canvas Flow/Storyboard  in the menu bar.  \n     \n     The in-game storyboard from Canvas Flow's Floaty Cube example, containing four screens.", 
            "title": "Introduction"
        }, 
        {
            "location": "/manual/storyboards/creating-a-storyboard/", 
            "text": "Creating A Storyboard\n\n\nTo create a new storyboard, open Unity's \nCreate\n menu - by either right-clicking in the Project window or selecting Assets in the menu bar - and selecting \nCreate/Canvas Flow/Storyboard\n. Enter a name and a directory for your new storyboard.\n\n\nThis will create a new storyboard file at the specified location and open it in the Storyboard Editor window.\n\n\n\n    \n\n    \nA newly-created, empty storyboard.", 
            "title": "Creating A Storyboard"
        }, 
        {
            "location": "/manual/storyboards/creating-a-storyboard/#creating-a-storyboard", 
            "text": "To create a new storyboard, open Unity's  Create  menu - by either right-clicking in the Project window or selecting Assets in the menu bar - and selecting  Create/Canvas Flow/Storyboard . Enter a name and a directory for your new storyboard.  This will create a new storyboard file at the specified location and open it in the Storyboard Editor window.  \n     \n     A newly-created, empty storyboard.", 
            "title": "Creating A Storyboard"
        }, 
        {
            "location": "/manual/storyboards/storyboard-nodes/", 
            "text": "Storyboard Nodes\n\n\nA storyboard node represents a single instance of a canvas controller in the storyboard. Nodes can then have connections made between them, called \ntransitions\n, which define the flow of your user interface.\n\n\nAdding Nodes\n\n\nTo add a node to a storyboard, simply drag the canvas controller's scene file onto the storyboard window, as shown in the video below.\n\n\nAlternatively, you can use the '+' button in the lower-right corner of the Storyboard Editor window to select an existing canvas controller in the file inspector.\n\n\n\n    \n\n    \nAdding a canvas controller to a storyboard with drag \n&\n drop.\n\n    \n\n\n\n\n\nNode Details\n\n\nA node represents a single instance of a canvas controller in the storyboard. It will display any \nhookable\n elements - such as Unity's \nUI Buttons\n - in the canvas preview area of the node, as shown below. A \nhookable\n element is one that a transition can be created from, in order to present or dismiss a canvas controller. \n\n\n\n    \n\n    \nA node's canvas preview area displays its 'hookable' elements, such as the pause button shown here.\n\n\n\n\n\n\n\nNote: The canvas preview area is sized according to the \nCanvas Scaler's\n reference resolution. See the canvas controller's \ncanvas object\n for more information.\n\n\n\n\nBy default, all \nUnity UI Buttons\n are supported as \nhookable\n elements in a storyboard. This means that any \nUI Buttons\n in a canvas controller can be used in a storyboard to trigger a transition to another canvas controller. To support additional UI elements, such as a custom button type, please see the \nCustom Storyboard Hooks\n section of the manual.\n\n\nWhen a canvas controller's scene is saved, all \nhookable\n components have a \nStoryboard Hook\n added to them, causing them to be displayed in the canvas preview area. A storyboard hook can be excluded from a storyboard by selecting the \nExclude From Storyboard\n flag on the hook in your canvas controller's scene.\n\n\n\n    \n\n    \nExclude a hook from a storyboard.\n\n    \n\n\n\n\n\nAdditionally, the automatic adding of \nStoryboardHook\n components can be disabled in Canvas Flow's preferences by unchecking \n'Auto-Add Hooks On Scene Save'\n, found in the menu bar at \nUnity/Preferences/Canvas Flow\n.", 
            "title": "Storyboard Nodes"
        }, 
        {
            "location": "/manual/storyboards/storyboard-nodes/#storyboard-nodes", 
            "text": "A storyboard node represents a single instance of a canvas controller in the storyboard. Nodes can then have connections made between them, called  transitions , which define the flow of your user interface.", 
            "title": "Storyboard Nodes"
        }, 
        {
            "location": "/manual/storyboards/storyboard-nodes/#adding-nodes", 
            "text": "To add a node to a storyboard, simply drag the canvas controller's scene file onto the storyboard window, as shown in the video below.  Alternatively, you can use the '+' button in the lower-right corner of the Storyboard Editor window to select an existing canvas controller in the file inspector.  \n     \n     Adding a canvas controller to a storyboard with drag  &  drop.", 
            "title": "Adding Nodes"
        }, 
        {
            "location": "/manual/storyboards/storyboard-nodes/#node-details", 
            "text": "A node represents a single instance of a canvas controller in the storyboard. It will display any  hookable  elements - such as Unity's  UI Buttons  - in the canvas preview area of the node, as shown below. A  hookable  element is one that a transition can be created from, in order to present or dismiss a canvas controller.   \n     \n     A node's canvas preview area displays its 'hookable' elements, such as the pause button shown here.    Note: The canvas preview area is sized according to the  Canvas Scaler's  reference resolution. See the canvas controller's  canvas object  for more information.   By default, all  Unity UI Buttons  are supported as  hookable  elements in a storyboard. This means that any  UI Buttons  in a canvas controller can be used in a storyboard to trigger a transition to another canvas controller. To support additional UI elements, such as a custom button type, please see the  Custom Storyboard Hooks  section of the manual.  When a canvas controller's scene is saved, all  hookable  components have a  Storyboard Hook  added to them, causing them to be displayed in the canvas preview area. A storyboard hook can be excluded from a storyboard by selecting the  Exclude From Storyboard  flag on the hook in your canvas controller's scene.  \n     \n     Exclude a hook from a storyboard. \n       Additionally, the automatic adding of  StoryboardHook  components can be disabled in Canvas Flow's preferences by unchecking  'Auto-Add Hooks On Scene Save' , found in the menu bar at  Unity/Preferences/Canvas Flow .", 
            "title": "Node Details"
        }, 
        {
            "location": "/manual/storyboards/storyboard-transitions/", 
            "text": "Storyboard Transitions\n\n\nStoryboard transitions define the flow of nodes in the storyboard. A connection from one node to another represents a transition between those two nodes - a presentation or dismissal. The hook from which the transition originates defines the trigger for that transition.\n\n\nDirection\n\n\nAll transitions in a storyboard have a direction, which can be one of two values - downstream or upstream. A downstream connection is equivalent to a presentation and is represented by a \nblue\n color. An upstream connection is equivalent to a dismissal and is represented by an \norange\n color.\n\n\n\n    \n\n    \nA downstream transition (presentation) from the menu to the settings screen and an upstream transition (dismissal) from the settings screen back to the menu.\n\n\n\n\n\nCreation\n\n\nTo create a transition between two nodes, drag from the source node's hook to the destination node, as shown in the video below. Canvas Flow automatically detects the direction - downstream or upstream - based on the current state of the flow graph.\n\n\n\n    \n\n    \nCreating transitions between nodes.\n\n    \n\n\n\n\n\n\n\nNote: An upstream transition, or dismissal, is created when a connection is made in which the destination node has a downstream path to the source node. Therefore, to create an upstream transition a downstream path between the nodes must exist.\n\n\n\n\nConfiguration\n\n\nA transition's properties can be configured by selecting its origin hook. This will open the transition inspector, which is shown below and followed by a description of each property.\n\n\n\n    \n\n    \nThe transition inspector.\n\n\n\n\n\n\n\n\n\n\n\nProperty\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nHook Name\n\n\nThe name of the hook that will invoke this transition. This is taken from the game object that the hook component is attached to in the canvas controller.\n\n\n\n\n\n\nAnimated\n\n\nIs the transition animated?\n\n\n\n\n\n\nCustom Animator\n\n\nThe transition's animator. For more information, please see the \ntransition animators\n section of the manual.\n\n\n\n\n\n\nPresentation Mode\n\n\nThe presentation mode of the destination canvas controller (only available on downstream transitions). Please see \npresentation mode\n for more information.\n\n\n\n\n\n\nUser Identifier\n\n\nThe transition's user identifier. This is used to identify the transition when triggering it manually, such as with a \nmanual transition\n.\n\n\n\n\n\n\nLoad Asynchronously\n\n\nShould the canvas controller be loaded asynchronously? By default, canvas controllers are always loaded asynchronously.\n\n\n\n\n\n\nOverride World Position\n\n\nSpecify a world position at which to place the loaded canvas controller. This can be specified as an absolute world position with the \n'Position'\n setting, or as a spacing multiplier with the \n'World Spacing Multiplier'\n setting. If \n'World Spacing Multiplier'\n is selected, the world position for the new canvas will be the source canvas' world position plus the canvas size scaled by the multiplier.\n\n\n\n\n\n\n\n\nPassing Data Between Canvas Controllers\n\n\nWhen a transition occurs in a storyboard, the transition's source canvas controller will have its \nPrepareForStoryboardTransition()\n method called, passing in a \nStoryboardTransition\n.\n\n\nThis gives an opportunity to pass data between canvas controllers, just as you might use a \nconfiguration action\n when presenting a canvas controller from script.\n\n\nFor example, in Canvas Flow's Floaty Cube example, the menu canvas controller uses the \nPrepareForStoryboardTransition()\n method to detect when the loading screen is being presented and to configure it with the name of the scene to load, like so:\n\n\npublic override void PrepareForStoryboardTransition(StoryboardTransition transition)\n{\n    var destination = transition.DestinationCanvasController();\n    if (destination is FCLoadingCanvasController \n\n        transition.direction == StoryboardTransitionDirection.Downstream)\n    {\n        // We are presenting the loading screen. Configure it to present the Game scene.\n        var loadingCanvasController = (FCLoadingCanvasController)destination;\n        loadingCanvasController.SceneToLoad = \nFCGameScene\n;\n    }\n}\n\n\n\n\nManual Transitions\n\n\nManual transitions are transitions that have no origin hook - i.e. they must be triggered manually. These can be used to invoke a storyboard transition in response to non-UI events, such as a \ncollider\n being intersected or a timer expiring.\n\n\nTo create a manual transition, drag from the source node's \n'Manual Transitions'\n element to the destination node and enter a user identifier, as shown in the video below.\n\n\n\n    \n\n    \nCreating a manual transition between nodes.\n\n    \n\n\n\n\n\nTo trigger a manual transition, call \nPerformTransitionWithIdentifier()\n from the source canvas controller, passing in the transition's \nuserIdentifier\n.\n\n\nFor example, in Canvas Flow's Floaty Cube example, an event is raised when the player reaches a target height. The game overlay screen subscribes to this event, and in the callback it triggers its manual transition named \n\"PresentGameCompleteScreen\"\n, like so:\n\n\npublic void OnPlayerReachedHeight()\n{\n    PerformTransitionWithIdentifier(\nPresentGameCompleteScreen\n);\n}\n\n\n\n\n\n\nNote: Any storyboard transition - not just manual transitions - can be triggered by passing its \nUser Identifier\n to \nPerformTransitionWithIdentifier()\n.\n\n\n\n\nEntry Transition\n\n\nWhen the first canvas controller is added to a storyboard, an entry transition pointing to the new canvas controller is automatically created. This is shown by the blue wire connecting the 'Entry' node to the newly-added canvas controller.\n\n\n\n    \n\n    \nThe storyboard's entry transition.\n\n    \n\n\n\n\n\nThe storyboard's entry transition determines which canvas controller is presented when the storyboard is presented - i.e. the storyboard's entry point. To change the storyboard's entry point, select the \n'Make storyboard entry point'\n button on the canvas controller's node, as shown below.\n\n\n\n    \n\n    \nSet a storyboard's entry point.\n\n    \n\n\n\n\n\n\n\nNote: A node can only become the entry point if it has no downstream transitions pointing to it. Similarly, if a node is the entry point, a downstream connection cannot be made to it.\n\n\n\n\nThe entry transition can be configured just like any other transition, as described above, with the exception that it cannot be deleted; a storyboard must have an entry point.\n\n\nExit Transition\n\n\nA storyboard exit transition is optional and is not always required. It is used in the event that you want to dismiss the entire storyboard. It will dismiss all canvas controllers that are in the storyboard's initial canvas controller's presentation hierarchy, including the initial canvas controller itself. It is the equivalent of calling \nDismissAllCanvasControllers\n.\n\n\nTo create an exit transition, drag from a hook or manual transition element to the \nExit Transition\n node.", 
            "title": "Storyboard Transitions"
        }, 
        {
            "location": "/manual/storyboards/storyboard-transitions/#storyboard-transitions", 
            "text": "Storyboard transitions define the flow of nodes in the storyboard. A connection from one node to another represents a transition between those two nodes - a presentation or dismissal. The hook from which the transition originates defines the trigger for that transition.", 
            "title": "Storyboard Transitions"
        }, 
        {
            "location": "/manual/storyboards/storyboard-transitions/#direction", 
            "text": "All transitions in a storyboard have a direction, which can be one of two values - downstream or upstream. A downstream connection is equivalent to a presentation and is represented by a  blue  color. An upstream connection is equivalent to a dismissal and is represented by an  orange  color.  \n     \n     A downstream transition (presentation) from the menu to the settings screen and an upstream transition (dismissal) from the settings screen back to the menu.", 
            "title": "Direction"
        }, 
        {
            "location": "/manual/storyboards/storyboard-transitions/#creation", 
            "text": "To create a transition between two nodes, drag from the source node's hook to the destination node, as shown in the video below. Canvas Flow automatically detects the direction - downstream or upstream - based on the current state of the flow graph.  \n     \n     Creating transitions between nodes. \n        Note: An upstream transition, or dismissal, is created when a connection is made in which the destination node has a downstream path to the source node. Therefore, to create an upstream transition a downstream path between the nodes must exist.", 
            "title": "Creation"
        }, 
        {
            "location": "/manual/storyboards/storyboard-transitions/#configuration", 
            "text": "A transition's properties can be configured by selecting its origin hook. This will open the transition inspector, which is shown below and followed by a description of each property.  \n     \n     The transition inspector.      Property  Description      Hook Name  The name of the hook that will invoke this transition. This is taken from the game object that the hook component is attached to in the canvas controller.    Animated  Is the transition animated?    Custom Animator  The transition's animator. For more information, please see the  transition animators  section of the manual.    Presentation Mode  The presentation mode of the destination canvas controller (only available on downstream transitions). Please see  presentation mode  for more information.    User Identifier  The transition's user identifier. This is used to identify the transition when triggering it manually, such as with a  manual transition .    Load Asynchronously  Should the canvas controller be loaded asynchronously? By default, canvas controllers are always loaded asynchronously.    Override World Position  Specify a world position at which to place the loaded canvas controller. This can be specified as an absolute world position with the  'Position'  setting, or as a spacing multiplier with the  'World Spacing Multiplier'  setting. If  'World Spacing Multiplier'  is selected, the world position for the new canvas will be the source canvas' world position plus the canvas size scaled by the multiplier.", 
            "title": "Configuration"
        }, 
        {
            "location": "/manual/storyboards/storyboard-transitions/#passing-data-between-canvas-controllers", 
            "text": "When a transition occurs in a storyboard, the transition's source canvas controller will have its  PrepareForStoryboardTransition()  method called, passing in a  StoryboardTransition .  This gives an opportunity to pass data between canvas controllers, just as you might use a  configuration action  when presenting a canvas controller from script.  For example, in Canvas Flow's Floaty Cube example, the menu canvas controller uses the  PrepareForStoryboardTransition()  method to detect when the loading screen is being presented and to configure it with the name of the scene to load, like so:  public override void PrepareForStoryboardTransition(StoryboardTransition transition)\n{\n    var destination = transition.DestinationCanvasController();\n    if (destination is FCLoadingCanvasController  \n        transition.direction == StoryboardTransitionDirection.Downstream)\n    {\n        // We are presenting the loading screen. Configure it to present the Game scene.\n        var loadingCanvasController = (FCLoadingCanvasController)destination;\n        loadingCanvasController.SceneToLoad =  FCGameScene ;\n    }\n}", 
            "title": "Passing Data Between Canvas Controllers"
        }, 
        {
            "location": "/manual/storyboards/storyboard-transitions/#manual-transitions", 
            "text": "Manual transitions are transitions that have no origin hook - i.e. they must be triggered manually. These can be used to invoke a storyboard transition in response to non-UI events, such as a  collider  being intersected or a timer expiring.  To create a manual transition, drag from the source node's  'Manual Transitions'  element to the destination node and enter a user identifier, as shown in the video below.  \n     \n     Creating a manual transition between nodes. \n       To trigger a manual transition, call  PerformTransitionWithIdentifier()  from the source canvas controller, passing in the transition's  userIdentifier .  For example, in Canvas Flow's Floaty Cube example, an event is raised when the player reaches a target height. The game overlay screen subscribes to this event, and in the callback it triggers its manual transition named  \"PresentGameCompleteScreen\" , like so:  public void OnPlayerReachedHeight()\n{\n    PerformTransitionWithIdentifier( PresentGameCompleteScreen );\n}   Note: Any storyboard transition - not just manual transitions - can be triggered by passing its  User Identifier  to  PerformTransitionWithIdentifier() .", 
            "title": "Manual Transitions"
        }, 
        {
            "location": "/manual/storyboards/storyboard-transitions/#entry-transition", 
            "text": "When the first canvas controller is added to a storyboard, an entry transition pointing to the new canvas controller is automatically created. This is shown by the blue wire connecting the 'Entry' node to the newly-added canvas controller.  \n     \n     The storyboard's entry transition. \n       The storyboard's entry transition determines which canvas controller is presented when the storyboard is presented - i.e. the storyboard's entry point. To change the storyboard's entry point, select the  'Make storyboard entry point'  button on the canvas controller's node, as shown below.  \n     \n     Set a storyboard's entry point. \n        Note: A node can only become the entry point if it has no downstream transitions pointing to it. Similarly, if a node is the entry point, a downstream connection cannot be made to it.   The entry transition can be configured just like any other transition, as described above, with the exception that it cannot be deleted; a storyboard must have an entry point.", 
            "title": "Entry Transition"
        }, 
        {
            "location": "/manual/storyboards/storyboard-transitions/#exit-transition", 
            "text": "A storyboard exit transition is optional and is not always required. It is used in the event that you want to dismiss the entire storyboard. It will dismiss all canvas controllers that are in the storyboard's initial canvas controller's presentation hierarchy, including the initial canvas controller itself. It is the equivalent of calling  DismissAllCanvasControllers .  To create an exit transition, drag from a hook or manual transition element to the  Exit Transition  node.", 
            "title": "Exit Transition"
        }, 
        {
            "location": "/manual/storyboards/presenting-a-storyboard/", 
            "text": "Presenting A Storyboard\n\n\nStoryboards are presented from a scene. This could be a game scene, a menu scene, or any other content scene, over which the user interface is presented.\n\n\nTo present a storyboard, create a new game object in the scene, add the \nStoryboard\n component, and select your storyboard asset in the \nStoryboard\n field, as shown below. Run the scene and the storyboard will be presented.\n\n\n\n    \n\n    \nPresenting a storyboard from an empty scene.\n\n\n\n\n\n\n\nNote: A single \nUnity EventSystem\n is required to be present for canvases to receive input events. Therefore, depending on your game's structure, you may wish to place an Event System (\nGame Object/UI/Event System\n) in the scene presenting your storyboard.\n\n\n\n\nCallbacks\n\n\nAs shown above, three \nUnityEvent\n callbacks are available on a \nStoryboard\n component.\n\n\nThese callbacks can be particularly useful for passing scene data to the user interface, such as references to scene objects. For example, Canvas Flow's Floaty Cube example uses the \nStoryboardWillPresentInitialCanvasController\n callback to pass a reference to the player object to the intial game overlay screen. This allows the game overlay screen to display the player's current height. It is implemented like so:\n\n\npublic void OnGameStoryboardWillPresentInitialCanvasController(StoryboardTransition transition)\n{\n    var gameOverlayCanvasController =\n        transition.DestinationCanvasController\nFCGameOverlayCanvasController\n();\n    gameOverlayCanvasController.ConfigureWithPlayer(player);\n}\n\n\n\n\n\n\nNote: The callbacks pass a \nStoryboardTransition\n object, allowing you to access the canvas controllers involved.\n\n\n\n\nFor more information, please see the \nStoryboard component's documentation\n.", 
            "title": "Presenting A Storyboard"
        }, 
        {
            "location": "/manual/storyboards/presenting-a-storyboard/#presenting-a-storyboard", 
            "text": "Storyboards are presented from a scene. This could be a game scene, a menu scene, or any other content scene, over which the user interface is presented.  To present a storyboard, create a new game object in the scene, add the  Storyboard  component, and select your storyboard asset in the  Storyboard  field, as shown below. Run the scene and the storyboard will be presented.  \n     \n     Presenting a storyboard from an empty scene.    Note: A single  Unity EventSystem  is required to be present for canvases to receive input events. Therefore, depending on your game's structure, you may wish to place an Event System ( Game Object/UI/Event System ) in the scene presenting your storyboard.", 
            "title": "Presenting A Storyboard"
        }, 
        {
            "location": "/manual/storyboards/presenting-a-storyboard/#callbacks", 
            "text": "As shown above, three  UnityEvent  callbacks are available on a  Storyboard  component.  These callbacks can be particularly useful for passing scene data to the user interface, such as references to scene objects. For example, Canvas Flow's Floaty Cube example uses the  StoryboardWillPresentInitialCanvasController  callback to pass a reference to the player object to the intial game overlay screen. This allows the game overlay screen to display the player's current height. It is implemented like so:  public void OnGameStoryboardWillPresentInitialCanvasController(StoryboardTransition transition)\n{\n    var gameOverlayCanvasController =\n        transition.DestinationCanvasController FCGameOverlayCanvasController ();\n    gameOverlayCanvasController.ConfigureWithPlayer(player);\n}   Note: The callbacks pass a  StoryboardTransition  object, allowing you to access the canvas controllers involved.   For more information, please see the  Storyboard component's documentation .", 
            "title": "Callbacks"
        }, 
        {
            "location": "/manual/storyboards/custom-storyboard-hooks/", 
            "text": "Custom Storyboard Hooks\n\n\nCustom \nStoryboard Hooks\n allow you to use your own button types in storyboards. They will show up in the canvas preview area as \nhookable\n elements, just as native UI Buttons do.\n\n\nOverview\n\n\nA storyboard hook is a component that is attached to game objects in your canvas controller's scene. Any game object in the canvas controller's scene with a \nStoryboardHook\n component will become \nhookable\n in a storyboard.\n\n\nYou do not use the \nStoryboardHook\n component directly, however. Instead, a subclass is created that adds support for a single target component type - the component that you wish to make \nhookable\n. It is this \nStoryboardHook\n subclass that is then added to any game objects with the target component type. Additionally, the process of adding \nStoryboardHook\n subclasses to their relevant game objects can be performed automatically for you by Canvas Flow, each time a canvas controller's scene is saved.\n\n\nFor example, Canvas Flow includes one such \nStoryboardHook\n subclass - \nStoryboardHookUnityEngineUIButton\n - which is a storyboard hook for native \nUI Button\n components. It can be (and is automatically) added to any game object with a \nUI.Button\n component in order to make it \nhookable\n in a storyboard.\n\n\nIn order to make your own buttons \nhookable\n in a storyboard, you must create a similar \nStoryboardHook\n subclass for your custom button type, as documented below.\n\n\n\n\nCanvas Flow's default storyboard hook for native \nUI Button\n components is included as a .cs file. This means you can easily inspect the source code, which is recommended when creating your first custom storyboard hook. It can be found in the Project inspector at \nCanvas Flow/Storyboard Hooks/StoryboardHookUnityEngineUIButton.cs\n.\n\n\n\n\n1. Create A New Storyboard Hook Subclass\n\n\nTo begin creating a new storyboard hook, open Unity's \nCreate\n menu - by either right-clicking in the Project window or selecting Assets in the menu bar - and selecting \nCreate/Canvas Flow/Storyboard Hook\n. Enter a name and a directory for your new hook. This will generate a new \nStoryboardHook\n subclass at the specified location.\n\n\nThe generated script contains three methods for you to implement.\n\n\n\n\nConnect()\n\n\nReset()\n\n\nAutoAddComponentType\n\n\n\n\n2. Implement The Connect Method\n\n\nWhen a canvas controller is loaded from a storyboard at runtime, its connected hooks will be provided with a callback via the \nConnect()\n method. Your hook's responsibility is to simply invoke this callback when it deems itself to have been triggered. Invoking the provided callback is all that is required to trigger a storyboard transition.\n\n\nSo, in the case of the \nStoryboardHookUnityEngineUIButton\n, the callback passed to the \nConnect()\n method is attached to the button's \nonClick\n handler.  This means that when the button is clicked, the callback will be invoked, triggering the storyboard transition.\n\n\nThe source code for the \nStoryboardHookUnityEngineUIButton\n's \nConnect()\n method is therefore:\n\n\npublic override void Connect(System.Action\nStoryboardHook\n invokeTransition)\n{\n    // For a Unity UI Button we invoke our storyboard transition when\n    // our Button is clicked.\n    button.onClick.AddListener(() =\n {\n        invokeTransition(this);\n    });\n}\n\n\n\n\nYou may wish to do some additional logic here. For example, if we were making a hook to be used with a UI Toggle switch, we might only wish to trigger the transition when the toggle is switched on, like so:\n\n\npublic override void Connect(System.Action\nStoryboardHook\n invokeTransition)\n{\n    toggle.onValueChanged.AddListener(() =\n\n    {\n        // Only invoke the transition if the toggle is switched on.\n        if (toggle.isOn)\n        {\n            invokeTransition(this);\n        }\n    });\n}\n\n\n\n\n\n\nNote: You can pass your hook to the callback with \nthis\n, as above. This causes it to be included in the subsequent \nStoryboardTransition\n object that is created and passed to methods such as \nPrepareForStoryboardTransition\n.\n\n\n\n\n3. Implement The Reset Method\n\n\nThe \nReset()\n method is called on your hook in the Unity Editor when the component is added to a game object or the user resets it in the inspector. A hook can be automatically added to a game object when the scene is saved or manually added in the inspector. In either case, the \nReset()\n method is where you must do any configuration you require.\n\n\nIn the case of the \nStoryboardHookUnityEngineUIButton\n, the \nReset()\n method obtains the required reference to the \nButton\n component that is used in the \nConnect()\n method above, like so:\n\n\nprotected override void Reset()\n{\n    // Always call base.Reset() when overriding Reset() in a custom hook.\n    base.Reset();\n\n    // Store a reference to the Button component.\n    button = GetComponent\nUnityEngine.UI.Button\n();\n}\n\n\n\n\nYou might wish to follow a similar pattern, storing a reference to your custom button type that can later be used in the \nConnect()\n method.\n\n\n4. Implement The Auto-Add Component Type Property (Optional)\n\n\nWhen a canvas controller scene is saved in the Editor, Canvas Flow will ensure that storyboard hooks are present on any game objects with the hook's 'auto-add' component type. Here you can return the target type of your hook, such as your custom button type, to have your hook automatically added to any game objects with the target component type.\n\n\nFor example, Canvas Flow's default storyboard hook for native \nUI Button\n components returns the \nUI.Button\n component here, causing it to automatically be added to any game objects with a \nUI.Button\n component.\n\n\npublic override System.Type AutoAddComponentType\n{\n    get\n    {\n        // Automatically add this hook to game objects with a Unity UI\n        // Button component when the scene is saved.\n        return typeof(UnityEngine.UI.Button);\n    }\n}\n\n\n\n\n\n\nNote: This is an optional step. You may return \nnull\n here if you do not want your custom storyboard hook to automatically be added to the target component type when the scene is saved. Additionally, you can turn off \nauto-add\n for all storyboard hooks in Canvas Flow's preferences, found in the menu bar at \nUnity/Preferences/Canvas Flow\n.", 
            "title": "Custom Storyboard Hooks"
        }, 
        {
            "location": "/manual/storyboards/custom-storyboard-hooks/#custom-storyboard-hooks", 
            "text": "Custom  Storyboard Hooks  allow you to use your own button types in storyboards. They will show up in the canvas preview area as  hookable  elements, just as native UI Buttons do.", 
            "title": "Custom Storyboard Hooks"
        }, 
        {
            "location": "/manual/storyboards/custom-storyboard-hooks/#overview", 
            "text": "A storyboard hook is a component that is attached to game objects in your canvas controller's scene. Any game object in the canvas controller's scene with a  StoryboardHook  component will become  hookable  in a storyboard.  You do not use the  StoryboardHook  component directly, however. Instead, a subclass is created that adds support for a single target component type - the component that you wish to make  hookable . It is this  StoryboardHook  subclass that is then added to any game objects with the target component type. Additionally, the process of adding  StoryboardHook  subclasses to their relevant game objects can be performed automatically for you by Canvas Flow, each time a canvas controller's scene is saved.  For example, Canvas Flow includes one such  StoryboardHook  subclass -  StoryboardHookUnityEngineUIButton  - which is a storyboard hook for native  UI Button  components. It can be (and is automatically) added to any game object with a  UI.Button  component in order to make it  hookable  in a storyboard.  In order to make your own buttons  hookable  in a storyboard, you must create a similar  StoryboardHook  subclass for your custom button type, as documented below.   Canvas Flow's default storyboard hook for native  UI Button  components is included as a .cs file. This means you can easily inspect the source code, which is recommended when creating your first custom storyboard hook. It can be found in the Project inspector at  Canvas Flow/Storyboard Hooks/StoryboardHookUnityEngineUIButton.cs .", 
            "title": "Overview"
        }, 
        {
            "location": "/manual/storyboards/custom-storyboard-hooks/#1-create-a-new-storyboard-hook-subclass", 
            "text": "To begin creating a new storyboard hook, open Unity's  Create  menu - by either right-clicking in the Project window or selecting Assets in the menu bar - and selecting  Create/Canvas Flow/Storyboard Hook . Enter a name and a directory for your new hook. This will generate a new  StoryboardHook  subclass at the specified location.  The generated script contains three methods for you to implement.   Connect()  Reset()  AutoAddComponentType", 
            "title": "1. Create A New Storyboard Hook Subclass"
        }, 
        {
            "location": "/manual/storyboards/custom-storyboard-hooks/#2-implement-the-connect-method", 
            "text": "When a canvas controller is loaded from a storyboard at runtime, its connected hooks will be provided with a callback via the  Connect()  method. Your hook's responsibility is to simply invoke this callback when it deems itself to have been triggered. Invoking the provided callback is all that is required to trigger a storyboard transition.  So, in the case of the  StoryboardHookUnityEngineUIButton , the callback passed to the  Connect()  method is attached to the button's  onClick  handler.  This means that when the button is clicked, the callback will be invoked, triggering the storyboard transition.  The source code for the  StoryboardHookUnityEngineUIButton 's  Connect()  method is therefore:  public override void Connect(System.Action StoryboardHook  invokeTransition)\n{\n    // For a Unity UI Button we invoke our storyboard transition when\n    // our Button is clicked.\n    button.onClick.AddListener(() =  {\n        invokeTransition(this);\n    });\n}  You may wish to do some additional logic here. For example, if we were making a hook to be used with a UI Toggle switch, we might only wish to trigger the transition when the toggle is switched on, like so:  public override void Connect(System.Action StoryboardHook  invokeTransition)\n{\n    toggle.onValueChanged.AddListener(() = \n    {\n        // Only invoke the transition if the toggle is switched on.\n        if (toggle.isOn)\n        {\n            invokeTransition(this);\n        }\n    });\n}   Note: You can pass your hook to the callback with  this , as above. This causes it to be included in the subsequent  StoryboardTransition  object that is created and passed to methods such as  PrepareForStoryboardTransition .", 
            "title": "2. Implement The Connect Method"
        }, 
        {
            "location": "/manual/storyboards/custom-storyboard-hooks/#3-implement-the-reset-method", 
            "text": "The  Reset()  method is called on your hook in the Unity Editor when the component is added to a game object or the user resets it in the inspector. A hook can be automatically added to a game object when the scene is saved or manually added in the inspector. In either case, the  Reset()  method is where you must do any configuration you require.  In the case of the  StoryboardHookUnityEngineUIButton , the  Reset()  method obtains the required reference to the  Button  component that is used in the  Connect()  method above, like so:  protected override void Reset()\n{\n    // Always call base.Reset() when overriding Reset() in a custom hook.\n    base.Reset();\n\n    // Store a reference to the Button component.\n    button = GetComponent UnityEngine.UI.Button ();\n}  You might wish to follow a similar pattern, storing a reference to your custom button type that can later be used in the  Connect()  method.", 
            "title": "3. Implement The Reset Method"
        }, 
        {
            "location": "/manual/storyboards/custom-storyboard-hooks/#4-implement-the-auto-add-component-type-property-optional", 
            "text": "When a canvas controller scene is saved in the Editor, Canvas Flow will ensure that storyboard hooks are present on any game objects with the hook's 'auto-add' component type. Here you can return the target type of your hook, such as your custom button type, to have your hook automatically added to any game objects with the target component type.  For example, Canvas Flow's default storyboard hook for native  UI Button  components returns the  UI.Button  component here, causing it to automatically be added to any game objects with a  UI.Button  component.  public override System.Type AutoAddComponentType\n{\n    get\n    {\n        // Automatically add this hook to game objects with a Unity UI\n        // Button component when the scene is saved.\n        return typeof(UnityEngine.UI.Button);\n    }\n}   Note: This is an optional step. You may return  null  here if you do not want your custom storyboard hook to automatically be added to the target component type when the scene is saved. Additionally, you can turn off  auto-add  for all storyboard hooks in Canvas Flow's preferences, found in the menu bar at  Unity/Preferences/Canvas Flow .", 
            "title": "4. Implement The Auto-Add Component Type Property (Optional)"
        }, 
        {
            "location": "/manual/transition-animators/introduction/", 
            "text": "Transition Animators\n\n\nTransition animators are responsible for animating the transition between two canvas controllers.\n\n\nCanvas Flow includes five transition animators by default, which are:\n\n\n\n\nDefault\n\n\nFade To Color\n\n\nSlide\n\n\nScale\n\n\nScale \n Fade Background\n\n\n\n\nTo use a transition animator, you first create an instance of it, as described in \nUsing A Transition Animator\n.\n\n\nYou may also create your own transition animators to implement a custom transition animation between canvas controllers, as outlined in the \nCustom Transition Animators\n section.", 
            "title": "Introduction"
        }, 
        {
            "location": "/manual/transition-animators/introduction/#transition-animators", 
            "text": "Transition animators are responsible for animating the transition between two canvas controllers.  Canvas Flow includes five transition animators by default, which are:   Default  Fade To Color  Slide  Scale  Scale   Fade Background   To use a transition animator, you first create an instance of it, as described in  Using A Transition Animator .  You may also create your own transition animators to implement a custom transition animation between canvas controllers, as outlined in the  Custom Transition Animators  section.", 
            "title": "Transition Animators"
        }, 
        {
            "location": "/manual/transition-animators/default-transition-animators/transition-animator-default/", 
            "text": "Default Transition Animator\n\n\n\n\nTo use a transition animator, you first create an instance of it, as described in \nUsing A Transition Animator\n.\n\n\n\n\nDescription\n\n\nThe default transition animator presents content from the bottom of the screen, sliding it upwards. It dismisses content by performing the reverse - animating onscreen content downwards.\n\n\n\n    \n\n    \nA default transition animator.\n\n    \n\n\n\n\n\nConfiguration\n\n\n\n    \n\n    \nThe configurable properties of a default transition animator.\n\n    \n\n\n\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nDuration\n\n\nThe duration of the transition.\n\n\n\n\n\n\nCurve\n\n\nThe animation curve of the transition.\n\n\n\n\n\n\nUse Scaled Time\n\n\nAnimate with scaled time. By default this transition uses unscaled time - i.e. it won't be affected by changes to 'Time.timeScale'. This allows it to animate when the game is paused, for example. Enable this if you want the transition to be affected by changes to 'Time.timeScale'.", 
            "title": "Default Transition Animator"
        }, 
        {
            "location": "/manual/transition-animators/default-transition-animators/transition-animator-default/#default-transition-animator", 
            "text": "To use a transition animator, you first create an instance of it, as described in  Using A Transition Animator .", 
            "title": "Default Transition Animator"
        }, 
        {
            "location": "/manual/transition-animators/default-transition-animators/transition-animator-default/#description", 
            "text": "The default transition animator presents content from the bottom of the screen, sliding it upwards. It dismisses content by performing the reverse - animating onscreen content downwards.  \n     \n     A default transition animator.", 
            "title": "Description"
        }, 
        {
            "location": "/manual/transition-animators/default-transition-animators/transition-animator-default/#configuration", 
            "text": "The configurable properties of a default transition animator. \n          Name  Description      Duration  The duration of the transition.    Curve  The animation curve of the transition.    Use Scaled Time  Animate with scaled time. By default this transition uses unscaled time - i.e. it won't be affected by changes to 'Time.timeScale'. This allows it to animate when the game is paused, for example. Enable this if you want the transition to be affected by changes to 'Time.timeScale'.", 
            "title": "Configuration"
        }, 
        {
            "location": "/manual/transition-animators/default-transition-animators/transition-animator-fade-to-color/", 
            "text": "Fade To Color Transition Animator\n\n\n\n\nTo use a transition animator, you first create an instance of it, as described in \nUsing A Transition Animator\n.\n\n\n\n\nDescription\n\n\nThe 'fade to color' transition animator creates a color fade transition between screens.\n\n\nIt will first fade from the source content to the specified color - the 'pre-fade' - and then fade from the specified color to the destination content - the 'post-fade'.\n\n\n\n    \n\n    \nA fade to color transition animator.\n\n    \n\n\n\n\n\nConfiguration\n\n\n\n    \n\n    \nThe configurable properties of a fade to color transition animator.\n\n    \n\n\n\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nColor\n\n\nThe color of the transition.\n\n\n\n\n\n\nPre-fade Settings\n\n\nThe settings for the 'pre-fade' section of the transition.\n\n\n\n\n\n\nDuration\n\n\nThe duration of the pre-fade transition.\n\n\n\n\n\n\nCurve\n\n\nThe animation curve of the pre-fade transition.\n\n\n\n\n\n\nPre-fade Settings\n\n\nThe settings for the 'post-fade' section of the transition.\n\n\n\n\n\n\nDuration\n\n\nThe duration of the post-fade transition.\n\n\n\n\n\n\nCurve\n\n\nThe animation curve of the post-fade transition.\n\n\n\n\n\n\nUse Scaled Time\n\n\nAnimate with scaled time. By default this transition uses unscaled time - i.e. it won't be affected by changes to 'Time.timeScale'. This allows it to animate when the game is paused, for example. Enable this if you want the transition to be affected by changes to 'Time.timeScale'.", 
            "title": "Fade To Color Transition Animator"
        }, 
        {
            "location": "/manual/transition-animators/default-transition-animators/transition-animator-fade-to-color/#fade-to-color-transition-animator", 
            "text": "To use a transition animator, you first create an instance of it, as described in  Using A Transition Animator .", 
            "title": "Fade To Color Transition Animator"
        }, 
        {
            "location": "/manual/transition-animators/default-transition-animators/transition-animator-fade-to-color/#description", 
            "text": "The 'fade to color' transition animator creates a color fade transition between screens.  It will first fade from the source content to the specified color - the 'pre-fade' - and then fade from the specified color to the destination content - the 'post-fade'.  \n     \n     A fade to color transition animator.", 
            "title": "Description"
        }, 
        {
            "location": "/manual/transition-animators/default-transition-animators/transition-animator-fade-to-color/#configuration", 
            "text": "The configurable properties of a fade to color transition animator. \n          Name  Description      Color  The color of the transition.    Pre-fade Settings  The settings for the 'pre-fade' section of the transition.    Duration  The duration of the pre-fade transition.    Curve  The animation curve of the pre-fade transition.    Pre-fade Settings  The settings for the 'post-fade' section of the transition.    Duration  The duration of the post-fade transition.    Curve  The animation curve of the post-fade transition.    Use Scaled Time  Animate with scaled time. By default this transition uses unscaled time - i.e. it won't be affected by changes to 'Time.timeScale'. This allows it to animate when the game is paused, for example. Enable this if you want the transition to be affected by changes to 'Time.timeScale'.", 
            "title": "Configuration"
        }, 
        {
            "location": "/manual/transition-animators/default-transition-animators/transition-animator-slide/", 
            "text": "Slide Transition Animator\n\n\n\n\nTo use a transition animator, you first create an instance of it, as described in \nUsing A Transition Animator\n.\n\n\n\n\nDescription\n\n\nThe slide transition animation presents content by sliding it in from an off-screen location. It dismisses content by performing the reverse - sliding it to an off-screen location.\n\n\nIn addition to the presented canvas controller, the presenting canvas controller can also be animated to and from an off-screen location. This gives the appearance of the content sliding out as the presented content slides in.\n\n\nWith the \npresentingCanvasParallaxScalar\n property, you can scale the amount by which the presenter moves, creating parallax effects. A value of 1 will animate fully to the off-screen location (no parallax), whilst 0.5 would animate halfway to the off-screen location. A value of 0 has the same effect as disabling \nanimatePresentingCanvas\n.\n\n\n\n    \n\n    \nA slide transition animator.\n\n    \n\n\n\n\n\nConfiguration\n\n\n\n    \n\n    \nThe configurable properties of a slide transition animator.\n\n    \n\n\n\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nDuration\n\n\nThe duration of the transition.\n\n\n\n\n\n\nCurve\n\n\nThe animation curve of the transition.\n\n\n\n\n\n\nUse Scaled Time\n\n\nAnimate with scaled time. By default this transition uses unscaled time - i.e. it won't be affected by changes to 'Time.timeScale'. This allows it to animate when the game is paused, for example. Enable this if you want the transition to be affected by changes to 'Time.timeScale'.\n\n\n\n\n\n\nPresented Canvas\n\n\n\n\n\n\n\n\nPresented Canvas Off Screen Location\n\n\nThe off-screen location of the presented canvas.\n\n\n\n\n\n\nPresenting Canvas\n\n\n\n\n\n\n\n\nAnimate Presenting Canvas\n\n\nAnimate the presenting canvas.\n\n\n\n\n\n\nPresenting Canvas Off Screen Location\n\n\nThe off-screen location of the presenting canvas.\n\n\n\n\n\n\nPresenting Canvas Parallax Scalar\n\n\nThe presenting canvas' parallax scalar. A value of 1 will animate fully to the off-screen location (no parallax), whilst 0.5 would animate halfway to the off-screen location.", 
            "title": "Slide Transition Animator"
        }, 
        {
            "location": "/manual/transition-animators/default-transition-animators/transition-animator-slide/#slide-transition-animator", 
            "text": "To use a transition animator, you first create an instance of it, as described in  Using A Transition Animator .", 
            "title": "Slide Transition Animator"
        }, 
        {
            "location": "/manual/transition-animators/default-transition-animators/transition-animator-slide/#description", 
            "text": "The slide transition animation presents content by sliding it in from an off-screen location. It dismisses content by performing the reverse - sliding it to an off-screen location.  In addition to the presented canvas controller, the presenting canvas controller can also be animated to and from an off-screen location. This gives the appearance of the content sliding out as the presented content slides in.  With the  presentingCanvasParallaxScalar  property, you can scale the amount by which the presenter moves, creating parallax effects. A value of 1 will animate fully to the off-screen location (no parallax), whilst 0.5 would animate halfway to the off-screen location. A value of 0 has the same effect as disabling  animatePresentingCanvas .  \n     \n     A slide transition animator.", 
            "title": "Description"
        }, 
        {
            "location": "/manual/transition-animators/default-transition-animators/transition-animator-slide/#configuration", 
            "text": "The configurable properties of a slide transition animator. \n          Name  Description      Duration  The duration of the transition.    Curve  The animation curve of the transition.    Use Scaled Time  Animate with scaled time. By default this transition uses unscaled time - i.e. it won't be affected by changes to 'Time.timeScale'. This allows it to animate when the game is paused, for example. Enable this if you want the transition to be affected by changes to 'Time.timeScale'.    Presented Canvas     Presented Canvas Off Screen Location  The off-screen location of the presented canvas.    Presenting Canvas     Animate Presenting Canvas  Animate the presenting canvas.    Presenting Canvas Off Screen Location  The off-screen location of the presenting canvas.    Presenting Canvas Parallax Scalar  The presenting canvas' parallax scalar. A value of 1 will animate fully to the off-screen location (no parallax), whilst 0.5 would animate halfway to the off-screen location.", 
            "title": "Configuration"
        }, 
        {
            "location": "/manual/transition-animators/default-transition-animators/transition-animator-scale/", 
            "text": "Scale Transition Animator\n\n\n\n\nTo use a transition animator, you first create an instance of it, as described in \nUsing A Transition Animator\n.\n\n\n\n\nDescription\n\n\nThe scale transition animator presents content by scaling it up from the center of the screen. It dismisses content by performing the reverse - scaling content down.\n\n\nThe reverseCurveOnUpstream flag causes the animation curve to be evaluated backwards on upstream transitions.\n\n\n\n    \n\n    \nA scale transition animator.\n\n    \n\n\n\n\n\nConfiguration\n\n\n\n    \n\n    \nThe configurable properties of a scale transition animator.\n\n    \n\n\n\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nDuration\n\n\nThe duration of the transition.\n\n\n\n\n\n\nCurve\n\n\nThe animation curve of the transition.\n\n\n\n\n\n\nReverse Curve On Upstream\n\n\nReverse the animation curve for upstream transitions.\n\n\n\n\n\n\nUse Scaled Time\n\n\nAnimate with scaled time. By default this transition uses unscaled time - i.e. it won't be affected by changes to 'Time.timeScale'. This allows it to animate when the game is paused, for example. Enable this if you want the transition to be affected by changes to 'Time.timeScale'.", 
            "title": "Scale Transition Animator"
        }, 
        {
            "location": "/manual/transition-animators/default-transition-animators/transition-animator-scale/#scale-transition-animator", 
            "text": "To use a transition animator, you first create an instance of it, as described in  Using A Transition Animator .", 
            "title": "Scale Transition Animator"
        }, 
        {
            "location": "/manual/transition-animators/default-transition-animators/transition-animator-scale/#description", 
            "text": "The scale transition animator presents content by scaling it up from the center of the screen. It dismisses content by performing the reverse - scaling content down.  The reverseCurveOnUpstream flag causes the animation curve to be evaluated backwards on upstream transitions.  \n     \n     A scale transition animator.", 
            "title": "Description"
        }, 
        {
            "location": "/manual/transition-animators/default-transition-animators/transition-animator-scale/#configuration", 
            "text": "The configurable properties of a scale transition animator. \n          Name  Description      Duration  The duration of the transition.    Curve  The animation curve of the transition.    Reverse Curve On Upstream  Reverse the animation curve for upstream transitions.    Use Scaled Time  Animate with scaled time. By default this transition uses unscaled time - i.e. it won't be affected by changes to 'Time.timeScale'. This allows it to animate when the game is paused, for example. Enable this if you want the transition to be affected by changes to 'Time.timeScale'.", 
            "title": "Configuration"
        }, 
        {
            "location": "/manual/transition-animators/default-transition-animators/transition-animator-scale-and-fade/", 
            "text": "Scale And Fade Background Transition Animator\n\n\n\n\nTo use a transition animator, you first create an instance of it, as described in \nUsing A Transition Animator\n.\n\n\n\n\nDescription\n\n\nThe 'scale and fade background' transition animator presents content by scaling it up from the center of the screen, whilst fading in the backgroundImage property. It dismisses content by performing the reverse - scaling content down and fading out the backgroundImage property.\n\n\nThe \ncontentToScalePropertyName\n field allows you to specify what content gets scaled in your transition. You can set this to the name of any \nRectTransform\n property on your canvas controller. If none is specified or the property does not exist, the canvas controller's 'content' transform will be scaled.\n\n\nThe \nreverseScaleCurveOnUpstream\n and \nreverseFadeCurveOnUpstream\n flags cause the relevant animation curves to be evaluated backwards on upstream transitions.\n\n\n\n    \n\n    \nA scale transition animator.\n\n    \n\n\n\n\n\nConfiguration\n\n\n\n    \n\n    \nThe configurable properties of a scale and fade background transition animator.\n\n    \n\n\n\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nDuration\n\n\nThe duration of the transition.\n\n\n\n\n\n\nScale Settings\n\n\n\n\n\n\n\n\nScale Curve\n\n\nThe animation curve for the scaling animation of the transition.\n\n\n\n\n\n\nContent To Scale Property Name\n\n\nThe property name of the content to be scaled.\n\n\n\n\n\n\nReverse Scale Curve On Upstream\n\n\nReverse the scale animation curve for upstream transitions.\n\n\n\n\n\n\nFade Settings\n\n\n\n\n\n\n\n\nFade Curve\n\n\nThe animation curve for the fading animation of the transition.\n\n\n\n\n\n\nReverse Fade Curve On Upstream\n\n\nReverse the fade animation curve for upstream transitions.\n\n\n\n\n\n\nUse Scaled Time\n\n\nAnimate with scaled time. By default this transition uses unscaled time - i.e. it won't be affected by changes to 'Time.timeScale'. This allows it to animate when the game is paused, for example. Enable this if you want the transition to be affected by changes to 'Time.timeScale'.", 
            "title": "Scale And Fade Background Transition Animator"
        }, 
        {
            "location": "/manual/transition-animators/default-transition-animators/transition-animator-scale-and-fade/#scale-and-fade-background-transition-animator", 
            "text": "To use a transition animator, you first create an instance of it, as described in  Using A Transition Animator .", 
            "title": "Scale And Fade Background Transition Animator"
        }, 
        {
            "location": "/manual/transition-animators/default-transition-animators/transition-animator-scale-and-fade/#description", 
            "text": "The 'scale and fade background' transition animator presents content by scaling it up from the center of the screen, whilst fading in the backgroundImage property. It dismisses content by performing the reverse - scaling content down and fading out the backgroundImage property.  The  contentToScalePropertyName  field allows you to specify what content gets scaled in your transition. You can set this to the name of any  RectTransform  property on your canvas controller. If none is specified or the property does not exist, the canvas controller's 'content' transform will be scaled.  The  reverseScaleCurveOnUpstream  and  reverseFadeCurveOnUpstream  flags cause the relevant animation curves to be evaluated backwards on upstream transitions.  \n     \n     A scale transition animator.", 
            "title": "Description"
        }, 
        {
            "location": "/manual/transition-animators/default-transition-animators/transition-animator-scale-and-fade/#configuration", 
            "text": "The configurable properties of a scale and fade background transition animator. \n          Name  Description      Duration  The duration of the transition.    Scale Settings     Scale Curve  The animation curve for the scaling animation of the transition.    Content To Scale Property Name  The property name of the content to be scaled.    Reverse Scale Curve On Upstream  Reverse the scale animation curve for upstream transitions.    Fade Settings     Fade Curve  The animation curve for the fading animation of the transition.    Reverse Fade Curve On Upstream  Reverse the fade animation curve for upstream transitions.    Use Scaled Time  Animate with scaled time. By default this transition uses unscaled time - i.e. it won't be affected by changes to 'Time.timeScale'. This allows it to animate when the game is paused, for example. Enable this if you want the transition to be affected by changes to 'Time.timeScale'.", 
            "title": "Configuration"
        }, 
        {
            "location": "/manual/transition-animators/using-a-transition-animator/", 
            "text": "Using A Transition Animator\n\n\nCreate An Instance\n\n\nTo use a transition animator, begin by creating an instance of it. All available transition animators are listed in Unity's \nCreate\n menu, accessed by either right-clicking in the Project window or selecting Assets in the menu bar.\n\n\n\n    \n\n    \nThe available transition animators are listed in the Create menu.\n\n    \n\n\n\n\n\nThis will create a new \ntransition animator\n asset in your project. Select the new transition animator instance to open the inspector and view its properties. Here you can adjust any exposed properties on the transition animator, allowing you to tweak each transition animator on a per instance basis. For example, the \nFade To Color\n animator exposes the following properties:\n\n\n\n    \n\n    \nThe 'Fade To Color' transition animator inspector.\n\n    \n\n\n\n\n\n\n\nYou can have many instances of the same transition animator in your project, each configured differently. For example, you might have two instances of the 'Fade To Color' animator, one that fades to black, and one that fades to white.\n\n\n\n\nUsing With Storyboards\n\n\nTo use this new transition animator instance in a storyboard transition, simply select the transition in the storyboard, and drop the instance onto the \nCustom Animator\n field, as shown in the video below. This transition will now be animated by the specified instance.\n\n\n\n    \n\n    \nSetting a transition animator on a storyboard transition.\n\n    \n\n\n\n\n\nUsing Directly With Canvas Controllers\n\n\nTo use a transition animator instance when presenting and dismissing canvas controllers from script, you must provide, or \nvend\n, the animator instance to Canvas Flow when the transition is about to be performed. This process is as follows:\n\n\nWhen a transition is to be performed, the target canvas controller's\n1\n \ntransitioningAnimatorVendor\n will be asked to provide an animator for the transition. You should therefore specify the target canvas controller's \ntransitioningAnimatorVendor\n and return your animator instance in the \nTransitioningAnimatorForContext\n method.\n\n\n1. The target canvas controller is the canvas controller being acted upon - i.e. the canvas controler being presented or being dismissed. Therefore, in a presentation, this will be the transition context's \ndestinationCanvasController\n, whereas in a dismissal, this will be the transition context's \nsourceCanvasController\n.\n\n\nFor example, in Canvas Flow's Transitions example, the menu screen sets itself as the \ntransitioningAnimatorVendor\n when presenting a canvas controller. This is done in the configuration action, as shown below.\n\n\nPresentCanvasController\nTEFadeTransitionCanvasController\n(\n    configuration: (fadeDescriptionCanvasController) =\n\n{\n    fadeDescriptionCanvasController.transitioningAnimatorVendor = this;\n});\n\n\n\n\nThen the menu screen implements the required \nTransitioningAnimatorForContext\n method, returning the appropriate transition animator based upon the context.\n\n\n// Set in the inspector.\npublic CanvasControllerTransitioningAnimator fadeTransitionAnimator;\n\npublic ICanvasControllerTransitioningAnimator TransitioningAnimatorForContext(\n    CanvasControllerTransitionContext transitionContext)\n{\n    // The presented canvas controller is the destination on downstream transitions (Present)\n    // and the source on upstream transitions (Dismiss).\n    CanvasController presentedCanvasController = (transitionContext.isUpstream) ?\n        transitionContext.sourceCanvasController : transitionContext.destinationCanvasController;\n\n    if (presentedCanvasController is TEFadeTransitionCanvasController)\n    {\n      return fadeTransitionAnimator;\n    }\n\n    return null\n}\n\n\n\n\n\n\nYou may return \nnull\n in your TransitioningAnimatorForContext implementation to use the default transition animator. For example, in the above implementation, we only use our fade animator if we are transitioning to or from the \nTEFadeTransitionCanvasController\n, otherwise \nnull\n is returned and the default animator is used.", 
            "title": "Using A Transition Animator"
        }, 
        {
            "location": "/manual/transition-animators/using-a-transition-animator/#using-a-transition-animator", 
            "text": "", 
            "title": "Using A Transition Animator"
        }, 
        {
            "location": "/manual/transition-animators/using-a-transition-animator/#create-an-instance", 
            "text": "To use a transition animator, begin by creating an instance of it. All available transition animators are listed in Unity's  Create  menu, accessed by either right-clicking in the Project window or selecting Assets in the menu bar.  \n     \n     The available transition animators are listed in the Create menu. \n       This will create a new  transition animator  asset in your project. Select the new transition animator instance to open the inspector and view its properties. Here you can adjust any exposed properties on the transition animator, allowing you to tweak each transition animator on a per instance basis. For example, the  Fade To Color  animator exposes the following properties:  \n     \n     The 'Fade To Color' transition animator inspector. \n        You can have many instances of the same transition animator in your project, each configured differently. For example, you might have two instances of the 'Fade To Color' animator, one that fades to black, and one that fades to white.", 
            "title": "Create An Instance"
        }, 
        {
            "location": "/manual/transition-animators/using-a-transition-animator/#using-with-storyboards", 
            "text": "To use this new transition animator instance in a storyboard transition, simply select the transition in the storyboard, and drop the instance onto the  Custom Animator  field, as shown in the video below. This transition will now be animated by the specified instance.  \n     \n     Setting a transition animator on a storyboard transition.", 
            "title": "Using With Storyboards"
        }, 
        {
            "location": "/manual/transition-animators/using-a-transition-animator/#using-directly-with-canvas-controllers", 
            "text": "To use a transition animator instance when presenting and dismissing canvas controllers from script, you must provide, or  vend , the animator instance to Canvas Flow when the transition is about to be performed. This process is as follows:  When a transition is to be performed, the target canvas controller's 1   transitioningAnimatorVendor  will be asked to provide an animator for the transition. You should therefore specify the target canvas controller's  transitioningAnimatorVendor  and return your animator instance in the  TransitioningAnimatorForContext  method.  1. The target canvas controller is the canvas controller being acted upon - i.e. the canvas controler being presented or being dismissed. Therefore, in a presentation, this will be the transition context's  destinationCanvasController , whereas in a dismissal, this will be the transition context's  sourceCanvasController .  For example, in Canvas Flow's Transitions example, the menu screen sets itself as the  transitioningAnimatorVendor  when presenting a canvas controller. This is done in the configuration action, as shown below.  PresentCanvasController TEFadeTransitionCanvasController (\n    configuration: (fadeDescriptionCanvasController) = \n{\n    fadeDescriptionCanvasController.transitioningAnimatorVendor = this;\n});  Then the menu screen implements the required  TransitioningAnimatorForContext  method, returning the appropriate transition animator based upon the context.  // Set in the inspector.\npublic CanvasControllerTransitioningAnimator fadeTransitionAnimator;\n\npublic ICanvasControllerTransitioningAnimator TransitioningAnimatorForContext(\n    CanvasControllerTransitionContext transitionContext)\n{\n    // The presented canvas controller is the destination on downstream transitions (Present)\n    // and the source on upstream transitions (Dismiss).\n    CanvasController presentedCanvasController = (transitionContext.isUpstream) ?\n        transitionContext.sourceCanvasController : transitionContext.destinationCanvasController;\n\n    if (presentedCanvasController is TEFadeTransitionCanvasController)\n    {\n      return fadeTransitionAnimator;\n    }\n\n    return null\n}   You may return  null  in your TransitioningAnimatorForContext implementation to use the default transition animator. For example, in the above implementation, we only use our fade animator if we are transitioning to or from the  TEFadeTransitionCanvasController , otherwise  null  is returned and the default animator is used.", 
            "title": "Using Directly With Canvas Controllers"
        }, 
        {
            "location": "/manual/transition-animators/custom-transition-animators/", 
            "text": "Custom Transition Animators\n\n\nYou may create your own transition animators to implement a custom transition animation between canvas controllers. If following the steps below, your custom transition animator will be displayed in Unity's \nCreate\n menu alongside the default transition animators, and will therefore also be compatible with storyboards.\n\n\n\n\nCanvas Flow's default transition animators are included as .cs files. This means you can easily inspect their source code, which is recommended when creating your first custom transition animator. They can be found in the Project inspector at \nCanvas Flow/Transition Animators/\n.\n\n\n\n\n1. Create A Custom Transition Animator Script\n\n\nTo begin creating a new transition animator, open Unity's \nCreate\n menu - by either right-clicking in the Project window or selecting Assets in the menu bar - and selecting \nCreate/Canvas Flow/Custom Transition Animator\n. Enter a name and a directory for your new animator. This will generate a new transition animator script file at the specified location.\n\n\nThe generated script contains two methods for you to implement.\n\n\n\n\nAnimateTransition()\n\n\nAnimateTransitionInvolvingRootCanvasController()\n\n\n\n\n2. The Animate Transition Method\n\n\nAs described in \nUsing A Transition Animator\n, an instance of your custom transition animator will be \nvended\n to Canvas Flow at runtime when the transition is about to be performed. Once this has occurred, Canvas Flow will tell the transition animator to perform the transition by calling its \nAnimateTransition()\n method. This is where you can perform your custom animation. Please see \nPerforming The Animation\n for more details.\n\n\npublic override void AnimateTransition(CanvasControllerTransitionContext transitionContext)\n{\n    /*  \n      *  Do your custom animation with the source and destination content\n      *  here. For example:\n      *\n      *  CanvasController source = transitionContext.sourceCanvasController;\n      *  CanvasController destination = transitionContext.destinationCanvasController;\n      *\n      *  source.ContentPosition = ...\n      *  destination.ContentScale = ...\n      */\n\n    /*  \n     *  Call CompleteTransition() on the transition context once you have\n     *  performed your custom animation.\n     */\n    transitionContext.CompleteTransition();\n}\n\n\n\n\n\n\nWhen your transition animator has completed its animation, you must call \nCompleteTransition\n on the provided transition context. This tells Canvas Flow that the custom animation has been performed and to complete the transition.\n\n\n\n\n3. The Animate Transition Involving Root Canvas Controller Method (Optional)\n\n\nThe \nAnimateTransitionInvolvingRootCanvasController()\n method is called on your transition animator when the transition to be animated involves a root canvas controller. A root canvas controller is one with no presenter - i.e. it was the first canvas controller presented, perhaps from a storyboard entry transition or using PresentInitialCanvasController(). Therefore, you only need to implement this method if you intend to use your transition animator on root transitions.\n\n\nThe only difference from the \nAnimateTransition\n method is that either the context's \nsourceCanvasController\n or \ndestinationCanvasController\n will be null, depending on whether the transition context \nisUpstream\n - i.e. it is presenting/dismissing to \n'nothing'\n.\n\n\nThe default transition animator, found in \nCanvas Flow/Transition Animators/DefaultTransitionAnimator.cs\n simply forwards this method to \nAnimateTransition()\n as it only ever operates on the presented canvas, like so:\n\n\npublic override void AnimateTransitionInvolvingRootCanvasController(\n    CanvasControllerTransitionContext transitionContext)\n{\n    /*\n      *  We support transitions to and from the root canvas controller by default\n      *  in our main AnimateTransition() method as we only operate on the\n      *  presented canvas controller, so we can just forward to that method.\n      */\n\n    AnimateTransition(transitionContext);\n}\n\n\n\n\nPlease see \nCanvas Flow/Transition Animators/FadeToColorTransitionAnimator.cs\n for an example of how different behaviour can be implemented when presenting/dismissing the root canvas controller.\n\n\n4. Performing The Animation\n\n\nBelow is an example of a complete \nAnimateTransition\n method, which animates the presented canvas controller from/to the bottom of the screen. This will serve as a basis for presenting several useful pointers when animating canvas controllers.\n\n\n\n\nNote that you are free to animate the context's canvas controllers however you wish, including using external animation tools.\n\n\n\n\npublic override void AnimateTransition(CanvasControllerTransitionContext transitionContext)\n{\n    // Determine the target canvas controller - the one being presented or dismissed.\n    var targetCanvasController = (transitionContext.isUpstream) ?\n        transitionContext.sourceCanvasController :\n            transitionContext.destinationCanvasController;\n\n    // Determine the content's start position.\n    Vector3 contentStartPosition = (transitionContext.isUpstream) ?\n        targetCanvasController.OnScreenContentPosition() :\n            targetCanvasController.OffScreenBottomContentPosition();\n\n    // Determine the content's end position.\n    Vector3 contentEndPosition = (transitionContext.isUpstream) ?\n        targetCanvasController.OffScreenBottomContentPosition() :\n            targetCanvasController.OnScreenContentPosition();\n\n    // Create a routine lasting `duration` seconds.\n    Routine animation = new Routine(duration);\n\n    // Execute the routine.\n    animation.Run(OnUpdate: (progress01) =\n\n    {\n        // The update action is called every frame for the routine's duration,\n        // passing in a progress01 value.\n\n        // Move the canvas controller's content from the start position\n        // to the end position, each frame.\n        targetCanvasController.ContentPosition = Vector3.LerpUnclamped(\n                    contentStartPosition,\n                    contentEndPosition,\n                    progress01);\n\n    }, OnComplete: () =\n\n    {\n        // The completion action is called after `duration` seconds.\n        transitionContext.CompleteTransition();\n    });\n}\n\n\n\n\nThe Content Transform\n\n\nTo move a canvas controller's content, the \nContentPosition\n (or \ncontent.localPosition\n) should be animated. Animating the canvas' transform itself will cause the canvas' \ncamera\n to move with it, which, although moving the canvas in world space, will have no effect on the canvas' screen position. \n\n\nSimilarly, to scale or rotate the canvas, you should also perform these operations on the canvas controller's \ncontent\n transform.\n\n\nUse The Helper Positioning Methods\n\n\nA canvas controller has several extension methods to help with positioning a canvas controller's content transform. These are used above to calculate the content's on/off-screen position.\n\n\n\n\nOnScreenContentPosition\n\n\nOffScreenBottomContentPosition\n\n\nOffScreenLeftContentPosition\n\n\nOffScreenTopContentPosition\n\n\n\n\nRoutine\n\n\nThe above example, as well as all default transition animators, use Canvas Flow's \nRoutine\n class to perform their animation. You may also use this class to easily create a \ncoroutine\n with a progress and completion callback, as above.\n\n\nComplete The Transition\n\n\nWhen your transition animator has completed its animation, you \nmust\n call \nCompleteTransition\n on the provided transition context. This tells Canvas Flow that the custom animation has been performed and to complete the transition.\n\n\n5. Use Your Custom Transition Animator\n\n\nOnce your custom transition animator is complete, it will be available to select in Unity's \nCreate\n menu. Please refer to \nUsing A Transition Animator\n to create an instance of your custom animator.", 
            "title": "Custom Transition Animators"
        }, 
        {
            "location": "/manual/transition-animators/custom-transition-animators/#custom-transition-animators", 
            "text": "You may create your own transition animators to implement a custom transition animation between canvas controllers. If following the steps below, your custom transition animator will be displayed in Unity's  Create  menu alongside the default transition animators, and will therefore also be compatible with storyboards.   Canvas Flow's default transition animators are included as .cs files. This means you can easily inspect their source code, which is recommended when creating your first custom transition animator. They can be found in the Project inspector at  Canvas Flow/Transition Animators/ .", 
            "title": "Custom Transition Animators"
        }, 
        {
            "location": "/manual/transition-animators/custom-transition-animators/#1-create-a-custom-transition-animator-script", 
            "text": "To begin creating a new transition animator, open Unity's  Create  menu - by either right-clicking in the Project window or selecting Assets in the menu bar - and selecting  Create/Canvas Flow/Custom Transition Animator . Enter a name and a directory for your new animator. This will generate a new transition animator script file at the specified location.  The generated script contains two methods for you to implement.   AnimateTransition()  AnimateTransitionInvolvingRootCanvasController()", 
            "title": "1. Create A Custom Transition Animator Script"
        }, 
        {
            "location": "/manual/transition-animators/custom-transition-animators/#2-the-animate-transition-method", 
            "text": "As described in  Using A Transition Animator , an instance of your custom transition animator will be  vended  to Canvas Flow at runtime when the transition is about to be performed. Once this has occurred, Canvas Flow will tell the transition animator to perform the transition by calling its  AnimateTransition()  method. This is where you can perform your custom animation. Please see  Performing The Animation  for more details.  public override void AnimateTransition(CanvasControllerTransitionContext transitionContext)\n{\n    /*  \n      *  Do your custom animation with the source and destination content\n      *  here. For example:\n      *\n      *  CanvasController source = transitionContext.sourceCanvasController;\n      *  CanvasController destination = transitionContext.destinationCanvasController;\n      *\n      *  source.ContentPosition = ...\n      *  destination.ContentScale = ...\n      */\n\n    /*  \n     *  Call CompleteTransition() on the transition context once you have\n     *  performed your custom animation.\n     */\n    transitionContext.CompleteTransition();\n}   When your transition animator has completed its animation, you must call  CompleteTransition  on the provided transition context. This tells Canvas Flow that the custom animation has been performed and to complete the transition.", 
            "title": "2. The Animate Transition Method"
        }, 
        {
            "location": "/manual/transition-animators/custom-transition-animators/#3-the-animate-transition-involving-root-canvas-controller-method-optional", 
            "text": "The  AnimateTransitionInvolvingRootCanvasController()  method is called on your transition animator when the transition to be animated involves a root canvas controller. A root canvas controller is one with no presenter - i.e. it was the first canvas controller presented, perhaps from a storyboard entry transition or using PresentInitialCanvasController(). Therefore, you only need to implement this method if you intend to use your transition animator on root transitions.  The only difference from the  AnimateTransition  method is that either the context's  sourceCanvasController  or  destinationCanvasController  will be null, depending on whether the transition context  isUpstream  - i.e. it is presenting/dismissing to  'nothing' .  The default transition animator, found in  Canvas Flow/Transition Animators/DefaultTransitionAnimator.cs  simply forwards this method to  AnimateTransition()  as it only ever operates on the presented canvas, like so:  public override void AnimateTransitionInvolvingRootCanvasController(\n    CanvasControllerTransitionContext transitionContext)\n{\n    /*\n      *  We support transitions to and from the root canvas controller by default\n      *  in our main AnimateTransition() method as we only operate on the\n      *  presented canvas controller, so we can just forward to that method.\n      */\n\n    AnimateTransition(transitionContext);\n}  Please see  Canvas Flow/Transition Animators/FadeToColorTransitionAnimator.cs  for an example of how different behaviour can be implemented when presenting/dismissing the root canvas controller.", 
            "title": "3. The Animate Transition Involving Root Canvas Controller Method (Optional)"
        }, 
        {
            "location": "/manual/transition-animators/custom-transition-animators/#4-performing-the-animation", 
            "text": "Below is an example of a complete  AnimateTransition  method, which animates the presented canvas controller from/to the bottom of the screen. This will serve as a basis for presenting several useful pointers when animating canvas controllers.   Note that you are free to animate the context's canvas controllers however you wish, including using external animation tools.   public override void AnimateTransition(CanvasControllerTransitionContext transitionContext)\n{\n    // Determine the target canvas controller - the one being presented or dismissed.\n    var targetCanvasController = (transitionContext.isUpstream) ?\n        transitionContext.sourceCanvasController :\n            transitionContext.destinationCanvasController;\n\n    // Determine the content's start position.\n    Vector3 contentStartPosition = (transitionContext.isUpstream) ?\n        targetCanvasController.OnScreenContentPosition() :\n            targetCanvasController.OffScreenBottomContentPosition();\n\n    // Determine the content's end position.\n    Vector3 contentEndPosition = (transitionContext.isUpstream) ?\n        targetCanvasController.OffScreenBottomContentPosition() :\n            targetCanvasController.OnScreenContentPosition();\n\n    // Create a routine lasting `duration` seconds.\n    Routine animation = new Routine(duration);\n\n    // Execute the routine.\n    animation.Run(OnUpdate: (progress01) = \n    {\n        // The update action is called every frame for the routine's duration,\n        // passing in a progress01 value.\n\n        // Move the canvas controller's content from the start position\n        // to the end position, each frame.\n        targetCanvasController.ContentPosition = Vector3.LerpUnclamped(\n                    contentStartPosition,\n                    contentEndPosition,\n                    progress01);\n\n    }, OnComplete: () = \n    {\n        // The completion action is called after `duration` seconds.\n        transitionContext.CompleteTransition();\n    });\n}", 
            "title": "4. Performing The Animation"
        }, 
        {
            "location": "/manual/transition-animators/custom-transition-animators/#the-content-transform", 
            "text": "To move a canvas controller's content, the  ContentPosition  (or  content.localPosition ) should be animated. Animating the canvas' transform itself will cause the canvas'  camera  to move with it, which, although moving the canvas in world space, will have no effect on the canvas' screen position.   Similarly, to scale or rotate the canvas, you should also perform these operations on the canvas controller's  content  transform.", 
            "title": "The Content Transform"
        }, 
        {
            "location": "/manual/transition-animators/custom-transition-animators/#use-the-helper-positioning-methods", 
            "text": "A canvas controller has several extension methods to help with positioning a canvas controller's content transform. These are used above to calculate the content's on/off-screen position.   OnScreenContentPosition  OffScreenBottomContentPosition  OffScreenLeftContentPosition  OffScreenTopContentPosition", 
            "title": "Use The Helper Positioning Methods"
        }, 
        {
            "location": "/manual/transition-animators/custom-transition-animators/#routine", 
            "text": "The above example, as well as all default transition animators, use Canvas Flow's  Routine  class to perform their animation. You may also use this class to easily create a  coroutine  with a progress and completion callback, as above.", 
            "title": "Routine"
        }, 
        {
            "location": "/manual/transition-animators/custom-transition-animators/#complete-the-transition", 
            "text": "When your transition animator has completed its animation, you  must  call  CompleteTransition  on the provided transition context. This tells Canvas Flow that the custom animation has been performed and to complete the transition.", 
            "title": "Complete The Transition"
        }, 
        {
            "location": "/manual/transition-animators/custom-transition-animators/#5-use-your-custom-transition-animator", 
            "text": "Once your custom transition animator is complete, it will be available to select in Unity's  Create  menu. Please refer to  Using A Transition Animator  to create an instance of your custom animator.", 
            "title": "5. Use Your Custom Transition Animator"
        }, 
        {
            "location": "/scripting-reference/overview/", 
            "text": "Overview", 
            "title": "Scripting Reference"
        }, 
        {
            "location": "/scripting-reference/overview/#overview", 
            "text": "", 
            "title": "Overview"
        }
    ]
}